<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 20px;
            width: 100%;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        #dropZone.dragover {
            background-color: #e1e1e1;
        }

        #fileInput,
        #logoInput {
            display: none;
        }

        #status {
            margin-top: 20px;
        }

        .mode-buttons {
            margin-bottom: 20px;
        }

        .mode-button {
            margin-right: 10px;
            padding: 10px 15px;
            background-color: #ccc;
            border: none;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .mode-button.active {
            background-color: #007bff;
            color: #fff;
        }

        #logoPreview {
            max-width: 100px;
            max-height: 100px;
            margin-top: 10px;
            display: none;
        }

        #screenshotArrange,
        #borderlessScreenshotArrange {
            margin-top: 30px;
            text-align: center;
        }

        #fileInput2,
        #borderlessFileInput2 {
            margin-bottom: 10px;
        }

        #canvasContainer,
        #borderlessCanvasContainer {
            position: relative;
            display: inline-block;
        }

        #canvas,
        #borderlessCanvas {
            border: 1px solid #000;
        }

        #imageList,
        #borderlessImageList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .image-item {
            width: 150px;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: move;
            position: relative;
            user-select: none;
        }

        .image-item img {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
        }

        .image-item.dragging {
            opacity: 0.5;
        }

        .image-item.drag-over {
            border: 2px dashed #000;
        }

        .delete-button {
            margin-top: 5px;
            padding: 2px 5px;
            background-color: #cc0000;
            color: white;
            border: none;
            cursor: pointer;
        }

        #downloadButton,
        #borderlessDownloadButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            display: none;
        }

        #editTools,
        #borderlessEditTools {
            margin-top: 10px;
        }

        #editTools button,
        #borderlessEditTools button,
        #previewEditTools button {
            margin-right: 5px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        #editTools button:hover,
        #borderlessEditTools button:hover,
        #previewEditTools button:hover {
            background-color: #e0e0e0;
        }

        #editCanvas,
        #borderlessEditCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #clearAllButton,
        #borderlessClearAllButton {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            cursor: pointer;
        }

        /* ç¸®æ”¾å“è³ªé¸é …æ¨£å¼ */
        .quality-control {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .quality-control label {
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
            color: #495057;
        }

        .quality-control select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: white;
            font-size: 14px;
        }

        .quality-info {
            margin-top: 8px;
            font-size: 12px;
            color: #6c757d;
            line-height: 1.4;
        }

        .quality-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 5px;
        }

        .badge-ultra {
            background-color: #28a745;
            color: white;
        }

        .badge-high {
            background-color: #17a2b8;
            color: white;
        }

        .badge-balanced {
            background-color: #ffc107;
            color: black;
        }

        .badge-fast {
            background-color: #dc3545;
            color: white;
        }
    </style>
</head>

<body>
    <h1 id="pageTitle">åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ <small style="color: #666; font-size: 0.6em;">(ä¿®å¾©ç·šæ¢å•é¡Œ)</small></h1>

    <!-- ç¸®æ”¾å“è³ªæ§åˆ¶ -->
    <div class="quality-control">
        <label for="scalingQuality">ğŸ¯ ç¸®æ”¾å“è³ªé¸æ“‡ï¼š</label>
        <select id="scalingQuality">
            <option value="ultra">è¶…é«˜å“è³ª - å¤šæ­¥é©Ÿç¸®æ”¾ (ç„¡éŠ³åŒ–)</option>
            <option value="high">é«˜å“è³ª - é«˜å“è³ªCanvasç¸®æ”¾</option>
            <option value="balanced" selected>å¹³è¡¡ - æ¨™æº–é«˜å“è³ªç¸®æ”¾ (é è¨­)</option>
            <option value="fast">å¿«é€Ÿ - èˆ‡åŸç‰ˆç›¸åŒ</option>
        </select>
        <div class="quality-info">
            <div id="qualityDescription">
                <span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>
                ä½¿ç”¨é«˜å“è³ªCanvasç¸®æ”¾ï¼Œåœ¨å“è³ªå’Œé€Ÿåº¦é–“å–å¾—å¹³è¡¡ï¼Œå·²ä¿®å¾©ç·šæ¢å•é¡Œ
            </div>
        </div>
    </div>

    <div class="mode-buttons">
        <button id="cropImageMode" class="mode-button active">åœ–ç‰‡è£åˆ‡</button>
        <button id="resize320Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰</button>
        <button id="resize1080Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰</button>
        <button id="addWatermarkMode" class="mode-button">æ·»åŠ æµ®æ°´å°</button>
        <button id="adaSpecialMode" class="mode-button">é›»è…¦ç‹é˜¿é”å°ˆç”¨</button>
        <button id="screenshotArrangeMode" class="mode-button">æˆªåœ–ä¸¦æ’</button>
        <button id="borderlessScreenshotArrangeMode" class="mode-button">ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’</button>
    </div>
    <div id="dropZone">
        <p>æ‹–æ›³åœ–ç‰‡åˆ°é€™è£¡æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*">
    <div id="status"></div>

    <!-- çµ±ä¸€é è¦½å’Œç·¨è¼¯å€åŸŸ -->
    <div id="previewArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>è™•ç†çµæœé è¦½</h3>
        <div id="previewCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="previewCanvas"
                style="border: 1px solid #000; max-width: 100%; height: auto; display: block;"></canvas>
            <canvas id="previewEditCanvas"
                style="position: absolute; top: 0; left: 0; cursor: crosshair; width: 100%; height: 100%;"></canvas>
            <button id="previewDownloadButton"
                style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="previewEditTools" style="margin-top: 10px;">
            <button id="previewRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="previewWatermarkTool">æµ®æ°´å°</button>
            <input type="file" id="previewWatermarkInput" accept="image/*" style="display: none;">
            <button id="previewArrowTool">ç®­é ­å·¥å…·</button>
            <button id="previewMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="previewUndoButton">å¾©åŸ</button>
            <button id="previewClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
        <div style="margin-top: 10px;">
            <button id="processMoreButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; margin-right: 10px;">è™•ç†æ›´å¤šåœ–ç‰‡</button>
            <button id="clearPreviewButton"
                style="padding: 10px 15px; background-color: #6c757d; color: white; border: none; cursor: pointer; margin-right: 10px;">æ¸…é™¤é è¦½</button>
            <button id="downloadPNGButton"
                style="padding: 10px 15px; background-color: #28a745; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰PNGé«˜ç•«è³ª</button>
        </div>
    </div>
    <div>
        <button id="selectLogoBtn" style="display: none;">é¸æ“‡ Logo</button>
        <button id="selectAdaLogoBtn" style="display: none;">é¸æ“‡é˜¿é”å°ˆç”¨ Logo</button>
        <input type="file" id="logoInput" accept="image/*" style="display: none;">
        <span id="logoStatus"></span>
        <img id="logoPreview" alt="Logo Preview" style="display: none;">
    </div>

    <div id="screenshotArrange" style="display: none;">
        <input type="file" id="fileInput2" multiple accept="image/*">
        <span id="fileCount"></span>
        <button id="clearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="imageList"></div>
        <button id="processButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            <canvas id="editCanvas"></canvas>
            <button id="downloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="editTools">
            <button id="rectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="arrowTool">ç®­é ­å·¥å…·</button>
            <button id="watermarkTool">æµ®æ°´å°</button>
            <button id="mosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="undoButton">å¾©åŸ</button>
            <button id="clearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <!-- ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’åŠŸèƒ½ -->
    <div id="borderlessScreenshotArrange" style="display: none;">
        <input type="file" id="borderlessFileInput2" multiple accept="image/*">
        <span id="borderlessFileCount"></span>
        <button id="borderlessClearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="borderlessImageList"></div>
        <button id="borderlessProcessButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="borderlessCanvasContainer">
            <canvas id="borderlessCanvas"></canvas>
            <canvas id="borderlessEditCanvas"></canvas>
            <button id="borderlessDownloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="borderlessEditTools">
            <button id="borderlessRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="borderlessArrowTool">ç®­é ­å·¥å…·</button>
            <button id="borderlessWatermarkTool">æµ®æ°´å°</button>
            <button id="borderlessMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="borderlessUndoButton">å¾©åŸ</button>
            <button id="borderlessClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <!-- åœ–ç‰‡è£åˆ‡åŠŸèƒ½å€å¡Š -->
    <div id="cropImageArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>åœ–ç‰‡è£åˆ‡</h3>
        <div id="cropCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="cropCanvas" style="border: 1px solid #000;"></canvas>
            <canvas id="cropSelectionCanvas" style="position: absolute; top: 0; left: 0; z-index: 10;"></canvas>
        </div>
        <div style="margin-top: 10px;">
            <button id="executeCropButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer;">åŸ·è¡Œè£åˆ‡</button>
            <button id="cancelCropButton"
                style="padding: 10px 15px; background-color: #dc3545; color: white; border: none; cursor: pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.0/dist/browser-image-compression.js"></script>
    <script>
        // Define global constants for max crop dimensions
        const MAX_CROP_WIDTH = 1000; // é™åˆ¶è£åˆ‡é è¦½å¯¬åº¦ç‚º1000px
        const MAX_CROP_HEIGHT = 800; // Example value, adjust as needed
        const MAX_WIDTH = 1000; // Define MAX_WIDTH
        const MAX_HEIGHT = 1000; // Define MAX_HEIGHT
        const MAX_IMAGES = 20; // Define MAX_IMAGES

        // ============ å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾ç®—æ³• (ä¿®å¾©ç·šæ¢å•é¡Œ) ============

        // æ·»åŠ é»‘æ¡†å‡½æ•¸ (Global Scope)
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            borderedCanvas.width = canvas.width + 2; // å·¦å³å„1px
            borderedCanvas.height = canvas.height + 2; // ä¸Šä¸‹å„1px
            const ctx = borderedCanvas.getContext('2d');

            // å¡«æ»¿é»‘è‰²èƒŒæ™¯
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // ç¹ªè£½åŸå§‹åœ–ç‰‡åœ¨ä¸­é–“
            ctx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾å‡½æ•¸ - ä¸ä½¿ç”¨æœ‰å•é¡Œçš„éŠ³åŒ–æ¿¾é¡
         */
        function safeAdvancedImageScale(sourceCanvas, targetWidth, targetHeight, quality = 'balanced') {
            const sourceWidth = sourceCanvas.width;
            const sourceHeight = sourceCanvas.height;
            const scaleX = targetWidth / sourceWidth;
            const scaleY = targetHeight / sourceHeight;
            const minScale = Math.min(scaleX, scaleY);

            console.log(`ç¸®æ”¾å“è³ªé¸æ“‡: ${quality}, ç¸®æ”¾æ¯”ä¾‹: ${minScale.toFixed(3)}`);

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡ç¸®æ”¾ç­–ç•¥
            switch (quality) {
                case 'ultra':
                    // è¶…é«˜å“è³ªï¼šç¸½æ˜¯ä½¿ç”¨å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆç¸®å°æ™‚ï¼‰æˆ–é«˜å“è³ªç¸®æ”¾ï¼ˆæ”¾å¤§æ™‚ï¼‰
                    if (minScale < 1.0) {
                        return safeMultiStepScale(sourceCanvas, targetWidth, targetHeight);
                    } else {
                        return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);
                    }

                case 'high':
                    return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'balanced':
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'fast':
                    return simpleFastScale(sourceCanvas, targetWidth, targetHeight);

                default:
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);
            }
        }

        /**
         * å®‰å…¨çš„å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆä¸ä½¿ç”¨éŠ³åŒ–ï¼‰
         */
        function safeMultiStepScale(sourceCanvas, targetWidth, targetHeight) {
            let currentCanvas = sourceCanvas;
            const scaleX = targetWidth / sourceCanvas.width;
            const scaleY = targetHeight / sourceCanvas.height;
            const minScale = Math.min(scaleX, scaleY);

            // è¨ˆç®—æ­¥é©Ÿæ•¸ - æ¯æ­¥æœ€å¤šç¸®å°åˆ°50%
            const steps = Math.max(1, Math.ceil(Math.log(minScale) / Math.log(0.5)));

            console.log(`Ultraè³ªé‡æ¨¡å¼ï¼šåŸå§‹å°ºå¯¸ ${sourceCanvas.width}x${sourceCanvas.height} -> ç›®æ¨™ ${targetWidth}x${targetHeight}ï¼Œç¸®æ”¾æ¯”ä¾‹ ${minScale.toFixed(3)}ï¼Œä½¿ç”¨ ${steps} æ­¥ç¸®æ”¾`);

            for (let i = 0; i < steps; i++) {
                const isLastStep = (i === steps - 1);

                let stepTargetWidth, stepTargetHeight;
                if (isLastStep) {
                    stepTargetWidth = targetWidth;
                    stepTargetHeight = targetHeight;
                } else {
                    // æ¯æ­¥ç¸®å°åˆ°50%
                    stepTargetWidth = Math.max(targetWidth, Math.round(currentCanvas.width * 0.5));
                    stepTargetHeight = Math.max(targetHeight, Math.round(currentCanvas.height * 0.5));
                }

                const stepCanvas = document.createElement('canvas');
                stepCanvas.width = stepTargetWidth;
                stepCanvas.height = stepTargetHeight;
                const stepCtx = stepCanvas.getContext('2d');

                setupUltraQualityCanvas(stepCtx);
                stepCtx.drawImage(currentCanvas, 0, 0, stepTargetWidth, stepTargetHeight);

                console.log(`æ­¥é©Ÿ ${i + 1}/${steps}: ${currentCanvas.width}x${currentCanvas.height} -> ${stepTargetWidth}x${stepTargetHeight}`);
                currentCanvas = stepCanvas;
            }

            return currentCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜å“è³ªç¸®æ”¾
         */
        function safeHighQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`é«˜å“è³ªæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupHighQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * å¹³è¡¡å“è³ªç¸®æ”¾
         */
        function balancedQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¹³è¡¡æ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupBalancedQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * ç°¡å–®å¿«é€Ÿç¸®æ”¾
         */
        function simpleFastScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¿«é€Ÿæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupFastQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        // ============ å“è³ªé¸é …äº¤äº’é‚è¼¯ ============

        function updateQualityDescription() {
            const quality = document.getElementById('scalingQuality').value;
            const description = document.getElementById('qualityDescription');

            const descriptions = {
                ultra: '<span class="badge-ultra quality-badge">è¶…é«˜å“è³ª</span>å¤šæ­¥é©Ÿç¸®æ”¾ + æœ€é«˜JPEGå“è³ª(99%) - æª”æ¡ˆè¼ƒå¤§ä½†å“è³ªæœ€ä½³',
                high: '<span class="badge-high quality-badge">é«˜å“è³ª</span>é«˜å“è³ªç¸®æ”¾ + JPEGå“è³ª(95%) - å¹³è¡¡å“è³ªèˆ‡æª”æ¡ˆå¤§å°',
                balanced: '<span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>ä¸­ç­‰å“è³ªç¸®æ”¾ + JPEGå“è³ª(90%) - æ¨™æº–å“è³ªèˆ‡åˆç†æª”æ¡ˆå¤§å°',
                fast: '<span class="badge-fast quality-badge">å¿«é€Ÿæ¨¡å¼</span>å¿«é€Ÿç¸®æ”¾ + JPEGå“è³ª(80%) - è™•ç†é€Ÿåº¦å¿«ã€æª”æ¡ˆè¼ƒå°'
            };

            description.innerHTML = descriptions[quality];
        }

        // ============ åŸæœ‰åŠŸèƒ½ä»£ç¢¼ ============

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const resize320ModeBtn = document.getElementById('resize320Mode');
        const resize1080ModeBtn = document.getElementById('resize1080Mode');
        const addWatermarkModeBtn = document.getElementById('addWatermarkMode');
        const adaSpecialModeBtn = document.getElementById('adaSpecialMode');
        const screenshotArrangeModeBtn = document.getElementById('screenshotArrangeMode');
        const borderlessScreenshotArrangeModeBtn = document.getElementById('borderlessScreenshotArrangeMode');
        const cropImageModeBtn = document.getElementById('cropImageMode');
        const logoInput = document.getElementById('logoInput');
        const logoStatus = document.getElementById('logoStatus');
        const logoPreview = document.getElementById('logoPreview');
        const pageTitle = document.getElementById('pageTitle');
        const selectLogoBtn = document.getElementById('selectLogoBtn');
        const selectAdaLogoBtn = document.getElementById('selectAdaLogoBtn');
        const screenshotArrangeDiv = document.getElementById('screenshotArrange');
        const borderlessScreenshotArrangeDiv = document.getElementById('borderlessScreenshotArrange');
        const cropImageArea = document.getElementById('cropImageArea');
        // const cropFileInput = document.getElementById('cropFileInput'); // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
        const cropCanvas = document.getElementById('cropCanvas');
        const cropCtx = cropCanvas.getContext('2d');
        const cropSelectionCanvas = document.getElementById('cropSelectionCanvas');
        const cropSelectionCtx = cropSelectionCanvas.getContext('2d');
        const executeCropButton = document.getElementById('executeCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // å“è³ªé¸é …å…ƒç´ 
        const scalingQuality = document.getElementById('scalingQuality');

        // é è¦½ç›¸é—œå…ƒç´ 
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const previewEditCanvas = document.getElementById('previewEditCanvas');
        const previewEditCtx = previewEditCanvas.getContext('2d');
        const previewDownloadButton = document.getElementById('previewDownloadButton');
        const processMoreButton = document.getElementById('processMoreButton');
        const clearPreviewButton = document.getElementById('clearPreviewButton');
        const downloadPNGButton = document.getElementById('downloadPNGButton');

        // é è¦½ç·¨è¼¯å·¥å…·
        const previewRectangleTool = document.getElementById('previewRectangleTool');
        const previewArrowTool = document.getElementById('previewArrowTool');
        const previewMosaicTool = document.getElementById('previewMosaicTool');
        const previewUndoButton = document.getElementById('previewUndoButton');
        const previewClearButton = document.getElementById('previewClearButton');

        // é è¦½ç·¨è¼¯ç‹€æ…‹è®Šé‡
        let previewIsDrawing = false;
        let previewStartX, previewStartY;
        let previewCurrentTool = null;
        let previewEditHistory = [];
        let previewBaseEditState = null;

        let currentMode = 'resize320';
        let logoImage = null;
        let logoFileName = '';
        let adaSpecialLogo = null;
        let adaSpecialLogoFileName = '';

        // è£åˆ‡åŠŸèƒ½ç›¸é—œè®Šæ•¸
        let originalCropImage = null;
        let cropStartX, cropStartY, cropEndX, cropEndY;
        let isCropping = false;
        let cropSelection = { x: 0, y: 0, width: 0, height: 0 };

        // å¾ localStorage è®€å–ä¸Šæ¬¡ä½¿ç”¨çš„ Logo
        const lastUsedLogo = localStorage.getItem('lastUsedLogo');
        const lastUsedLogoName = localStorage.getItem('lastUsedLogoName');
        const lastUsedAdaLogo = localStorage.getItem('lastUsedAdaLogo');
        const lastUsedAdaLogoName = localStorage.getItem('lastUsedAdaLogoName');

        if (lastUsedLogo && lastUsedLogoName) {
            logoImage = new Image();
            logoImage.src = lastUsedLogo;
            logoFileName = lastUsedLogoName;
            updateLogoPreview(lastUsedLogo, lastUsedLogoName, 'ä¸€èˆ¬');
        }

        if (lastUsedAdaLogo && lastUsedAdaLogoName) {
            adaSpecialLogo = new Image();
            adaSpecialLogo.src = lastUsedAdaLogo;
            adaSpecialLogoFileName = lastUsedAdaLogoName;
        }

        // å“è³ªé¸é …äº‹ä»¶ç›£è½å™¨
        scalingQuality.addEventListener('change', updateQualityDescription);

        dropZone.addEventListener('click', () => {
            console.log('dropZone clicked');
            fileInput.click();
        });
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', handleFiles);
        fileInput.addEventListener('change', handleFiles);
        resize320ModeBtn.addEventListener('click', () => setMode('resize320'));
        resize1080ModeBtn.addEventListener('click', () => setMode('resize1080'));
        addWatermarkModeBtn.addEventListener('click', () => setMode('addWatermark'));
        adaSpecialModeBtn.addEventListener('click', () => setMode('adaSpecial'));
        screenshotArrangeModeBtn.addEventListener('click', () => setMode('screenshotArrange'));
        cropImageModeBtn.addEventListener('click', () => setMode('cropImage')); // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼æŒ‰éˆ•äº‹ä»¶
        selectLogoBtn.addEventListener('click', () => logoInput.click());
        selectAdaLogoBtn.addEventListener('click', () => logoInput.click());

        // é è¦½åŠŸèƒ½äº‹ä»¶ç›£è½å™¨
        previewDownloadButton.addEventListener('click', downloadPreviewImage);
        processMoreButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
            fileInput.value = '';
        });
        clearPreviewButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
        });

        downloadPNGButton.addEventListener('click', downloadPreviewImageAsPNG);

        // é è¦½ç·¨è¼¯å·¥å…·äº‹ä»¶ç›£è½å™¨
        previewRectangleTool.addEventListener('click', () => {
            previewCurrentTool = 'rectangle';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewArrowTool.addEventListener('click', () => {
            previewCurrentTool = 'arrow';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewMosaicTool.addEventListener('click', () => {
            previewCurrentTool = 'mosaic';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewUndoButton.addEventListener('click', previewUndo);
        previewClearButton.addEventListener('click', previewClearEdits);

        // é è¦½ç·¨è¼¯canvasäº‹ä»¶ç›£è½å™¨
        previewEditCanvas.addEventListener('mousedown', previewStartDrawing);
        previewEditCanvas.addEventListener('mousemove', previewDraw);
        previewEditCanvas.addEventListener('mouseup', previewStopDrawing);
        previewEditCanvas.addEventListener('mouseout', previewStopDrawing);

        // è£åˆ‡åŠŸèƒ½äº‹ä»¶ç›£è½å™¨

        cropSelectionCanvas.addEventListener('mousedown', startCropDrawing);
        cropSelectionCanvas.addEventListener('mousemove', drawCropSelection);
        cropSelectionCanvas.addEventListener('mouseup', stopCropDrawing);
        cropSelectionCanvas.addEventListener('mouseout', stopCropDrawing);
        executeCropButton.addEventListener('click', executeCrop);
        cancelCropButton.addEventListener('click', cancelCrop);

        // ğŸ”¥ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const borderlessFileInput2 = document.getElementById('borderlessFileInput2');
        const borderlessFileCount = document.getElementById('borderlessFileCount');
        const borderlessProcessButton = document.getElementById('borderlessProcessButton');
        const borderlessDownloadButton = document.getElementById('borderlessDownloadButton');
        const borderlessCanvas = document.getElementById('borderlessCanvas');
        const borderlessCtx = borderlessCanvas.getContext('2d');
        const borderlessImageList = document.getElementById('borderlessImageList');
        const borderlessEditCanvas = document.getElementById('borderlessEditCanvas');
        const borderlessEditCtx = borderlessEditCanvas.getContext('2d');
        const borderlessRectangleTool = document.getElementById('borderlessRectangleTool');
        const borderlessArrowTool = document.getElementById('borderlessArrowTool');
        const borderlessWatermarkTool = document.getElementById('borderlessWatermarkTool');
        const borderlessMosaicTool = document.getElementById('borderlessMosaicTool');
        const borderlessUndoButton = document.getElementById('borderlessUndoButton');
        const borderlessClearButton = document.getElementById('borderlessClearButton');
        const borderlessClearAllButton = document.getElementById('borderlessClearAllButton');

        let borderlessUploadedImages = [];
        let borderlessIsDrawing = false;
        let borderlessStartX, borderlessStartY;
        let borderlessCurrentTool = null;
        let borderlessEditHistory = [];
        let borderlessBaseEditState = null;

        borderlessScreenshotArrangeModeBtn.addEventListener('click', () => setMode('borderlessScreenshotArrange'));
        borderlessFileInput2.addEventListener('change', borderlessHandleFileSelect);
        borderlessProcessButton.addEventListener('click', borderlessProcessImages);
        borderlessDownloadButton.addEventListener('click', borderlessDownloadProcessedImage);
        borderlessClearAllButton.addEventListener('click', borderlessClearAllImages);

        logoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (currentMode === 'adaSpecial') {
                        adaSpecialLogo = new Image();
                        adaSpecialLogo.src = e.target.result;
                        adaSpecialLogoFileName = file.name;
                        localStorage.setItem('lastUsedAdaLogo', e.target.result);
                        localStorage.setItem('lastUsedAdaLogoName', file.name);
                        updateLogoPreview(e.target.result, file.name, 'é˜¿é”å°ˆç”¨');
                    } else if (currentMode === 'addWatermark') {
                        logoImage = new Image();
                        logoImage.src = e.target.result;
                        logoFileName = file.name;
                        localStorage.setItem('lastUsedLogo', e.target.result);
                        localStorage.setItem('lastUsedLogoName', file.name);
                        updateLogoPreview(e.target.result, file.name, 'ä¸€èˆ¬');
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        function updateLogoPreview(src, name, type) {
            logoPreview.src = src;
            logoPreview.style.display = 'block';
            logoStatus.textContent = `å·²è¼‰å…¥${type} Logo: ${name}`;
        }

        function setMode(mode) {
            // å¦‚æœä½¿ç”¨è€…å†æ¬¡é»æ“Šç•¶å‰æ¨¡å¼çš„æŒ‰éˆ•ï¼Œå‰‡é‡ç½®è©²æ¨¡å¼çš„ä»‹é¢
            if (mode === currentMode) {
                if (mode === 'screenshotArrange') {
                    clearAllImages();
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    downloadButton.style.display = 'none';
                    document.getElementById('editTools').style.display = 'none';
                    updateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (mode === 'borderlessScreenshotArrange') {
                    borderlessClearAllImages();
                    borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
                    borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    borderlessDownloadButton.style.display = 'none';
                    document.getElementById('borderlessEditTools').style.display = 'none';
                    borderlessUpdateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (['resize320', 'resize1080', 'addWatermark', 'adaSpecial'].includes(mode)) {
                    previewArea.style.display = 'none';
                    status.innerHTML = '';
                    fileInput.value = '';
                    dropZone.style.display = 'flex';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
                if (mode === 'cropImage') {
                    cancelCrop();
                    cropImageArea.style.display = 'none';
                    dropZone.style.display = 'flex';
                    status.innerHTML = '';
                    fileInput.value = '';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
            }

            currentMode = mode;
            [resize320ModeBtn, resize1080ModeBtn, addWatermarkModeBtn, adaSpecialModeBtn, screenshotArrangeModeBtn, cropImageModeBtn, borderlessScreenshotArrangeModeBtn].forEach(btn => btn.classList.remove('active'));

            selectLogoBtn.style.display = 'none';
            selectAdaLogoBtn.style.display = 'none';
            logoPreview.style.display = 'none';
            logoStatus.textContent = '';
            screenshotArrangeDiv.style.display = 'none';
            borderlessScreenshotArrangeDiv.style.display = 'none';
            cropImageArea.style.display = 'none';

            // æ¸…é™¤ä¹‹å‰çš„è™•ç†æª”æ¡ˆè³‡è¨Š
            status.innerHTML = '';

            // ç„¡è«–ä¹‹å‰çš„ç‹€æ…‹å¦‚ä½•ï¼Œåˆ‡æ›æ¨¡å¼æ™‚ä¸€å¾‹é‡ç½®ç‚ºåˆå§‹ç‹€æ…‹
            dropZone.style.display = 'flex';
            fileInput.style.display = 'none';
            previewArea.style.display = 'none';

            // æ¸…é™¤é è¦½ Canvas
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewCanvas.width = 0;
            previewCanvas.height = 0;
            previewEditCanvas.width = 0;
            previewEditCanvas.height = 0;

            if (mode === 'resize320') {
                resize320ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰';
            } else if (mode === 'resize1080') {
                resize1080ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰';
            } else if (mode === 'addWatermark') {
                addWatermarkModeBtn.classList.add('active');
                pageTitle.textContent = 'æ·»åŠ æµ®æ°´å°';
                selectLogoBtn.style.display = 'inline-block';
                if (logoImage) {
                    updateLogoPreview(logoImage.src, logoFileName, 'ä¸€èˆ¬');
                }
            } else if (mode === 'adaSpecial') {
                adaSpecialModeBtn.classList.add('active');
                pageTitle.textContent = 'é›»è…¦ç‹é˜¿é”å°ˆç”¨';
                selectAdaLogoBtn.style.display = 'inline-block';
                if (adaSpecialLogo) {
                    updateLogoPreview(adaSpecialLogo.src, adaSpecialLogoFileName, 'é˜¿é”å°ˆç”¨');
                }
            } else if (mode === 'screenshotArrange') {
                screenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'æˆªåœ–ä¸¦æ’';
                screenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'borderlessScreenshotArrange') {
                borderlessScreenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’';
                borderlessScreenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
                borderlessUpdateFileInputAndCount(); // ğŸ”§ Initialize file count display
            } else if (mode === 'cropImage') {
                cropImageModeBtn.classList.add('active');
                pageTitle.textContent = 'åœ–ç‰‡è£åˆ‡';
                cropImageArea.style.display = 'block';
                dropZone.style.display = 'flex';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            }

            // æ¸…é™¤æª”æ¡ˆè¼¸å…¥
            fileInput.value = '';
        }

        function handleFiles(e) {
            console.log('handleFiles triggered');
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
            processFiles(files);
        }

        async function processFiles(files) {
            console.log('processFiles triggered', files);
            status.innerHTML = 'é–‹å§‹è™•ç†æª”æ¡ˆ...';

            // åªè™•ç†ç¬¬ä¸€å¼µåœ–ç‰‡é€²è¡Œé è¦½
            const file = files[0];
            if (file && file.type.startsWith('image/')) {
                try {
                    let result = null;
                    if (currentMode === 'resize320') {
                        result = await processImageForPreview(file, 'resize320');
                    } else if (currentMode === 'resize1080') {
                        result = await processImageForPreview(file, 'resize1080');
                    } else if (currentMode === 'addWatermark') {
                        if (logoImage) {
                            result = await processImageForPreview(file, 'addWatermark');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'adaSpecial') {
                        if (adaSpecialLogo) {
                            result = await processImageForPreview(file, 'adaSpecial');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡é˜¿é”å°ˆç”¨ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'cropImage') { // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼è™•ç†
                        handleCropFileSelect({ target: { files: [file] } }); // æ¨¡æ“¬äº‹ä»¶å°è±¡
                        status.innerHTML += '<br>åœ–ç‰‡å·²è¼‰å…¥è£åˆ‡å€ï¼Œè«‹ç¹ªè£½è£åˆ‡ç¯„åœã€‚';
                        return; // è£åˆ‡æ¨¡å¼ä¸‹ä¸é€²å…¥é è¦½å€ï¼Œç›´æ¥é¡¯ç¤ºè£åˆ‡ä»‹é¢
                    }

                    if (result && result.canvas) {
                        const filename = file.name.replace(/\.[^/.]+$/, ".jpg");
                        showPreview(result.canvas, filename);
                        status.innerHTML += '<br>è™•ç†å®Œæˆï¼è«‹æŸ¥çœ‹é è¦½çµæœã€‚';
                    }
                } catch (error) {
                    console.error('è™•ç†éŒ¯èª¤:', error);
                    status.innerHTML += '<br>è™•ç†å¤±æ•—: ' + error.message;
                }
            }
        }

        async function resizeImage(file, targetSize, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let newWidth, newHeight;

                        const longSide = Math.max(img.width, img.height);

                        if (longSide <= targetSize) {
                            newWidth = img.width;
                            newHeight = img.height;
                        } else if (img.width > img.height) {
                            newWidth = targetSize;
                            newHeight = (img.height / img.width) * targetSize;
                        } else {
                            newHeight = targetSize;
                            newWidth = (img.width / img.height) * targetSize;
                        }

                        // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾æŠ€è¡“
                        const sourceCanvas = document.createElement('canvas');
                        sourceCanvas.width = img.width;
                        sourceCanvas.height = img.height;
                        const sourceCtx = sourceCanvas.getContext('2d');
                        setupHighQualityCanvas(sourceCtx);
                        sourceCtx.drawImage(img, 0, 0);

                        const quality = scalingQuality.value;
                        const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                        canvas.width = scaledCanvas.width;
                        canvas.height = scaledCanvas.height;
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(scaledCanvas, 0, 0);

                        // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
                        let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
                        switch (quality) {
                            case 'ultra':
                                jpegQuality = 0.99; // æœ€é«˜å“è³ª
                                break;
                            case 'high':
                                jpegQuality = 0.95; // é«˜å“è³ª
                                break;
                            case 'balanced':
                                jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                                break;
                            case 'fast':
                                jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                                break;
                        }

                        console.log(`ä½¿ç”¨JPEGå“è³ª: ${jpegQuality}`);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const resizedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                console.log(`è¼¸å‡ºæª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                                if (returnBlob) {
                                    resolve(resizedFile);
                                } else {
                                    saveAs(resizedFile);
                                    status.innerHTML += ` - èª¿æ•´å¤§å°æˆåŠŸï¼(å“è³ª: ${quality}, æª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB)`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºèª¿æ•´å¤§å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', jpegQuality);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function addWatermark(file, logo, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        canvas.width = img.width;
                        canvas.height = img.height;

                        // è¨­ç½®é«˜å“è³ªç¸®æ”¾
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(img, 0, 0, img.width, img.height);

                        // Logo å°ºå¯¸ç¸®å°30%
                        const logoWidth = logo.width * 0.7;
                        const logoHeight = logo.height * 0.7;

                        // è¨ˆç®— Logo ä½ç½®ï¼ˆå³ä¸‹è§’ï¼Œè·é›¢é‚Šç·£ 15 åƒç´ ï¼‰
                        const logoX = img.width - logoWidth - 15;
                        const logoY = img.height - logoHeight - 15;

                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(logo, logoX, logoY, logoWidth, logoHeight);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const watermarkedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                if (returnBlob) {
                                    resolve(watermarkedFile);
                                } else {
                                    saveAs(watermarkedFile);
                                    status.innerHTML += ` - æ·»åŠ æµ®æ°´å°æˆåŠŸï¼`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºæ·»åŠ æµ®æ°´å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', 0.98);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function adaSpecialProcess(file) {
            try {
                console.log('é–‹å§‹é˜¿é”å°ˆç”¨è™•ç†');
                status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;

                console.log('æ­¥é©Ÿ 1: èª¿æ•´åœ–ç‰‡å¤§å°');
                status.innerHTML += `<br>- èª¿æ•´åœ–ç‰‡å¤§å°ä¸­...`;
                let processedImage = await resizeImage(file, 1000, true);

                console.log('æ­¥é©Ÿ 2: æ·»åŠ æµ®æ°´å°');
                status.innerHTML += `<br>- æ·»åŠ æµ®æ°´å°ä¸­...`;
                if (!adaSpecialLogo) {
                    throw new Error('é˜¿é”å°ˆç”¨ Logo æœªè¨­ç½®');
                }
                processedImage = await addWatermark(processedImage, adaSpecialLogo, true);

                console.log('å„²å­˜æœ€çµ‚åœ–ç‰‡');
                saveAs(processedImage);
                status.innerHTML += `<br>é›»è…¦ç‹é˜¿é”å°ˆç”¨è™•ç†å®Œæˆï¼`;
            } catch (error) {
                console.error('é˜¿é”å°ˆç”¨è™•ç†éŒ¯èª¤:', error);
                status.innerHTML += `<br>è™•ç†å¤±æ•—: ${error.message}`;
            }
        }

        // é«˜å“è³ªCanvasè¨­ç½®å‡½æ•¸
        function setupHighQualityCanvas(ctx) {
            // è¨­ç½®é«˜å“è³ªåœ–åƒç¸®æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            // é‡å°æ–‡å­—å„ªåŒ–çš„è¨­ç½®
            ctx.textRenderingOptimization = 'optimizeQuality';
        }

        // ============ ä¸åŒå“è³ªçš„Canvasè¨­ç½® ============

        function setupUltraQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            // è¶…é«˜å“è³ªè¨­ç½®
            ctx.globalCompositeOperation = 'source-over';
        }

        function setupBalancedQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        function setupFastQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'low';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        // æ·»åŠ é»‘æ¡†å‡½æ•¸
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            const borderedCtx = borderedCanvas.getContext('2d');

            // æ–°canvaså°ºå¯¸ç‚ºåŸå°ºå¯¸+2pxï¼ˆä¸Šä¸‹å„1pxï¼Œå·¦å³å„1pxï¼‰
            borderedCanvas.width = canvas.width + 2;
            borderedCanvas.height = canvas.height + 2;

            // å¡«å……é»‘è‰²èƒŒæ™¯
            borderedCtx.fillStyle = 'black';
            borderedCtx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // åœ¨ä¸­å¤®ç¹ªè£½åŸå§‹åœ–ç‰‡
            borderedCtx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        // è™•ç†åœ–ç‰‡ä¸¦è¿”å›canvasï¼ˆé è¦½æ¨¡å¼ï¼‰
        async function processImageForPreview(file, mode) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
                        const quality = scalingQuality.value;
                        console.log(`ğŸ¯ è™•ç†æ¨¡å¼: ${mode}, å“è³ªè¨­å®š: ${quality}`);

                        if (mode === 'resize320') {
                            // çŸ­é‚Šç¸®æ”¾åˆ°320px
                            const shortSide = Math.min(img.width, img.height);
                            let newWidth, newHeight;

                            if (shortSide <= 320) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width < img.height) {
                                // ç›´ç‰ˆåœ–ç‰‡ï¼Œå¯¬åº¦æ˜¯çŸ­é‚Š
                                newWidth = 320;
                                newHeight = (img.height / img.width) * 320;
                            } else {
                                // æ©«ç‰ˆåœ–ç‰‡ï¼Œé«˜åº¦æ˜¯çŸ­é‚Š
                                newHeight = 320;
                                newWidth = (img.width / img.height) * 320;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'resize1080') {
                            // é•·é‚Šç¸®æ”¾åˆ°1000px
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'addWatermark') {
                            // æ·»åŠ æµ®æ°´å° - ğŸ”¥ ä½¿ç”¨å“è³ªè¨­å®š
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');

                            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
                            switch (quality) {
                                case 'ultra':
                                    setupUltraQualityCanvas(ctx);
                                    break;
                                case 'high':
                                    setupHighQualityCanvas(ctx);
                                    break;
                                case 'balanced':
                                    setupBalancedQualityCanvas(ctx);
                                    break;
                                case 'fast':
                                    setupFastQualityCanvas(ctx);
                                    break;
                                default:
                                    setupBalancedQualityCanvas(ctx);
                            }

                            ctx.drawImage(img, 0, 0);

                            // æ·»åŠ æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = logoImage.width * 0.7;
                            const logoHeight = logoImage.height * 0.7;
                            const logoX = img.width - logoWidth - 15;
                            const logoY = img.height - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);

                            resolve({ canvas: canvas });

                        } else if (mode === 'adaSpecial') {
                            // é˜¿é”å°ˆç”¨ï¼šç¸®æ”¾ + æµ®æ°´å° + é»‘æ¡†
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                            const canvas = document.createElement('canvas');
                            canvas.width = scaledCanvas.width;
                            canvas.height = scaledCanvas.height;
                            const ctx = canvas.getContext('2d');
                            setupHighQualityCanvas(ctx);
                            ctx.drawImage(scaledCanvas, 0, 0);

                            // æ·»åŠ é˜¿é”å°ˆç”¨æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = adaSpecialLogo.width * 0.7;
                            const logoHeight = adaSpecialLogo.height * 0.7;
                            const logoX = newWidth - logoWidth - 15;
                            const logoY = newHeight - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(adaSpecialLogo, logoX, logoY, logoWidth, logoHeight);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(canvas);
                            resolve({ canvas: borderedCanvas });
                        }

                    } catch (error) {
                        reject(error);
                    }
                };
                img.onerror = () => reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
                img.src = URL.createObjectURL(file);
            });
        }

        // é¡¯ç¤ºé è¦½çµæœ
        function showPreview(canvas, filename) {
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCtx.drawImage(canvas, 0, 0);

            // è¨­ç½®ç·¨è¼¯canvas
            previewEditCanvas.width = canvas.width;
            previewEditCanvas.height = canvas.height;
            previewEditCanvas.style.display = 'block';

            // å„²å­˜ä¸‹è¼‰ä¿¡æ¯
            previewCanvas.downloadFilename = filename;

            // åˆå§‹åŒ–ç·¨è¼¯æ­·å²
            previewClearEdits();
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];

            // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•å’Œé è¦½å€åŸŸ
            previewDownloadButton.style.display = 'block';
            downloadPNGButton.style.display = 'inline-block';
            previewArea.style.display = 'block';
            dropZone.style.display = 'none';
        }

        // é è¦½ç·¨è¼¯å·¥å…·å‡½æ•¸
        function previewStartDrawing(e) {
            if (!previewCurrentTool) return;
            previewIsDrawing = true;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            previewStartX = (e.clientX - rect.left) * scaleX;
            previewStartY = (e.clientY - rect.top) * scaleY;

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewStopDrawing() {
            if (!previewIsDrawing) return;
            previewIsDrawing = false;
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));
        }

        function previewDraw(e) {
            if (!previewIsDrawing || !previewCurrentTool) return;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            if (previewEditHistory.length > 0) {
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
            }

            previewEditCtx.beginPath();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.lineWidth = 3;

            if (previewCurrentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX + 3, previewStartY + 3, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'red';
                previewEditCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX, previewStartY, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();
            } else if (previewCurrentTool === 'arrow') {
                previewDrawArrow(previewStartX, previewStartY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (previewCurrentTool === 'mosaic') {
                // ğŸ”¥ ä¿®æ­£ï¼šé¦¬è³½å…‹å·¥å…·éœ€è¦æ•´æ•¸åº§æ¨™
                const x = Math.round(Math.min(previewStartX, endX));
                const y = Math.round(Math.min(previewStartY, endY));
                const width = Math.round(Math.abs(endX - previewStartX));
                const height = Math.round(Math.abs(endY - previewStartY));

                if (width > 0 && height > 0) {
                    previewDrawMosaic(x, y, width, height);
                }
            }

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX + 2, fromY + 2);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX + 2, toY + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.fillStyle = 'red';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';
            previewEditCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX, fromY);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX, toY);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();
        }

        function previewDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = previewCtx.getImageData(x, y, width, height);
            const stride = imageData.width; // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨å¯¦éš›çš„ imageData å¯¬åº¦ä½œç‚º stride

            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = previewGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height, stride);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                            const index = ((j + my) * stride + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            previewEditCtx.putImageData(imageData, x, y);
        }

        function previewGetAverageColor(imageData, startX, startY, size, width, height, stride) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                    const index = ((startY + j) * stride + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        function previewUndo() {
            if (previewEditHistory.length > 1) {
                previewEditHistory.pop();
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
                previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            } else {
                previewClearEdits();
            }
        }

        function previewClearEdits() {
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];
            previewBaseEditState = null;
        }

        // ä¸‹è¼‰é è¦½åœ–ç‰‡
        function downloadPreviewImage() {
            const filename = previewCanvas.downloadFilename || 'processed_image.jpg';

            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰JPG: å“è³ªè¨­å®š ${quality}`);

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            // ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦ç¸®æ”¾è‡³ 1000px (é‡å°è£åˆ‡æ¨¡å¼çš„é«˜è§£æåº¦åœ–ç‰‡)
            // æ³¨æ„ï¼šå¦‚æœå·²ç¶“æ˜¯è£åˆ‡æ¨¡å¼ä¸”å·²ç¶“åœ¨ executeCrop ä¸­ç¸®æ”¾éå¯¬åº¦ï¼Œé€™è£¡å°±ä¸æ‡‰è©²å†å¼·åˆ¶ç¸®æ”¾é•·é‚Š
            // é™¤éä½¿ç”¨è€…æ²’æœ‰ç¶“éè£åˆ‡æµç¨‹ (ä¸å¤ªå¯èƒ½ï¼Œå› ç‚º cropImage æ¨¡å¼ä¸‹å¿…é ˆå…ˆè£åˆ‡)
            // ä½†ç‚ºäº†ä¿éšªèµ·è¦‹ï¼Œæˆ‘å€‘å¯ä»¥æª¢æŸ¥ currentMode

            let outputCanvas = finalCanvas;
            const longSide = Math.max(finalCanvas.width, finalCanvas.height);

            // åªæœ‰åœ¨éè£åˆ‡æ¨¡å¼ä¸‹ï¼Œæˆ–è€…è£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦ç•°å¸¸å¤§æ™‚æ‰åŸ·è¡Œæ­¤è™•çš„ç¸®æ”¾
            // ä½†æ ¹æ“šæ–°éœ€æ±‚ï¼Œè£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦å·²ç¶“æ˜¯ 1000pxï¼Œæ‰€ä»¥é€™è£¡æ‡‰è©²è·³é
            if (currentMode !== 'cropImage' && longSide > 1000) {
                console.log(`ğŸ”½ ä¸‹è¼‰å‰ç¸®æ”¾: åŸå§‹å°ºå¯¸ ${finalCanvas.width}x${finalCanvas.height} -> é•·é‚Šé™åˆ¶ 1000px`);
                let newWidth, newHeight;
                if (finalCanvas.width > finalCanvas.height) {
                    newWidth = 1000;
                    newHeight = (finalCanvas.height / finalCanvas.width) * 1000;
                } else {
                    newHeight = 1000;
                    newWidth = (finalCanvas.width / finalCanvas.height) * 1000;
                }

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾
                outputCanvas = safeAdvancedImageScale(finalCanvas, newWidth, newHeight, quality);
            }

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰JPG: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            outputCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename, { type: "image/jpeg" });
                    console.log(`ğŸ”½ ä¸‹è¼‰JPG: æª”æ¡ˆå¤§å° ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                    saveAs(file);
                }
            }, 'image/jpeg', jpegQuality);
        }

        // ä¸‹è¼‰PNGæ ¼å¼é è¦½åœ–ç‰‡ï¼ˆæœ€é«˜ç•«è³ªï¼‰
        function downloadPreviewImageAsPNG() {
            const filename = previewCanvas.downloadFilename || 'processed_image.png';

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // è¨­ç½®é«˜å“è³ªç¸®æ”¾
            setupHighQualityCanvas(finalCtx);

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            finalCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename.replace(/\.[^/.]+$/, ".png"), { type: "image/png" });
                    saveAs(file);
                }
            }, 'image/png');
        }

        function saveAs(blob) {
            const a = document.createElement("a");
            document.body.appendChild(a);
            a.style.display = "none";
            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = blob.name;

            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Crop Watermark Variables
        let cropLogoImage = null;
        // const cropLogoInput = document.getElementById('cropLogoInput'); // Removed
        // const cropLogoStatus = document.getElementById('cropLogoStatus'); // Removed

        // Preview Watermark Tool Variables
        const previewWatermarkTool = document.getElementById('previewWatermarkTool');
        const previewWatermarkInput = document.getElementById('previewWatermarkInput');

        // Load saved watermark from localStorage
        const savedWatermarkData = localStorage.getItem('cropWatermarkData');
        if (savedWatermarkData) {
            cropLogoImage = new Image();
            cropLogoImage.src = savedWatermarkData;
        }

        if (previewWatermarkTool) {
            previewWatermarkTool.addEventListener('click', () => {
                if (cropLogoImage) {
                    applyWatermarkToPreview();
                } else {
                    previewWatermarkInput.click();
                }
            });
        }

        if (previewWatermarkInput) {
            previewWatermarkInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        cropLogoImage = new Image();
                        cropLogoImage.onload = function () {
                            // Save to localStorage
                            localStorage.setItem('cropWatermarkData', event.target.result);

                            // Determine which mode is active and apply watermark accordingly
                            if (document.getElementById('previewArea').style.display !== 'none') {
                                applyWatermarkToPreview();
                            } else if (document.getElementById('screenshotArrange').style.display !== 'none') {
                                applyWatermarkToArrange(cropLogoImage);
                            } else if (document.getElementById('borderlessScreenshotArrange').style.display !== 'none') {
                                applyWatermarkToBorderlessArrange(cropLogoImage);
                            }
                        };
                        cropLogoImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function applyWatermarkToPreview() {
            if (!cropLogoImage) return;

            // Save current state for undo
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));

            const ctx = previewEditCtx;

            // Watermark scaling (shrink 30%)
            const logoWidth = cropLogoImage.width * 0.7;
            const logoHeight = cropLogoImage.height * 0.7;

            // Position: Bottom-right, 15px margin
            // Note: previewEditCanvas size matches the preview image size
            const logoX = previewEditCanvas.width - logoWidth - 15;
            const logoY = previewEditCanvas.height - logoHeight - 15;

            ctx.save();
            ctx.globalAlpha = 0.5; // 50% opacity
            ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            ctx.restore();

            console.log('Watermark applied to preview edit canvas');
        }

        function handleCropFileSelect(event) {
            console.log('handleCropFileSelect triggered', event);
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                console.log('File is an image:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    console.log('FileReader onload triggered');
                    originalCropImage = new Image();
                    originalCropImage.onload = () => {
                        console.log('originalCropImage onload triggered', originalCropImage.width, originalCropImage.height);
                        let displayWidth = originalCropImage.width;
                        let displayHeight = originalCropImage.height;
                        let scaleFactor = 1; // æ–°å¢ï¼šç¸®æ”¾å› å­

                        // å¦‚æœåœ–ç‰‡å¯¬åº¦æˆ–é«˜åº¦è¶…éæœ€å¤§é™åˆ¶ï¼Œå‰‡æŒ‰æ¯”ä¾‹ç¸®æ”¾
                        if (displayWidth > MAX_CROP_WIDTH || displayHeight > MAX_CROP_HEIGHT) {
                            const aspectRatio = displayWidth / displayHeight;
                            if (displayWidth / MAX_CROP_WIDTH > displayHeight / MAX_CROP_HEIGHT) {
                                scaleFactor = MAX_CROP_WIDTH / displayWidth;
                                displayWidth = MAX_CROP_WIDTH;
                                displayHeight = displayWidth / aspectRatio;
                            } else {
                                scaleFactor = MAX_CROP_HEIGHT / displayHeight;
                                displayHeight = MAX_CROP_HEIGHT;
                                displayWidth = displayHeight * aspectRatio;
                            }
                        }

                        cropCanvas.width = displayWidth;
                        cropCanvas.height = displayHeight;
                        cropCtx.drawImage(originalCropImage, 0, 0, displayWidth, displayHeight);

                        cropSelectionCanvas.width = displayWidth;
                        cropSelectionCanvas.height = displayHeight;
                        cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

                        // é‡ç½®è£åˆ‡é¸å€
                        cropSelection = { x: 0, y: 0, width: 0, height: 0, scaleFactor: scaleFactor }; // æ–°å¢ï¼šå„²å­˜ç¸®æ”¾å› å­
                        isCropping = false;
                        cropImageArea.style.display = 'block'; // ç¢ºä¿è£åˆ‡å€åŸŸé¡¯ç¤º
                    };
                    originalCropImage.onerror = () => {
                        console.error('Error loading originalCropImage');
                        status.innerHTML += '<br>åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥åœ–ç‰‡æª”æ¡ˆã€‚';
                    };
                    originalCropImage.src = e.target.result;
                    console.log('originalCropImage.src set');
                };
                reader.readAsDataURL(file);
            }
        }

        function startCropDrawing(e) {
            console.log('startCropDrawing triggered');
            isCropping = true;
            [cropStartX, cropStartY] = [e.offsetX, e.offsetY];
            cropEndX = cropStartX;
            cropEndY = cropStartY;
        }

        function drawCropSelection(e) {
            if (!isCropping) return;
            cropEndX = e.offsetX;
            cropEndY = e.offsetY;

            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);

            // ç¹ªè£½åŠé€æ˜é®ç½© (å››å€‹çŸ©å½¢è¦†è“‹é¸å€å¤–)
            cropSelectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            // Top rectangle
            cropSelectionCtx.fillRect(0, 0, cropSelectionCanvas.width, y);
            // Bottom rectangle
            cropSelectionCtx.fillRect(0, y + height, cropSelectionCanvas.width, cropSelectionCanvas.height - (y + height));
            // Left rectangle
            cropSelectionCtx.fillRect(0, y, x, height);
            // Right rectangle
            cropSelectionCtx.fillRect(x + width, y, cropSelectionCanvas.width - (x + width), height);

            // ç¹ªè£½é¸å€é‚Šæ¡†
            cropSelectionCtx.strokeStyle = 'red';
            cropSelectionCtx.lineWidth = 2;
            cropSelectionCtx.strokeRect(x, y, width, height);

            cropSelection = { x, y, width, height, scaleFactor: cropSelection.scaleFactor };
        }

        function stopCropDrawing() {
            isCropping = false;
        }

        function executeCrop() {
            if (!originalCropImage || cropSelection.width === 0 || cropSelection.height === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ä¸¦ç¹ªè£½è£åˆ‡ç¯„åœã€‚');
                return;
            }

            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨åŸå§‹åœ–ç‰‡çš„çœŸå¯¦å°ºå¯¸é€²è¡Œè£åˆ‡ï¼Œè€Œä¸æ˜¯é è¦½å°ºå¯¸
            // cropSelection ç´€éŒ„çš„æ˜¯åœ¨ canvas (é è¦½åœ–) ä¸Šçš„åº§æ¨™
            // æˆ‘å€‘éœ€è¦å°‡å…¶è½‰æ›å›åŸå§‹åœ–ç‰‡çš„åº§æ¨™

            // 1. è¨ˆç®—é è¦½åœ–èˆ‡åŸå§‹åœ–çš„æ¯”ä¾‹
            // cropCanvas.width æ˜¯é è¦½ canvas çš„å¯¬åº¦
            // originalCropImage.width æ˜¯åŸå§‹åœ–ç‰‡çš„å¯¬åº¦
            // ä½†æ³¨æ„ï¼šåœ¨ handleCropFileSelect ä¸­ï¼Œæˆ‘å€‘å¯èƒ½å·²ç¶“å°é¡¯ç¤ºé€²è¡Œäº†ç¸®æ”¾ (scaleFactor)
            // å¯¦éš›ä¸Šï¼ŒcropSelection.scaleFactor å·²ç¶“ç´€éŒ„äº† (é è¦½å¯¬åº¦ / åŸå§‹å¯¬åº¦) çš„æ¯”ä¾‹å—ï¼Ÿ
            // è®“æˆ‘å€‘é‡æ–°æª¢æŸ¥ handleCropFileSelect çš„é‚è¼¯

            // åœ¨ handleCropFileSelect ä¸­:
            // scaleFactor = MAX_CROP_WIDTH / displayWidth; (å¦‚æœéœ€è¦ç¸®å°é¡¯ç¤º)
            // cropCanvas.width = displayWidth (é€™æ˜¯ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦)
            // cropCtx.drawImage(originalCropImage, ..., displayWidth, displayHeight)

            // æ‰€ä»¥ï¼ŒcropSelection ä¸Šçš„åº§æ¨™æ˜¯åŸºæ–¼ "ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦"
            // è¦æ‹¿åˆ°åŸå§‹åœ–ç‰‡çš„åº§æ¨™ï¼Œæˆ‘å€‘éœ€è¦é™¤ä»¥ scaleFactor (å¦‚æœ scaleFactor æ˜¯ é¡¯ç¤º/åŸå§‹)
            // ç­‰ç­‰ï¼ŒhandleCropFileSelect ä¸­çš„ scaleFactor å®šç¾©æ˜¯ï¼š
            // if (displayWidth > MAX_CROP_WIDTH ...) { scaleFactor = MAX_CROP_WIDTH / original_width }
            // æ‰€ä»¥ cropSelection.x / scaleFactor æ‡‰è©²å°±æ˜¯åŸå§‹åº§æ¨™

            // è®“æˆ‘å€‘ç¢ºèªä¸€ä¸‹ cropSelection.scaleFactor çš„å€¼
            const scale = cropSelection.scaleFactor || 1;

            const sourceX = cropSelection.x / scale;
            const sourceY = cropSelection.y / scale;
            const sourceWidth = cropSelection.width / scale;
            const sourceHeight = cropSelection.height / scale;

            console.log(`è£åˆ‡è³‡è¨Š:
            é è¦½é¸å€: ${cropSelection.x}, ${cropSelection.y}, ${cropSelection.width}x${cropSelection.height}
            ç¸®æ”¾å› å­: ${scale}
            åŸå§‹åº§æ¨™: ${sourceX}, ${sourceY}, ${sourceWidth}x${sourceHeight}
            åŸå§‹åœ–ç‰‡: ${originalCropImage.width}x${originalCropImage.height}
            `);

            const croppedCanvas = document.createElement('canvas');
            // è¨­å®š canvas ç‚ºåŸå§‹è§£æåº¦çš„å¤§å°
            croppedCanvas.width = sourceWidth;
            croppedCanvas.height = sourceHeight;
            const croppedCtx = croppedCanvas.getContext('2d');

            // ä½¿ç”¨é«˜å“è³ªè¨­å®š
            setupHighQualityCanvas(croppedCtx);

            croppedCtx.drawImage(
                originalCropImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // ä¾†æºåº§æ¨™ (åŸå§‹è§£æåº¦)
                0, 0, sourceWidth, sourceHeight              // ç›®æ¨™åº§æ¨™ (åŸå§‹è§£æåº¦)
            );

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡å¯¬åº¦ç¸®è‡³ 1000px
            let finalCanvas = croppedCanvas;
            if (croppedCanvas.width > 1000) {
                console.log(`è£åˆ‡å¾Œè‡ªå‹•ç¸®æ”¾: åŸå§‹å¯¬åº¦ ${croppedCanvas.width} -> ç›®æ¨™å¯¬åº¦ 1000px`);
                const newWidth = 1000;
                const newHeight = (croppedCanvas.height / croppedCanvas.width) * 1000;

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ (é è¨­ä½¿ç”¨ balanced å“è³ª)
                finalCanvas = safeAdvancedImageScale(croppedCanvas, newWidth, newHeight, 'balanced');
            }

            // ğŸ”¥ Removed auto-apply watermark logic
            // if (cropLogoImage) {
            //     const ctx = finalCanvas.getContext('2d');

            //     // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            //     const logoWidth = cropLogoImage.width * 0.7;
            //     const logoHeight = cropLogoImage.height * 0.7;

            //     // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            //     // æ³¨æ„ï¼šå¦‚æœåœ–ç‰‡è¢«ç¸®æ”¾åˆ° 1000pxï¼Œé‚Šè·ä¹Ÿæ‡‰è©²ç›¸å°èª¿æ•´ï¼Œä½†é€™è£¡å›ºå®š 15px æ‡‰è©²é‚„å¥½
            //     const logoX = finalCanvas.width - logoWidth - 15;
            //     const logoY = finalCanvas.height - logoHeight - 15;

            //     ctx.save();
            //     ctx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            //     ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            //     ctx.restore();

            //     console.log('å·²æ·»åŠ æµ®æ°´å°åˆ°è£åˆ‡åœ–ç‰‡');
            // }

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•åœ¨åœ–ç‰‡æœ€å¤–åœåŠ ä¸Š 1px é»‘é‚Š
            finalCanvas = addBlackBorder(finalCanvas);

            // å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡é¡¯ç¤ºåœ¨é è¦½å€
            showPreview(finalCanvas, 'cropped_image.jpg');
            status.innerHTML = 'åœ–ç‰‡è£åˆ‡å®Œæˆï¼å·²è‡ªå‹•èª¿æ•´å¯¬åº¦ç‚º 1000pxã€‚';

            // è£åˆ‡å®Œæˆå¾Œï¼Œéš±è—è£åˆ‡å€åŸŸä¸¦é‡ç½®ç‹€æ…‹
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            cropImageArea.style.display = 'none';

            // å°‡æ¨¡å¼åˆ‡æ›å›é è¨­çš„ resize320ï¼Œä¸¦æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥
            dropZone.style.display = 'none'; // ç¢ºä¿æ‹–æ›³å€éš±è—ï¼Œå› ç‚ºé è¦½å€æœƒé¡¯ç¤º
        }

        function cancelCrop() {
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥ // å–æ¶ˆå¾Œï¼Œåˆ‡æ›å›é è¨­æ¨¡å¼
        }

        // æ–°å¢çš„æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const fileInput2 = document.getElementById('fileInput2');
        const fileCount = document.getElementById('fileCount');
        const processButton = document.getElementById('processButton');
        const downloadButton = document.getElementById('downloadButton');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageList = document.getElementById('imageList');
        const editCanvas = document.getElementById('editCanvas');
        const editCtx = editCanvas.getContext('2d');
        const rectangleTool = document.getElementById('rectangleTool');
        const arrowTool = document.getElementById('arrowTool');
        const watermarkTool = document.getElementById('watermarkTool');
        const undoButton = document.getElementById('undoButton');
        const clearButton = document.getElementById('clearButton');
        const clearAllButton = document.getElementById('clearAllButton');

        const ARRANGE_MAX_WIDTH = 996;
        const ARRANGE_MAX_HEIGHT = 996;
        const SPACING = 2;
        const ARRANGE_MAX_IMAGES = 4;
        const BORDER_WIDTH = 2;

        let uploadedImages = [];
        let isDrawing = false;
        let startX, startY;
        let currentTool = null;
        let editHistory = [];
        let baseEditState = null;

        fileInput2.addEventListener('change', handleFileSelect);
        processButton.addEventListener('click', processImages);
        downloadButton.addEventListener('click', downloadProcessedImage);
        rectangleTool.addEventListener('click', () => {
            currentTool = 'rectangle';
            editCanvas.style.cursor = 'crosshair';
        });
        arrowTool.addEventListener('click', () => {
            currentTool = 'arrow';
            editCanvas.style.cursor = 'crosshair';
        });
        watermarkTool.addEventListener('click', () => {
            // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
            const savedWatermark = localStorage.getItem('cropWatermarkData');
            if (savedWatermark) {
                const img = new Image();
                img.onload = () => {
                    applyWatermarkToArrange(img);
                };
                img.src = savedWatermark;
            } else {
                // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                previewWatermarkInput.click();
            }
        });
        // ç›£è½ previewWatermarkInput çš„è®ŠåŒ–ï¼Œä»¥ä¾¿åœ¨é¸æ“‡å¾Œæ‡‰ç”¨æ–¼ä¸¦æ’æ¨¡å¼
        // æ³¨æ„ï¼šé€™è£¡éœ€è¦ä¸€å€‹æ©Ÿåˆ¶ä¾†å€åˆ†æ˜¯é è¦½æ¨¡å¼é‚„æ˜¯ä¸¦æ’æ¨¡å¼è§¸ç™¼çš„
        // ç°¡å–®è§£æ³•ï¼šåœ¨ previewWatermarkInput çš„ change äº‹ä»¶ä¸­ï¼Œæª¢æŸ¥ç•¶å‰æ¨¡å¼
        // ä½†å› ç‚º previewWatermarkInput å·²ç¶“ç¶å®šäº† applyWatermarkToPreviewï¼Œ
        // æˆ‘å€‘å¯èƒ½éœ€è¦ä¸€å€‹æ–°çš„ input æˆ–è€…ä¿®æ”¹ç¾æœ‰çš„é‚è¼¯ã€‚
        // ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘é‡ç”¨ previewWatermarkInputï¼Œä½†åœ¨å…¶ change handler ä¸­åˆ¤æ–·
        // æˆ–è€…ï¼Œæˆ‘å€‘ç›´æ¥åœ¨é€™è£¡æ·»åŠ ä¸€å€‹å°ˆç”¨çš„ handlerï¼Œä½†é€™æœƒå°è‡´é‡è¤‡ç¶å®š
        // æ›´å¥½çš„æ–¹æ³•ï¼šå‰µå»ºä¸€å€‹é€šç”¨çš„è™•ç†å‡½æ•¸

        undoButton.addEventListener('click', undo);
        clearButton.addEventListener('click', clearEdits);
        clearAllButton.addEventListener('click', clearAllImages);

        editCanvas.addEventListener('mousedown', startDrawing);
        editCanvas.addEventListener('mousemove', draw);
        editCanvas.addEventListener('mouseup', stopDrawing);
        editCanvas.addEventListener('mouseout', stopDrawing);

        function updateFileInputAndCount() {
            const remainingSlots = ARRANGE_MAX_IMAGES - uploadedImages.length;
            fileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            fileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            clearAllButton.style.display = uploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, ARRANGE_MAX_IMAGES - uploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        uploadedImages.push(img);
                        updateImageList();
                        updateFileInputAndCount();
                    }
                }
                reader.readAsDataURL(file);
            });
        }

        function createImageItem(img, index) {
            const div = document.createElement('div');
            div.className = 'image-item';
            div.draggable = true;
            div.dataset.uid = img._uid; // Store unique ID in DOM
            div.innerHTML = `
                <img src="${img.src}" alt="Image ${index + 1}">
                <button class="delete-button">åˆªé™¤</button>
            `;

            div.addEventListener('dragstart', dragStart);
            div.addEventListener('dragend', dragEnd);
            div.addEventListener('dragenter', dragEnter);
            div.addEventListener('dragleave', dragLeave);
            div.addEventListener('dragover', dragOver);
            div.addEventListener('drop', drop);
            div.querySelector('.delete-button').addEventListener('click', () => deleteImage(index));

            return div;
        }

        function dragStart(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.index);
        }

        function dragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function dragEnter(e) {
            e.preventDefault();
            if (!this.classList.contains('dragging')) {
                this.classList.add('drag-over');
            }
        }

        function dragLeave(e) {
            this.classList.remove('drag-over');
        }

        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function drop(e) {
            e.preventDefault();
            const draggable = document.querySelector('.dragging');
            if (this !== draggable) {
                const allItems = [...imageList.querySelectorAll('.image-item')];
                const draggedIndex = allItems.indexOf(draggable);
                const targetIndex = allItems.indexOf(this);
                if (draggedIndex < targetIndex) {
                    this.parentNode.insertBefore(draggable, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggable, this);
                }
                updateImageOrder();
            }
            this.classList.remove('drag-over');
        }

        function updateImageOrder() {
            const newOrderIds = Array.from(imageList.children).map(item => item.dataset.uid);
            uploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));
        }

        function deleteImage(index) {
            uploadedImages.splice(index, 1);
            updateImageList();
            updateFileInputAndCount();
        }

        function updateImageList() {
            imageList.innerHTML = '';
            uploadedImages.forEach((img, index) => {
                const imageItem = createImageItem(img, index);
                imageItem.dataset.index = index;
                imageList.appendChild(imageItem);
            });
        }

        function clearAllImages() {
            uploadedImages = [];
            updateImageList();
            updateFileInputAndCount();
            fileInput2.value = '';
        }

        function processImages() {
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            const newOrder = Array.from(imageList.children).map(item => item.querySelector('img').src);
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            // Ensure order is correct before processing
            updateImageOrder();

            arrangeImages(uploadedImages);
            downloadButton.style.display = 'block';

            clearEdits();
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
        }

        function arrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šç‚ºæ¯å¼µåœ–ç‰‡æ·»åŠ é»‘æ¡†ä¸¦è¨ˆç®—å°ºå¯¸
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // å‰µå»ºæ–°çš„Imageå°è±¡ç”¨æ–¼å¾ŒçºŒè™•ç†
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ä½¿ç”¨è™•ç†å¾Œçš„åœ–ç‰‡é€²è¡Œå¾ŒçºŒç¸®æ”¾è¨ˆç®—
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(ARRANGE_MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > ARRANGE_MAX_HEIGHT) {
                    newHeight = ARRANGE_MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // ç‚ºç¸®æ”¾å¾Œçš„åœ–ç‰‡æ·»åŠ é»‘æ¡†
                const borderedCanvas = addBlackBorder(scaledCanvas);

                totalWidth += borderedCanvas.width;
                maxHeight = Math.max(maxHeight, borderedCanvas.height);

                return { canvas: borderedCanvas, width: borderedCanvas.width, height: borderedCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            canvas.width = Math.min(ARRANGE_MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            canvas.height = Math.min(ARRANGE_MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡å¸¶é»‘æ¡†çš„åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (canvas.height - height) / 2;
                ctx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            resizeEditCanvas();

            document.getElementById('editTools').style.display = 'block';
        }

        function resizeEditCanvas() {
            editCanvas.width = canvas.width;
            editCanvas.height = canvas.height;
            editCanvas.style.display = 'block';
        }

        function startDrawing(e) {
            if (!currentTool) return;
            isDrawing = true;
            [startX, startY] = [e.offsetX, e.offsetY];
            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function draw(e) {
            if (!isDrawing || !currentTool) return;
            const [endX, endY] = [e.offsetX, e.offsetY];

            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            if (editHistory.length > 0) {
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
            }

            editCtx.beginPath();
            editCtx.strokeStyle = 'red';
            editCtx.lineWidth = 3;

            if (currentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                editCtx.save();
                editCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                editCtx.beginPath();
                editCtx.rect(startX + 3, startY + 3, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                editCtx.save();
                editCtx.strokeStyle = 'red';
                editCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                editCtx.beginPath();
                editCtx.rect(startX, startY, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();
            } else if (currentTool === 'arrow') {
                drawArrow(startX, startY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (currentTool === 'mosaic') {
                const x = Math.min(startX, endX);
                const y = Math.min(startY, endY);
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);
                drawMosaic(x, y, width, height);
            }

            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            editCtx.save();
            editCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            editCtx.fillStyle = 'rgba(0,0,0,0.3)';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX + 2, fromY + 2);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            editCtx.beginPath();
            editCtx.moveTo(toX + 2, toY + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            editCtx.save();
            editCtx.strokeStyle = 'red';
            editCtx.fillStyle = 'red';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';
            editCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX, fromY);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            editCtx.beginPath();
            editCtx.moveTo(toX, toY);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();
        }

        function undo() {
            if (editHistory.length > 1) {
                editHistory.pop();
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
                baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
            } else {
                clearEdits();
            }
        }

        function clearEdits() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
            baseEditState = null;
        }

        function applyWatermarkToArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = editCanvas.width - logoWidth - 15;
            const logoY = editCanvas.height - logoHeight - 15;

            editCtx.save();
            editCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            editCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            editCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function downloadProcessedImage() {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(canvas, 0, 0);
            finalCtx.drawImage(editCanvas, 0, 0);

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }

        window.addEventListener('load', function () {
            setMode('cropImage');
            updateFileInputAndCount();
            document.getElementById('editTools').style.display = 'none';
            updateQualityDescription(); // åˆå§‹åŒ–å“è³ªæè¿°
        });

        const mosaicTool = document.getElementById('mosaicTool');
        let isMosaicMode = false;
        const MOSAIC_SIZE = 10;

        mosaicTool.addEventListener('click', () => {
            currentTool = 'mosaic';
            isMosaicMode = true;
            editCanvas.style.cursor = 'crosshair';
        });

        function drawMosaic(x, y, width, height) {
            const imageData = ctx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = getAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            editCtx.putImageData(imageData, x, y);
        }

        function getAverageColor(imageData, startX, startY, size, width, height) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    const index = ((startY + j) * width + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        let lastX, lastY;
        editCanvas.addEventListener('mousemove', (e) => {
            lastX = e.offsetX;
            lastY = e.offsetY;
        });

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶é¸æ“‡è™•ç†
        function borderlessHandleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, MAX_IMAGES - borderlessUploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        borderlessUploadedImages.push(img);
                        borderlessUpdateImageList();
                        borderlessUpdateFileInputAndCount();
                    }
                    img.onerror = function () {
                        console.error('åœ–ç‰‡è¼‰å…¥å¤±æ•—:', file.name);
                    };
                }
                reader.readAsDataURL(file);
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶è¼¸å…¥æ›´æ–°
        function borderlessUpdateFileInputAndCount() {
            const remainingSlots = MAX_IMAGES - borderlessUploadedImages.length;
            borderlessFileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            borderlessFileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            borderlessClearAllButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆ—è¡¨æ›´æ–°
        function borderlessUpdateImageList() {
            borderlessImageList.innerHTML = '';
            borderlessUploadedImages.forEach((img, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.draggable = true;
                div.dataset.index = index;
                div.dataset.uid = img._uid; // Store unique ID in DOM

                const imgElement = document.createElement('img');
                imgElement.src = img.src;
                imgElement.alt = `åœ–ç‰‡ ${index + 1}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-button';
                deleteBtn.textContent = 'åˆªé™¤';
                deleteBtn.addEventListener('click', () => borderlessRemoveImage(index));

                div.appendChild(imgElement);
                div.appendChild(deleteBtn);
                borderlessImageList.appendChild(div);

                // æ‹–æ‹½åŠŸèƒ½
                div.addEventListener('dragstart', borderlessHandleDragStart);
                div.addEventListener('dragover', borderlessHandleDragOver);
                div.addEventListener('drop', borderlessHandleDrop);
                div.addEventListener('dragend', borderlessHandleDragEnd);
            });

            borderlessProcessButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆªé™¤
        function borderlessRemoveImage(index) {
            borderlessUploadedImages.splice(index, 1);
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ‹–æ‹½è™•ç†å‡½æ•¸
        function borderlessHandleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.index);
        }

        function borderlessHandleDragOver(e) {
            e.preventDefault();
            e.target.closest('.image-item').classList.add('drag-over');
        }

        function borderlessHandleDrop(e) {
            e.preventDefault();
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = parseInt(e.target.closest('.image-item').dataset.index);

            if (draggedIndex !== targetIndex) {
                const draggedItem = borderlessUploadedImages[draggedIndex];
                borderlessUploadedImages.splice(draggedIndex, 1);
                borderlessUploadedImages.splice(targetIndex, 0, draggedItem);
                borderlessUpdateImageList();
            }

            e.target.closest('.image-item').classList.remove('drag-over');
        }

        function borderlessHandleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('#borderlessImageList .image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡è™•ç†
        function borderlessProcessImages() {
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            // Re-sort based on DOM order to ensure consistency
            const newOrderIds = Array.from(borderlessImageList.children).map(item => item.dataset.uid);
            borderlessUploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));

            borderlessArrangeImages(borderlessUploadedImages);
            borderlessDownloadButton.style.display = 'block';

            borderlessClearEdits();
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
        }

        // ğŸ”¥ ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡æ’åˆ—ï¼ˆèˆ‡åŸç‰ˆå®Œå…¨ä¸€è‡´ï¼Œåªæ˜¯ä¸æ·»åŠ é»‘æ¡†ï¼‰
        function borderlessArrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šè™•ç†åœ–ç‰‡ä½†ä¸æ·»åŠ é»‘æ¡†ï¼ˆèˆ‡åŸç‰ˆé‚è¼¯ä¸€è‡´ï¼‰
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // ğŸ”§ ä¿®å¾©ï¼šèˆ‡é‚Šæ¡†ç‰ˆæœ¬ä¸€è‡´ï¼Œå‰µå»ºå°è±¡è€Œä¸æ˜¯æ–°Image
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨èˆ‡é‚Šæ¡†ç‰ˆæœ¬ç›¸åŒçš„ç¸®æ”¾é‚è¼¯
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > MAX_HEIGHT) {
                    newHeight = MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // âœ¨ é—œéµå·®ç•°ï¼šç„¡é‚Šæ¡†ç‰ˆæœ¬ä¸æ·»åŠ é»‘æ¡†
                // åŸç‰ˆæœƒèª¿ç”¨: const borderedCanvas = addBlackBorder(scaledCanvas);
                // ç„¡é‚Šæ¡†ç‰ˆæœ¬ç›´æ¥ä½¿ç”¨ scaledCanvas

                totalWidth += scaledCanvas.width;
                maxHeight = Math.max(maxHeight, scaledCanvas.height);

                return { canvas: scaledCanvas, width: scaledCanvas.width, height: scaledCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            borderlessCanvas.width = Math.min(MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            borderlessCanvas.height = Math.min(MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            borderlessCtx.fillStyle = 'white';
            borderlessCtx.fillRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (borderlessCanvas.height - height) / 2;
                borderlessCtx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            // è¨­ç½®ç·¨è¼¯canvas
            borderlessEditCanvas.width = borderlessCanvas.width;
            borderlessEditCanvas.height = borderlessCanvas.height;
            borderlessEditCanvas.style.display = 'block';

            document.getElementById('borderlessEditTools').style.display = 'block';
            borderlessInitializeEditTools();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç·¨è¼¯å·¥å…·åˆå§‹åŒ–
        function borderlessInitializeEditTools() {
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);

            borderlessRectangleTool.addEventListener('click', () => borderlessSetTool('rectangle'));
            borderlessArrowTool.addEventListener('click', () => borderlessSetTool('arrow'));
            borderlessWatermarkTool.addEventListener('click', () => {
                // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
                const savedWatermark = localStorage.getItem('cropWatermarkData');
                if (savedWatermark) {
                    const img = new Image();
                    img.onload = () => {
                        applyWatermarkToBorderlessArrange(img);
                    };
                    img.src = savedWatermark;
                } else {
                    // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                    // é€™è£¡æˆ‘å€‘éœ€è¦ä¸€å€‹è®Šé‡ä¾†æ¨™è¨˜ç•¶å‰æ˜¯å“ªå€‹æ¨¡å¼è§¸ç™¼çš„æµ®æ°´å°é¸æ“‡
                    // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘å‡è¨­ä½¿ç”¨è€…å·²ç¶“åœ¨è£åˆ‡æ¨¡å¼è¨­å®šå¥½æµ®æ°´å°ï¼Œæˆ–è€…æˆ‘å€‘å¼•å°ä»–å€‘å»è¨­å®š
                    // æˆ–è€…ï¼Œæˆ‘å€‘å¯ä»¥è‡¨æ™‚å€Ÿç”¨ previewWatermarkInput
                    previewWatermarkInput.click();
                }
            });
            borderlessMosaicTool.addEventListener('click', () => borderlessSetTool('mosaic'));
            borderlessUndoButton.addEventListener('click', borderlessUndo);
            borderlessClearButton.addEventListener('click', borderlessClearAllEdits);

            borderlessEditCanvas.addEventListener('mousedown', borderlessStartDrawing);
            borderlessEditCanvas.addEventListener('mousemove', borderlessDraw);
            borderlessEditCanvas.addEventListener('mouseup', borderlessStopDrawing);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å·¥å…·è¨­ç½®
        function borderlessSetTool(tool) {
            borderlessCurrentTool = tool;
            document.querySelectorAll('#borderlessEditTools button').forEach(btn => btn.classList.remove('active'));
            if (tool === 'rectangle') {
                borderlessRectangleTool.classList.add('active');
            } else if (tool === 'arrow') {
                borderlessArrowTool.classList.add('active');
            } else if (tool === 'mosaic') {
                borderlessMosaicTool.classList.add('active');
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç¹ªåœ–äº‹ä»¶è™•ç†
        function borderlessStartDrawing(e) {
            if (!borderlessCurrentTool) return;
            borderlessIsDrawing = true;
            const rect = borderlessEditCanvas.getBoundingClientRect();
            borderlessStartX = e.clientX - rect.left;
            borderlessStartY = e.clientY - rect.top;
        }

        function borderlessDraw(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            // é è¦½åŠŸèƒ½å¯ä»¥åœ¨é€™è£¡æ·»åŠ 
        }

        function borderlessStopDrawing(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            borderlessIsDrawing = false;

            const rect = borderlessEditCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„
            if (borderlessEditHistory.length > 10) {
                borderlessEditHistory.shift();
            }

            borderlessEditCtx.beginPath();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.lineWidth = 3;

            if (borderlessCurrentTool === 'rectangle') {
                // çŸ©å½¢å·¥å…· - æ·»åŠ é™°å½±æ•ˆæœ
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                borderlessEditCtx.lineWidth = 3;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX + 3, borderlessStartY + 3, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'red';
                borderlessEditCtx.lineWidth = 2;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX, borderlessStartY, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();
            } else if (borderlessCurrentTool === 'arrow') {
                borderlessDrawArrow(borderlessStartX, borderlessStartY, endX, endY);
            } else if (borderlessCurrentTool === 'mosaic') {
                const x = Math.min(borderlessStartX, endX);
                const y = Math.min(borderlessStartY, endY);
                const width = Math.abs(endX - borderlessStartX);
                const height = Math.abs(endY - borderlessStartY);
                borderlessDrawMosaic(x, y, width, height);
            }

            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç®­é ­ç¹ªè£½å‡½æ•¸
        function borderlessDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ç¹ªè£½é™°å½±æ•ˆæœ
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX + 2, fromY + 2);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2);
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX + 2, toY + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.fillStyle = 'red';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';
            borderlessEditCtx.lineJoin = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX, fromY);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle));
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX, toY);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„é¦¬è³½å…‹ç¹ªè£½å‡½æ•¸
        function borderlessDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = borderlessCtx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = borderlessGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            borderlessEditCtx.putImageData(imageData, x, y);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å¹³å‡é¡è‰²è¨ˆç®—å‡½æ•¸
        function borderlessGetAverageColor(imageData, startX, startY, size, totalWidth, totalHeight) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let x = startX; x < startX + size && x < totalWidth; x++) {
                for (let y = startY; y < startY + size && y < totalHeight; y++) {
                    const index = (y * totalWidth + x) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.floor(r / count), Math.floor(g / count), Math.floor(b / count)];
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ’¤éŠ·åŠŸèƒ½
        function borderlessUndo() {
            if (borderlessEditHistory.length > 1) {
                borderlessEditHistory.pop();
                borderlessEditCtx.putImageData(borderlessEditHistory[borderlessEditHistory.length - 1], 0, 0);
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰ç·¨è¼¯
        function borderlessClearAllEdits() {
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = null;
        }

        function applyWatermarkToBorderlessArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = borderlessEditCanvas.width - logoWidth - 15;
            const logoY = borderlessEditCanvas.height - logoHeight - 15;

            borderlessEditCtx.save();
            borderlessEditCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            borderlessEditCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            borderlessEditCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰åœ–ç‰‡
        function borderlessClearAllImages() {
            borderlessUploadedImages = [];
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
            borderlessDownloadButton.style.display = 'none';
            document.getElementById('borderlessEditTools').style.display = 'none';
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
            borderlessFileInput2.value = ''; // æ¸…é™¤æ–‡ä»¶è¼¸å…¥
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ä¸‹è¼‰åŠŸèƒ½
        function borderlessDownloadProcessedImage() {
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = borderlessCanvas.width;
            finalCanvas.height = borderlessCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(borderlessCanvas, 0, 0);
            finalCtx.drawImage(borderlessEditCanvas, 0, 0);

            // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98;
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99;
                    break;
                case 'high':
                    jpegQuality = 0.95;
                    break;
                case 'balanced':
                    jpegQuality = 0.90;
                    break;
                case 'fast':
                    jpegQuality = 0.80;
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'borderless_processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }
    </script>

    <style>
        #minimax-floating-ball {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 12px;
            background: #222222;
            border-radius: 12px;
            display: flex;
            align-items: center;
            color: #F8F8F8;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            z-index: 9999;
            transition: all 0.3s ease;
            overflow: hidden;
            cursor: pointer;
        }

        #minimax-floating-ball:hover {
            transform: translateY(-2px);
            background: #383838;
        }

        .minimax-ball-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .minimax-logo-wave {
            width: 26px;
            height: 22px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='26' height='22' viewBox='0 0 26 22' fill='none'%3E%3Cg clip-path='url(%23clip0_3442_102412)'%3E%3Cpath d='M12.8405 14.6775C12.8405 14.9897 13.0932 15.2424 13.4055 15.2424C13.7178 15.2424 13.9705 14.9897 13.9705 14.6775V2.98254C13.9705 1.88957 13.0809 1 11.9879 1C10.895 1 10.0054 1.88957 10.0054 2.98254V11.566V17.1068C10.0054 17.5773 9.62327 17.9594 9.1528 17.9594C8.68233 17.9594 8.30021 17.5773 8.30021 17.1068V8.04469C8.30021 6.95172 7.41063 6.06215 6.31767 6.06215C5.22471 6.06215 4.33513 6.95172 4.33513 8.04469V11.8855C4.33513 12.3559 3.953 12.7381 3.48254 12.7381C3.01207 12.7381 2.62994 12.3559 2.62994 11.8855V10.4936C2.62994 10.1813 2.37725 9.92861 2.06497 9.92861C1.7527 9.92861 1.5 10.1813 1.5 10.4936V11.8855C1.5 12.9784 2.38957 13.868 3.48254 13.868C4.5755 13.868 5.46508 12.9784 5.46508 11.8855V8.04469C5.46508 7.57422 5.8472 7.19209 6.31767 7.19209C6.78814 7.19209 7.17026 7.57422 7.17026 8.04469V17.1068C7.17026 18.1998 8.05984 19.0894 9.1528 19.0894C10.2458 19.0894 11.1353 18.1998 11.1353 17.1068V2.98254C11.1353 2.51207 11.5175 2.12994 11.9879 2.12994C12.4584 2.12994 12.8405 2.51207 12.8405 2.98254V14.6775Z' fill='%23F8F8F8'/%3E%3Cpath d='M23.3278 6.06215C22.2348 6.06215 21.3452 6.95172 21.3452 8.04469V15.6143C21.3452 16.0847 20.98631 16.4669 20.4926 16.4669C20.0222 16.4669 19.6401 16.0847 19.6401 15.6143V2.98254C19.6401 1.88957 18.7505 1 17.6575 1C16.5645 1 15.675 1.88957 15.675 2.98254V19.0175C15.675 19.4879 15.2928 19.8701 14.8224 19.8701C14.3519 19.8701 13.9698 19.4879 13.9698 19.0175V17.0329C13.9698 16.7206 13.7171 16.4679 13.4048 16.4679C13.0925 16.4679 12.8398 16.7206 12.8398 17.0329V19.0175C12.8398 20.1104 13.7294 21 14.8224 21C15.9153 21 16.8049 20.1104 16.8049 19.0175V2.98254C16.8049 2.51207 17.187 2.12994 17.6575 2.12994C18.128 2.12994 18.5101 2.51207 18.5101 2.98254V15.6143C18.5101 16.7072 19.3997 17.5968 20.4926 17.5968C21.5856 17.5968 22.4752 16.7072 22.4752 15.6143V8.04469C22.4752 7.57422 22.8573 7.19209 23.3278 7.19209C23.7982 7.19209 24.1804 7.57422 24.1804 8.04469V14.6775C24.1804 14.9897 24.4331 15.2424 24.7453 15.2424C25.0576 15.2424 25.3103 14.9897 25.3103 14.6775V8.04469C25.3103 6.95172 24.4207 6.06215 23.3278 6.06215Z' fill='%23F8F8F8'/%3E%3C/g%3E%3Cdefs%3E%3CclipPath id='clip0_3442_102412'%3E%3Crect width='25' height='22' fill='white' transform='translate(0.5)'/%3E%3C/clipPath%3E%3C/defs%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
        }

        .minimax-ball-text {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }

        .minimax-close-icon {
            margin-left: 8px;
            font-size: 16px;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .minimax-close-icon:hover {
            opacity: 1;
        }
    </style>
    <div id="minimax-floating-ball">
        <div class="minimax-ball-content">
            <div class="minimax-logo-wave"></div>
            <span class="minimax-ball-text">Created by MiniMax Agent</span>
        </div>
        <div class="minimax-close-icon">Ã—</div>
    </div>
    <script>
        // Initialize floating ball functionality
        function initFloatingBall() {
            const ball = document.getElementById('minimax-floating-ball');
            if (!ball) return;

            // Initial animation
            ball.style.opacity = '0';
            ball.style.transform = 'translateY(20px)';

            setTimeout(() => {
                ball.style.opacity = '1';
                ball.style.transform = 'translateY(0)';
            }, 500);

            // Handle logo click
            const ballContent = ball.querySelector('.minimax-ball-content');
            ballContent.addEventListener('click', function (e) {
                e.stopPropagation();
                window.open('https://agent.minimax.io/agent', '_blank');
                ball.style.transform = 'scale(0.985)';
                setTimeout(() => {
                    ball.style.transform = 'scale(1)';
                }, 100);
            });

            // Handle close button click
            const closeIcon = ball.querySelector('.minimax-close-icon');
            closeIcon.addEventListener('click', function (e) {
                e.stopPropagation();
                ball.style.opacity = '0';
                ball.style.transform = 'translateY(20px)';

                setTimeout(() => {
                    ball.style.display = 'none';
                }, 300);
            });
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initFloatingBall); 
    </script>

</body>

</html>