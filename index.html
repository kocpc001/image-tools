<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 20px;
            width: 100%;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        #dropZone.dragover {
            background-color: #e1e1e1;
        }

        #fileInput,
        #logoInput {
            display: none;
        }

        #status {
            margin-top: 20px;
        }

        .mode-buttons {
            margin-bottom: 20px;
        }

        .mode-button {
            margin-right: 10px;
            padding: 10px 15px;
            background-color: #ccc;
            border: none;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .mode-button.active {
            background-color: #007bff;
            color: #fff;
        }

        #logoPreview {
            max-width: 100px;
            max-height: 100px;
            margin-top: 10px;
            display: none;
        }

        #screenshotArrange,
        #borderlessScreenshotArrange {
            margin-top: 30px;
            text-align: center;
        }

        #fileInput2,
        #borderlessFileInput2 {
            margin-bottom: 10px;
        }

        #canvasContainer,
        #borderlessCanvasContainer {
            position: relative;
            display: inline-block;
        }

        #canvas,
        #borderlessCanvas {
            border: 1px solid #000;
        }

        #imageList,
        #borderlessImageList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .image-item {
            width: 150px;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: move;
            position: relative;
            user-select: none;
        }

        .image-item img {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
        }

        .image-item.dragging {
            opacity: 0.5;
        }

        .image-item.drag-over {
            border: 2px dashed #000;
        }

        .delete-button {
            margin-top: 5px;
            padding: 2px 5px;
            background-color: #cc0000;
            color: white;
            border: none;
            cursor: pointer;
        }

        #downloadButton,
        #borderlessDownloadButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            display: none;
        }

        #editTools,
        #borderlessEditTools {
            margin-top: 10px;
        }

        #editTools button,
        #borderlessEditTools button,
        #previewEditTools button {
            margin-right: 5px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        #editTools button:hover,
        #borderlessEditTools button:hover,
        #previewEditTools button:hover {
            background-color: #e0e0e0;
        }

        #editCanvas,
        #borderlessEditCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #clearAllButton,
        #borderlessClearAllButton {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            cursor: pointer;
        }

        /* ç¸®æ”¾å“è³ªé¸é …æ¨£å¼ */
        .quality-control {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .quality-control label {
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
            color: #495057;
        }

        .quality-control select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: white;
            font-size: 14px;
        }

        .quality-info {
            margin-top: 8px;
            font-size: 12px;
            color: #6c757d;
            line-height: 1.4;
        }

        .quality-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 5px;
        }

        .badge-ultra {
            background-color: #28a745;
            color: white;
        }

        .badge-high {
            background-color: #17a2b8;
            color: white;
        }

        .badge-balanced {
            background-color: #ffc107;
            color: black;
        }

        .badge-fast {
            background-color: #dc3545;
            color: white;
        }

        /* ç¹ç°¡è½‰æ›å™¨æ¨£å¼ */
        #chineseConvArea {
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .conv-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .conv-title {
            font-size: 24px;
            font-weight: bold;
        }

        .conv-subtitle {
            font-size: 14px;
            color: #888;
            margin-left: 10px;
        }

        .conv-main {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .conv-section {
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f8fafc;
        }

        .conv-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #edf2f7;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 8px 8px 0 0;
        }

        .conv-label {
            font-weight: bold;
            color: #2d3748;
        }

        .conv-tag {
            font-size: 12px;
            color: #718096;
            font-family: monospace;
        }

        .conv-textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: none;
            resize: none;
            background-color: transparent;
            font-size: 16px;
            line-height: 1.6;
            outline: none;
            box-sizing: border-box;
        }

        .conv-output-area {
            height: 150px;
            padding: 15px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 16px;
            line-height: 1.6;
        }

        .conv-output-container {
            display: flex;
            gap: 20px;
        }

        .conv-output-box {
            flex: 1;
        }

        .conv-tools {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .conv-section:hover .conv-tools {
            opacity: 1;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            color: #718096;
        }

        .icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: #2d3748;
        }

        /* Dictionary Dialog */
        #dictDialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .dict-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 500px;
            max-width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .dict-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .dict-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
        }

        .dict-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .dict-item:last-child {
            border-bottom: none;
        }

        .dict-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .dict-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
        }

        .btn-primary {
            background-color: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-primary:hover {
            background-color: #2c5282;
        }

        .btn-danger {
            color: #e53e3e;
            background: none;
            border: none;
            cursor: pointer;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-outline:hover {
            background-color: #f7fafc;
        }

        /* HTML Cleaner æ¨£å¼ */
        #htmlCleanerArea {
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .cleaner-tag {
            background: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .cleaner-tag-remove {
            cursor: pointer;
            color: #e53e3e;
            font-weight: bold;
        }

        /* Magic Remover (v2) styles */
        #magicRemoverArea {
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            max-width: 1000px;
            margin: 20px auto;
        }

        .mr-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mr-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }

        .mr-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mr-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
        }

        .mr-control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mr-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #4a5568;
        }

        .mr-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .mr-canvas-container {
            position: relative;
            background: #edf2f7;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mrCanvas {
            max-width: 100%;
            height: auto;
            display: block;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #mrMaskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            pointer-events: none;
            /* We handle events on the main canvas wrapper */
        }

        .mr-progress-container {
            display: none;
            margin-top: 10px;
        }

        .mr-progress-bar {
            height: 10px;
            background: #edf2f7;
            border-radius: 5px;
            overflow: hidden;
        }

        .mr-progress-fill {
            height: 100%;
            background: #4299e1;
            width: 0%;
            transition: width 0.3s ease;
        }

        .mr-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: none;
        }

        .mr-btn-primary {
            background: #4299e1;
            color: white;
        }

        .mr-btn-primary:hover {
            background: #3182ce;
        }

        .mr-btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .mr-btn-secondary:hover {
            background: #cbd5e0;
        }

        .mr-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;

            .mr-switch input {
                cursor: pointer;
            }

            /* Batch Image Grid Styles */
            .mr-batch-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 15px;
                width: 100%;
                padding: 15px;
                max-height: 100%;
                overflow-y: auto;
                box-sizing: border-box;
            }

            .mr-batch-item {
                position: relative;
                aspect-ratio: 1;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                background: #f0f0f0;
                transition: transform 0.2s;
            }

            .mr-batch-item:hover {
                transform: translateY(-2px);
            }

            .mr-batch-item img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mr-batch-badge {
                position: absolute;
                top: 5px;
                left: 5px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                font-size: 0.7rem;
                padding: 2px 6px;
                border-radius: 4px;
                backdrop-filter: blur(2px);
            }

            .mr-batch-badge.success {
                background: #48bb78;
            }

            .mr-batch-badge.processing {
                background: #ed8936;
            }

            .mr-batch-delete {
                position: absolute;
                top: 5px;
                right: 5px;
                background: #e53e3e;
                color: white;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 0.8rem;
                opacity: 0;
                transition: opacity 0.2s;
            }
        }

        .mr-switch input {
            cursor: pointer;
        }

        /* Batch Image Grid Styles */
        .mr-batch-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            width: 100%;
            padding: 15px;
            max-height: 100%;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .mr-batch-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background: #f0f0f0;
            transition: transform 0.2s;
        }

        .mr-batch-item:hover {
            transform: translateY(-2px);
        }

        .mr-batch-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .mr-batch-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            backdrop-filter: blur(2px);
        }

        .mr-batch-badge.success {
            background: #48bb78;
        }

        .mr-batch-badge.processing {
            background: #ed8936;
        }

        .mr-batch-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e53e3e;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .mr-batch-item:hover .mr-batch-delete {
            opacity: 1;
        }

        /* Word Table to HTML Styles Refined - Absolute Positioning Strategy */
        #wordTableToHtmlArea {
            display: none;
            background-color: #f8fafc;
            padding: 20px;
            width: 100%;
            height: calc(100vh - 100px);
            /* Use viewport height */
            box-sizing: border-box;
            position: relative;
        }

        .wt-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }

        .wt-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-width: 0;
            position: relative;
        }

        .wt-card {
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            flex: 1;
            height: 100%;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            /* Context for absolute children */
        }

        .wt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            flex-shrink: 0;
            height: 40px;
        }

        .wt-card-title {
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #1e293b;
        }

        /* Tabs Header */
        .wt-tabs-header {
            display: flex;
            flex-direction: row !important;
            /* Force row */
            flex-wrap: nowrap !important;
            border-bottom: 1px solid #f1f5f9;
            background: rgba(241, 245, 249, 0.5);
            padding: 0 16px;
            height: 48px;
            align-items: center;
            flex-shrink: 0;
        }

        .wt-tab-item {
            padding: 0 16px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #64748b;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .wt-tab-item:hover {
            color: #0f172a;
        }

        .wt-tab-item.active {
            color: #0f172a;
            border-bottom-color: #2563eb;
            background: white;
        }

        /* Tab Content - Absolute Positioning for stability */
        .wt-tab-content {
            display: none;
            position: absolute;
            top: 48px;
            /* Height of tabs header */
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            overflow: auto;
            /* Enable scrollbars for content */
        }

        .wt-tab-content.active {
            display: block;
        }

        /* Force preview table to have a minimum width to ensure readability and trigger scrollbar */
        #wtPreview table {
            min-width: 800px !important;
        }

        /* Specific modifications for Code View */
        #wtTabCode {
            background: #020617;
            /* Dark background */
        }

        .wt-code-textarea {
            display: block;
            width: 100%;
            height: 100%;
            /* Fill absolute container */
            resize: none;
            border: none;
            background: transparent;
            color: #f8fafc;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            padding: 20px;
            font-size: 13px;
            outline: none;
            box-sizing: border-box;
            margin: 0;
            white-space: pre;
            /* Ensure code doesn't wrap unnecessarily if not desired, or pre-wrap */
            overflow: auto;
            /* Ensure scrollbars on textarea */
        }

        /* Input Card Content - Use Flexbox for Input to respect sibling header */
        #wtInput {
            position: relative;
            flex: 1;
            width: 100%;
            height: auto;
            overflow: auto;
            padding: 24px;
            outline: none;
            box-sizing: border-box;
            white-space: normal;
            /* Ensure normal text wrapping behavior in input */
        }

        /* Ensure the input wrapper/card handles flex correctly */
        .wt-input-wrapper {
            position: relative;
            flex: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        @media (max-width: 1024px) {
            .wt-container {
                grid-template-columns: 1fr;
                height: auto;
                display: block;
                /* Stack them */
            }

            .wt-column {
                height: 500px;
                /* Fixed height for mobile sections */
                margin-bottom: 20px;
            }

            #wordTableToHtmlArea {
                height: auto;
            }
        }
    </style>

</head>

<body>
    <h1 id="pageTitle">åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ <small style="color: #666; font-size: 0.6em;">(ä¿®å¾©ç·šæ¢å•é¡Œ)</small></h1>

    <!-- ç¸®æ”¾å“è³ªæ§åˆ¶ -->
    <div class="quality-control">
        <label for="scalingQuality">ğŸ¯ ç¸®æ”¾å“è³ªé¸æ“‡ï¼š</label>
        <select id="scalingQuality">
            <option value="ultra">è¶…é«˜å“è³ª - å¤šæ­¥é©Ÿç¸®æ”¾ (ç„¡éŠ³åŒ–)</option>
            <option value="high">é«˜å“è³ª - é«˜å“è³ªCanvasç¸®æ”¾</option>
            <option value="balanced" selected>å¹³è¡¡ - æ¨™æº–é«˜å“è³ªç¸®æ”¾ (é è¨­)</option>
            <option value="fast">å¿«é€Ÿ - èˆ‡åŸç‰ˆç›¸åŒ</option>
        </select>
        <div class="quality-info">
            <div id="qualityDescription">
                <span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>
                ä½¿ç”¨é«˜å“è³ªCanvasç¸®æ”¾ï¼Œåœ¨å“è³ªå’Œé€Ÿåº¦é–“å–å¾—å¹³è¡¡ï¼Œå·²ä¿®å¾©ç·šæ¢å•é¡Œ
            </div>
        </div>
    </div>

    <div class="mode-buttons">
        <button id="cropImageMode" class="mode-button active">åœ–ç‰‡è£åˆ‡</button>
        <button id="resize320Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰</button>
        <button id="resize1080Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰</button>
        <button id="addWatermarkMode" class="mode-button">æ·»åŠ æµ®æ°´å°</button>
        <button id="adaSpecialMode" class="mode-button">é›»è…¦ç‹é˜¿é”å°ˆç”¨</button>
        <button id="screenshotArrangeMode" class="mode-button">æˆªåœ–ä¸¦æ’</button>
        <button id="borderlessScreenshotArrangeMode" class="mode-button">ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’</button>
        <button id="chineseConvMode" class="mode-button">ç°¡ç¹è½‰æ›</button>
        <button id="htmlCleanerMode" class="mode-button">å»é™¤ç„¡ç”¨å­—å…ƒ</button>
        <button id="magicRemoverMode" class="mode-button">å»æµ®æ°´å°</button>
        <button id="wordTableMode" class="mode-button">Wordè¡¨æ ¼è½‰HTML</button>
    </div>
    <div id="dropZone">
        <p>æ‹–æ›³åœ–ç‰‡åˆ°é€™è£¡æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*">
    <div id="status"></div>

    <!-- çµ±ä¸€é è¦½å’Œç·¨è¼¯å€åŸŸ -->
    <div id="previewArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>è™•ç†çµæœé è¦½</h3>
        <div id="previewCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="previewCanvas"
                style="border: 1px solid #000; max-width: 100%; height: auto; display: block;"></canvas>
            <canvas id="previewEditCanvas"
                style="position: absolute; top: 0; left: 0; cursor: crosshair; width: 100%; height: 100%;"></canvas>
            <button id="previewDownloadButton"
                style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="previewEditTools" style="margin-top: 10px;">
            <button id="previewRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="previewWatermarkTool">æµ®æ°´å°</button>
            <input type="file" id="previewWatermarkInput" accept="image/*" style="display: none;">
            <button id="previewArrowTool">ç®­é ­å·¥å…·</button>
            <button id="previewMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="previewUndoButton">å¾©åŸ</button>
            <button id="previewClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
        <div style="margin-top: 10px;">
            <button id="processMoreButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; margin-right: 10px;">è™•ç†æ›´å¤šåœ–ç‰‡</button>
            <button id="clearPreviewButton"
                style="padding: 10px 15px; background-color: #6c757d; color: white; border: none; cursor: pointer; margin-right: 10px;">æ¸…é™¤é è¦½</button>
            <button id="downloadPNGButton"
                style="padding: 10px 15px; background-color: #28a745; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰PNGé«˜ç•«è³ª</button>
        </div>
    </div>
    <div>
        <button id="selectLogoBtn" style="display: none;">é¸æ“‡ Logo</button>
        <button id="selectAdaLogoBtn" style="display: none;">é¸æ“‡é˜¿é”å°ˆç”¨ Logo</button>
        <input type="file" id="logoInput" accept="image/*" style="display: none;">
        <span id="logoStatus"></span>
        <img id="logoPreview" alt="Logo Preview" style="display: none;">
    </div>

    <div id="screenshotArrange" style="display: none;">
        <input type="file" id="fileInput2" multiple accept="image/*">
        <span id="fileCount"></span>
        <button id="clearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="imageList"></div>
        <button id="processButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            <canvas id="editCanvas"></canvas>
            <button id="downloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="editTools">
            <button id="rectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="arrowTool">ç®­é ­å·¥å…·</button>
            <button id="watermarkTool">æµ®æ°´å°</button>
            <button id="mosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="undoButton">å¾©åŸ</button>
            <button id="clearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <div id="borderlessScreenshotArrange" style="display: none;">
        <input type="file" id="borderlessFileInput2" multiple accept="image/*">
        <span id="borderlessFileCount"></span>
        <button id="borderlessClearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="borderlessImageList"></div>
        <button id="borderlessProcessButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="borderlessCanvasContainer">
            <canvas id="borderlessCanvas"></canvas>
            <canvas id="borderlessEditCanvas"></canvas>
            <button id="borderlessDownloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="borderlessEditTools">
            <button id="borderlessRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="borderlessArrowTool">ç®­é ­å·¥å…·</button>
            <button id="borderlessWatermarkTool">æµ®æ°´å°</button>
            <button id="borderlessMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="borderlessUndoButton">å¾©åŸ</button>
            <button id="borderlessClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <!-- å»æµ®æ°´å°å€åŸŸ (v2) -->
    <div id="magicRemoverArea">
        <div class="mr-container">
            <div class="mr-controls"
                style="display: flex; flex-direction: column; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px;">

                <!-- Main Control Row: Modes (Left) + Buttons (Right) -->
                <div
                    style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">

                    <!-- Left: Modes -->
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span class="mr-label" style="font-weight: bold; color: #4a5568;">è™•ç†æ¨¡å¼:</span>

                        <label class="mr-switch" style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="mrGeminiMode" checked>
                            <span style="font-size: 0.9rem;">Gemini å°ˆç”¨ (è‡ªå‹•)</span>
                        </label>

                        <label class="mr-switch" style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="mrBatchMode">
                            <span style="font-size: 0.9rem;">æ‰¹æ¬¡è™•ç†</span>
                        </label>
                    </div>

                    <!-- Right: Compact Action Buttons -->
                    <div style="display: flex; gap: 10px;">
                        <button id="mrProcessBtn" class="mr-btn mr-btn-primary"
                            style="font-size: 0.9rem; padding: 6px 15px; min-width: auto;" disabled>
                            ç§»é™¤æµ®æ°´å°
                        </button>
                        <button id="mrDownloadBtn" class="mr-btn mr-btn-secondary"
                            style="font-size: 0.9rem; padding: 6px 15px; min-width: auto;" disabled>
                            ä¸‹è¼‰ç…§ç‰‡
                        </button>
                        <button id="mrOneClickBtn" class="mr-btn"
                            style="font-size: 0.9rem; padding: 6px 15px; min-width: auto; background-color: #eab308; color: white;"
                            disabled>
                            âš¡ ä¸€éµå®Œæˆ
                        </button>
                    </div>
                </div>

                <!-- Secondary Row: Settings (Hidden by default) -->
                <div id="mrBrushSizeGroup"
                    style="display: none; border-top: 1px solid #e2e8f0; padding-top: 10px; margin-top: 5px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label class="mr-label" style="font-size: 0.9rem;">é­”æ³•æ£’å®¹è¨±åº¦: <span id="mrBrushSizeVal"
                                style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">20</span></label>
                        <input type="range" id="mrBrushSize" min="1" max="100" value="20"
                            style="flex: 1; max-width: 300px;">
                    </div>
                </div>
            </div>

            <div class="mr-canvas-container" id="mrCanvasWrapper"
                style="align-items: center; justify-content: center; position: relative;">
                <!-- Dedicated File Input for Magic Remover -->
                <input type="file" id="mrFileInput" accept="image/*" style="display: none;">

                <div id="mrEmptyState"
                    style="text-align: center; color: #718096; cursor: pointer; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                    <p style="pointer-events: none;">è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–å¾é è¦½å€å¸¶å…¥<br><span
                            style="font-size: 0.8em; color: #a0aec0;">(é»æ“Šæ­¤è™•ä¸Šå‚³)</span></p>
                </div>
                <div id="mrCanvasInner" style="position: relative; display: none;">
                    <!-- Reset/Undo Button (Top-Left) -->
                    <div id="mrResetImageBtn" style="
                        position: absolute; 
                        top: 10px; 
                        left: 10px; 
                        width: 30px; 
                        height: 30px; 
                        background-color: #3182ce; 
                        color: white; 
                        border-radius: 50%; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        cursor: pointer; 
                        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                        z-index: 20;
                        font-weight: bold;
                        user-select: none;
                    " title="é‡æ–°é¸å– / å¾©åŸ">â†©</div>

                    <canvas id="mrCanvas"
                        style="display: block; max-width: 100%; max-height: 70vh; width: auto; height: auto;"></canvas>

                    <!-- Close Button overlay -->
                    <div id="mrCloseBtn" style="
                        position: absolute; 
                        top: 10px; 
                        right: 10px; 
                        width: 30px; 
                        height: 30px; 
                        background-color: #e53e3e; 
                        color: white; 
                        border-radius: 50%; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        cursor: pointer; 
                        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                        z-index: 20;
                        font-weight: bold;
                        user-select: none;
                    ">âœ•</div>
                </div>
                <!-- é®ç½©ç•«å¸ƒæœƒå‹•æ…‹å±¤ç–Šåœ¨ mrCanvasInner è£¡é¢ -->
            </div>

            <!-- Batch Processing Area (Hidden by default) -->
            <div id="mrBatchContainer"
                style="display: none; height: 500px; background: linear-gradient(135deg, #a78bfa 0%, #d8b4fe 100%); border-radius: 12px; position: relative; overflow: hidden; color: white;">
                <!-- Batch Stats Panel (Left) -->
                <div style="
                    position: absolute; left: 0; top: 0; bottom: 0; width: 250px; 
                    background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px); 
                    padding: 15px; display: flex; flex-direction: column; gap: 10px; 
                    overflow-y: auto; box-sizing: border-box; /* Fix width overflow */
                    scrollbar-width: none; /* Hide scrollbar Firefox */
                 ">
                    <!-- Hide Scrollbar Webkit -->
                    <style>
                        #mrBatchContainer div::-webkit-scrollbar {
                            display: none;
                        }
                    </style>

                    <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 5px;">è™•ç†è¨­å®š</div>

                    <div style="background: rgba(255, 255, 255, 0.3); padding: 10px; border-radius: 12px;">
                        <div style="font-weight: bold; margin-bottom: 2px; font-size: 0.9rem;">Gemini å°ˆç”¨æ¨¡å¼</div>
                        <div style="font-size: 0.75rem; opacity: 0.8; margin-bottom: 5px; line-height: 1.2;">é‡å° Gemini
                            ç”Ÿæˆåœ–ç‰‡çš„æµ®æ°´å°å°é€²è¡Œç„¡æç§»é™¤</div>
                        <label class="mr-switch" style="transform: scale(0.9); transform-origin: left;">
                            <input type="checkbox" checked disabled> <!-- Always on for batch -->
                            <span>å•Ÿç”¨ä¸­</span>
                        </label>
                    </div>

                    <label for="mrBatchInput" style="
                        display: block; width: 100%; padding: 10px; background: #6366f1; 
                        color: white; text-align: center; border-radius: 8px; cursor: pointer; 
                        font-weight: bold; transition: background 0.2s; font-size: 0.9rem;
                        box-sizing: border-box;
                    ">
                        ğŸ”¼ é¸æ“‡åœ–ç‰‡
                    </label>
                    <input type="file" id="mrBatchInput" multiple accept="image/*" style="display: none;">

                    <div style="flex: 1; font-size: 0.85rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>ç¸½è¨ˆåœ–ç‰‡ :</span>
                            <span id="mrBatchTotalCount">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>å·²è™•ç† :</span>
                            <span id="mrBatchProcessedCount">0</span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 5px; color: #4ade80; font-weight: bold;">
                            <span>å·²å®Œæˆ :</span>
                            <span id="mrBatchSuccessCount">0</span>
                        </div>
                    </div>

                    <button id="mrBatchStartBtn" disabled style="
                        width: 100%; padding: 10px; background: #8b5cf6; color: white; 
                        border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;
                        box-sizing: border-box;
                    ">âœ¨ é–‹å§‹æ‰¹æ¬¡è™•ç†</button>

                    <button id="mrBatchDownloadBtn" disabled style="
                        width: 100%; padding: 10px; background: rgba(255, 255, 255, 0.2); 
                        color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem;
                        box-sizing: border-box;
                    ">ğŸ“¥ ä¸‹è¼‰å…¨éƒ¨ (ZIP)</button>

                    <button id="mrBatchClearBtn" style="
                        width: 100%; padding: 8px; background: transparent; color: rgba(255,255,255,0.7); 
                        border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 0.85rem;
                        box-sizing: border-box;
                    ">ğŸ—‘ï¸ æ¸…ç©ºåˆ—è¡¨</button>
                </div>

                <style>
                    /* Force Batch Grid Styles */
                    .mr-batch-grid {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                        gap: 10px;
                        width: 100%;
                        padding: 10px;
                        overflow-y: auto;
                        box-sizing: border-box;
                    }

                    .mr-batch-item {
                        position: relative;
                        width: 100%;
                        aspect-ratio: 1;
                        background: rgba(0, 0, 0, 0.2);
                        border-radius: 8px;
                        overflow: hidden;
                    }

                    .mr-batch-item img {
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                        display: block;
                    }

                    .mr-batch-badge {
                        position: absolute;
                        top: 4px;
                        left: 4px;
                        font-size: 0.7rem;
                        padding: 2px 6px;
                        border-radius: 4px;
                        background: rgba(0, 0, 0, 0.6);
                        color: white;
                    }

                    .mr-batch-badge.success {
                        background: #48bb78;
                    }

                    .mr-batch-delete {
                        position: absolute;
                        top: 2px;
                        right: 2px;
                        width: 20px;
                        height: 20px;
                        background: rgba(0, 0, 0, 0.5);
                        color: white;
                        border-radius: 50%;
                        text-align: center;
                        line-height: 20px;
                        font-size: 12px;
                        cursor: pointer;
                    }

                    .mr-batch-delete:hover {
                        background: red;
                    }
                </style>

                <!-- Drop Zone (Right) -->
                <div id="mrBatchDropZone" style="
                    margin: 10px 10px 10px 260px; /* 250px sidebar + 10px gap */
                    height: calc(100% - 20px); 
                    display: flex; flex-direction: column; align-items: center; justify-content: center; 
                    border: 2px dashed rgba(255,255,255,0.3); border-radius: 8px;
                 ">
                    <div style="font-size: 3rem; opacity: 0.8; margin-bottom: 15px;">ğŸ“¤</div>
                    <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 8px;">æ‹–æ”¾åœ–ç‰‡åˆ°æ­¤è™•</div>
                    <div style="opacity: 0.8; font-size: 0.9rem;">æˆ–é»æ“Šå·¦å´ã€Œé¸æ“‡åœ–ç‰‡ã€æŒ‰éˆ•ä¸Šå‚³</div>
                    <div style="opacity: 0.6; font-size: 0.8rem; margin-top: 5px;">æ”¯æ´ PNGã€JPG æ ¼å¼ï¼Œå¯ä¸€æ¬¡ä¸Šå‚³å¤šå¼µ</div>
                </div>
            </div>

            <div id="mrProgressContainer" class="mr-progress-container">
                <div class="mr-label">è™•ç†é€²åº¦: <span id="mrProgressVal">0</span>%</div>
                <div class="mr-progress-bar">
                    <div id="mrProgressFill" class="mr-progress-fill"></div>
                </div>
            </div>

        </div>
    </div>

    <!-- åœ–ç‰‡è£åˆ‡åŠŸèƒ½å€å¡Š -->
    <div id="cropImageArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>åœ–ç‰‡è£åˆ‡</h3>
        <div id="cropCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="cropCanvas" style="border: 1px solid #000;"></canvas>
            <canvas id="cropSelectionCanvas" style="position: absolute; top: 0; left: 0; z-index: 10;"></canvas>
        </div>
        <div style="margin-top: 10px;">
            <button id="executeCropButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer;">åŸ·è¡Œè£åˆ‡</button>
            <button id="cancelCropButton"
                style="padding: 10px 15px; background-color: #dc3545; color: white; border: none; cursor: pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- ç¹ç°¡è½‰æ›åŠŸèƒ½å€å¡Š -->
    <div id="chineseConvArea">
        <div class="conv-header">
            <div class="conv-title">
                ç¹ç°¡è½‰æ› <span class="conv-subtitle">Zen Converter</span>
            </div>
            <button id="dictBtn" class="btn-outline">
                ğŸ“š è‡ªå®šç¾©è©åº« <span id="dictCountBadge"
                    style="background: #3182ce; color: white; border-radius: 10px; padding: 0 5px; font-size: 12px; display: none;">0</span>
            </button>
        </div>

        <div class="conv-main">
            <!-- è¼¸å…¥å€ -->
            <div class="conv-section">
                <div class="conv-section-header">
                    <span class="conv-label">ä¸­æ–‡è¼¸å…¥</span>
                    <span class="conv-tag">INPUT (Auto Detect)</span>
                </div>
                <div class="conv-tools">
                    <button class="icon-btn" id="convClearBtn" title="æ¸…é™¤">ğŸ—‘ï¸</button>
                    <button class="icon-btn" id="convCopyInputBtn" title="è¤‡è£½">ğŸ“‹</button>
                    <input type="file" id="convFileInput" accept=".txt,.srt" style="display:none">
                    <button class="icon-btn" id="convUploadBtn" title="ä¸Šå‚³æª”æ¡ˆ">ğŸ“‚</button>
                </div>
                <textarea id="convInput" class="conv-textarea" placeholder="åœ¨æ­¤è¼¸å…¥ä¸­æ–‡å…§å®¹ï¼ˆç¹é«”æˆ–ç°¡é«”çš†å¯ï¼‰..."></textarea>
            </div>

            <div class="conv-output-container">
                <!-- ç¹é«”è¼¸å‡º -->
                <div class="conv-output-box">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">ç¹é«”ä¸­æ–‡</span>
                            <span class="conv-tag">TRADITIONAL</span>
                        </div>
                        <div class="conv-tools">
                            <button class="icon-btn" id="convDownloadTradBtn" title="ä¸‹è¼‰ç¹é«”çµæœ">â¬‡ï¸</button>
                            <button class="icon-btn" id="convCopyTradBtn" title="è¤‡è£½ç¹é«”çµæœ">ğŸ“‹</button>
                        </div>
                        <div id="convOutputTrad" class="conv-output-area"></div>
                    </div>
                </div>

                <!-- ç°¡é«”è¼¸å‡º -->
                <div class="conv-output-box">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">ç°¡é«”ä¸­æ–‡</span>
                            <span class="conv-tag">SIMPLIFIED</span>
                        </div>
                        <div class="conv-tools">
                            <button class="icon-btn" id="convDownloadSimpBtn" title="ä¸‹è¼‰ç°¡é«”çµæœ">â¬‡ï¸</button>
                            <button class="icon-btn" id="convCopySimpBtn" title="è¤‡è£½ç°¡é«”çµæœ">ğŸ“‹</button>
                        </div>
                        <div id="convOutputSimp" class="conv-output-area"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- HTML Cleaner åŠŸèƒ½å€å¡Š -->
    <div id="htmlCleanerArea" style="display: none;">
        <div class="conv-header">
            <div class="conv-title">
                å»é™¤ç„¡ç”¨å­—å…ƒ <span class="conv-subtitle">HTML Cleaner</span>
            </div>
        </div>
        <div class="conv-main">
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <!-- å´é‚Šæ¬„è¨­å®š -->
                <div
                    style="width: 280px; flex-shrink: 0; background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <h3 style="margin-top: 0; font-size: 16px;">åŸºæœ¬è¨­å®š</h3>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerRemovePath" checked> ç§»é™¤ data-path-to-node
                        </label>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerRemoveIndex" checked> ç§»é™¤ data-index-in-node
                        </label>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerAutocorrectPunct" checked> è‡ªå‹•ä¿®æ­£æ¨™é»ç¬¦è™Ÿ (åŠè½‰å…¨)
                        </label>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerAutocorrectSpace" checked> ä¸­è‹±æ–‡é–“è·å„ªåŒ– (åŠ ç©ºæ ¼)
                        </label>
                    </div>

                    <h3 style="font-size: 16px;">è‡ªè¨‚ç§»é™¤å±¬æ€§</h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 10px;">è¼¸å…¥å±¬æ€§åç¨± (å¦‚ class æˆ– id=123)</p>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <input type="text" id="cleanerNewAttr" placeholder="å¦‚: class"
                            style="flex: 1; padding: 5px; border: 1px solid #cbd5e0; border-radius: 4px; font-size: 12px;">
                        <button id="cleanerAddAttrBtn" class="btn-primary"
                            style="padding: 5px 10px; font-size: 12px;">æ–°å¢</button>
                    </div>
                    <div id="cleanerAttrList" style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <!-- å±¬æ€§æ¨™ç±¤ -->
                    </div>

                    <h3 style="font-size: 16px; margin-top: 20px;">è‡ªè¨‚ç§»é™¤æ¨™ç±¤</h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 10px;">ä¿ç•™æ¨™ç±¤å…§çš„å…§å®¹ï¼Œåƒ…ç§»é™¤æ¨™ç±¤æœ¬èº«</p>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <input type="text" id="cleanerNewTag" placeholder="å¦‚: div"
                            style="flex: 1; padding: 5px; border: 1px solid #cbd5e0; border-radius: 4px; font-size: 12px;">
                        <button id="cleanerAddTagBtn" class="btn-primary"
                            style="padding: 5px 10px; font-size: 12px;">æ–°å¢</button>
                    </div>
                    <div id="cleanerTagList" style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <!-- æ¨™ç±¤æ¨™ç±¤ -->
                    </div>
                </div>

                <!-- ç·¨è¼¯å€ -->
                <div style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 20px;">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">HTML è¼¸å…¥</span>
                            <div class="conv-tools" style="opacity: 1">
                                <button class="icon-btn" id="cleanerClearBtn" title="æ¸…é™¤">ğŸ—‘ï¸</button>
                                <button class="icon-btn" id="cleanerUploadBtn" title="ä¸Šå‚³æª”æ¡ˆ">ğŸ“‚</button>
                                <input type="file" id="cleanerFileInput" accept=".html,.htm,.txt" style="display:none">
                            </div>
                        </div>
                        <textarea id="cleanerInput" class="conv-textarea" style="height: 250px;"
                            placeholder="åœ¨æ­¤è²¼ä¸Š HTML ä»£ç¢¼..."></textarea>
                    </div>

                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">æ¸…ç†çµæœ</span>
                            <div class="conv-tools" style="opacity: 1">
                                <button class="icon-btn" id="cleanerDownloadBtn" title="ä¸‹è¼‰çµæœ">â¬‡ï¸</button>
                                <button class="icon-btn" id="cleanerCopyBtn" title="è¤‡è£½çµæœ">ğŸ“‹</button>
                            </div>
                        </div>
                        <textarea id="cleanerOutput" class="conv-textarea" style="height: 250px;" readonly
                            placeholder="è™•ç†å¾Œçš„ä»£ç¢¼å°‡é¡¯ç¤ºæ–¼æ­¤..."></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Table to HTML å€å¡Š -->
    <div id="wordTableToHtmlArea">
        <div class="conv-header" style="margin-bottom: 20px;">
            <div class="conv-title" style="display: flex; gap: 10px; align-items: center;">
                <div style="background: rgba(37, 99, 235, 0.1); padding: 5px; border-radius: 8px;">
                    <!-- LayoutTemplate icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="w-6 h-6 text-primary">
                        <rect width="18" height="18" x="3" y="3" rx="2" />
                        <path d="M3 9h18" />
                        <path d="M9 21V9" />
                    </svg>
                </div>
                <div>
                    <div>Word è¡¨æ ¼è½‰ HTML</div>
                    <div style="font-size: 0.8rem; color: #718096; font-weight: normal;">å°ˆæ¥­è¡¨æ ¼è½‰æ›å·¥å…·</div>
                </div>
            </div>
            <div style="display: flex; gap: 5px;">
                <!-- Header actions if any -->
            </div>
        </div>

        <div class="wt-container">
            <!-- Left: Input -->
            <div class="wt-column">
                <div class="wt-card-header">
                    <div class="wt-card-title">
                        <div style="background: rgba(37, 99, 235, 0.1); padding: 5px; border-radius: 6px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                fill="none" stroke="#2563eb" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                                <polyline points="14 2 14 8 20 8" />
                                <line x1="16" x2="8" y1="13" y2="13" />
                                <line x1="16" x2="8" y1="17" y2="17" />
                                <line x1="10" x2="8" y1="9" y2="9" />
                            </svg>
                        </div>
                        è¼¸å…¥ä¾†æº
                    </div>
                    <button id="wtClearBtn" class="btn-outline" style="color: #718096; border-color: transparent;">
                        <!-- Eraser icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            style="margin-right: 5px;">
                            <path
                                d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21" />
                            <path d="M22 21H7" />
                            <path d="m5 11 9 9" />
                        </svg>
                        æ¸…ç©º
                    </button>
                </div>

                <div class="wt-card"
                    style="flex: 1; display: flex; flex-direction: column; overflow: hidden; border: 2px dashed #e2e8f0; transition: border-color 0.2s;">
                    <div
                        style="background: rgba(241, 245, 249, 0.5); padding: 8px 16px; border-bottom: 1px solid #e2e8f0; font-size: 12px; color: #64748b; display: flex; justify-content: space-between; align-items: center;">
                        <span>è«‹åœ¨æ­¤è™•è²¼ä¸Š Word è¡¨æ ¼ (Ctrl+V)</span>
                        <span
                            style="background: rgba(37, 99, 235, 0.1); color: #2563eb; padding: 2px 6px; border-radius: 4px; font-weight: 500; font-size: 10px;">è‡ªå‹•åµæ¸¬</span>
                    </div>
                    <div id="wtInput" class="wt-input-area" contenteditable="true"
                        data-placeholder="åœ¨æ­¤è™•è²¼ä¸Šæ‚¨çš„ Word è¡¨æ ¼..."></div>
                </div>

                <div
                    style="background: rgba(239, 246, 255, 0.5); border: 1px solid rgba(219, 234, 254, 0.5); padding: 15px; border-radius: 8px; margin-top: 15px; display: flex; gap: 12px; color: #1e40af;">
                    <div style="margin-top: 2px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12h14" />
                            <path d="m12 5 7 7-7 7" />
                        </svg>
                    </div>
                    <div>
                        <div style="font-weight: 500; font-size: 14px; margin-bottom: 5px;">ä½¿ç”¨èªªæ˜ï¼š</div>
                        <ul
                            style="list-style-type: disc; padding-left: 20px; margin: 0; font-size: 13px; opacity: 0.9; line-height: 1.6;">
                            <li>ç›´æ¥å¾ Word è¤‡è£½è¡¨æ ¼ä¸¦è²¼ä¸Šåˆ°ä¸Šæ–¹å€åŸŸ</li>
                            <li>ç³»çµ±æœƒè‡ªå‹•è½‰æ›ç‚º 100% å¯¬åº¦çš„ HTML è¡¨æ ¼</li>
                            <li>æ ¼å­å¯¬åº¦å°‡è‡ªå‹•è½‰æ›ç‚ºç™¾åˆ†æ¯”</li>
                            <li>æ ¼å­å…§æ–·è¡Œé–“è·æœƒè‡ªå‹•è¨­ç‚º 0</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Right: Output -->
            <div class="wt-column">
                <div class="wt-card-header">
                    <div class="wt-card-title">
                        <div style="background: rgba(22, 163, 74, 0.1); padding: 5px; border-radius: 6px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                fill="none" stroke="#16a34a" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <polyline points="16 18 22 12 16 6" />
                                <polyline points="8 6 2 12 8 18" />
                            </svg>
                        </div>
                        è½‰æ›çµæœ
                    </div>
                    <button id="wtCopyBtn" class="btn-primary" disabled
                        style="display: flex; align-items: center; gap: 5px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
                            <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
                        </svg>
                        è¤‡è£½ HTML
                    </button>
                </div>

                <div class="wt-card">
                    <div class="wt-tabs-header">
                        <div class="wt-tab-item active" data-tab="preview">é è¦½æ•ˆæœ</div>
                        <div class="wt-tab-item" data-tab="code">HTML ä»£ç¢¼</div>
                    </div>

                    <div class="wt-tab-content active" id="wtTabPreview">
                        <div id="wtPreview" style="padding: 24px; min-height: 100%;">
                            <div
                                style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 300px; color: #94a3b8; text-align: center;">
                                <div
                                    style="width: 64px; height: 64px; background: #f1f5f9; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 16px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" style="opacity: 0.5;">
                                        <rect width="18" height="18" x="3" y="3" rx="2" />
                                        <path d="M3 9h18" />
                                        <path d="M9 21V9" />
                                    </svg>
                                </div>
                                <p style="font-size: 16px; margin-bottom: 8px;">ç­‰å¾…è¼¸å…¥...</p>
                                <p style="font-size: 13px; opacity: 0.7;">è²¼ä¸Šè¡¨æ ¼å¾Œå°‡åœ¨æ­¤è™•é¡¯ç¤ºé è¦½</p>
                            </div>
                        </div>
                    </div>

                    <div class="wt-tab-content" id="wtTabCode">
                        <textarea id="wtCode" class="wt-code-textarea" readonly
                            placeholder="<!-- HTML ä»£ç¢¼å°‡é¡¯ç¤ºæ–¼æ­¤ -->"></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="dictDialog">
        <div class="dict-content">
            <div class="dict-header">
                <h3>ğŸ“š è‡ªå®šç¾©è½‰æ›è¦å‰‡</h3>
                <button id="closeDictBtn" class="icon-btn">âŒ</button>
            </div>

            <div class="dict-input-row">
                <div style="flex:1">
                    <label style="font-size:12px; color:#666;">SIMPLIFIED (ç°¡é«”)</label>
                    <input id="newSimple" class="dict-input" placeholder="ç°¡é«”è©å½™ (å¦‚: é¼ æ ‡)">
                </div>
                <div style="flex:1">
                    <label style="font-size:12px; color:#666;">TRADITIONAL (ç¹é«”)</label>
                    <input id="newTrad" class="dict-input" placeholder="ç¹é«”è©å½™ (å¦‚: æ»‘é¼ )">
                </div>
                <button id="addDictBtn" class="btn-primary" style="margin-top: 18px;">+</button>
            </div>

            <div style="border-top: 1px solid #eee; margin: 10px 0;"></div>

            <div id="dictList" class="dict-list">
                <!-- åˆ—è¡¨é …ç›®å°‡ç”± JS ç”Ÿæˆ -->
                <div style="text-align: center; color: #999; padding: 20px;">å°šç„¡è‡ªå®šç¾©è¦å‰‡</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.0/dist/browser-image-compression.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.min.js"></script>
    <script>
        // Define global constants for max crop dimensions
        const MAX_CROP_WIDTH = 1000; // é™åˆ¶è£åˆ‡é è¦½å¯¬åº¦ç‚º1000px
        const MAX_CROP_HEIGHT = 800; // Example value, adjust as needed
        const MAX_WIDTH = 1000; // Define MAX_WIDTH
        const MAX_HEIGHT = 1000; // Define MAX_HEIGHT
        const MAX_IMAGES = 20; // Define MAX_IMAGES

        // ============ å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾ç®—æ³• (ä¿®å¾©ç·šæ¢å•é¡Œ) ============

        // æ·»åŠ é»‘æ¡†å‡½æ•¸ (Global Scope)
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            borderedCanvas.width = canvas.width + 2; // å·¦å³å„1px
            borderedCanvas.height = canvas.height + 2; // ä¸Šä¸‹å„1px
            const ctx = borderedCanvas.getContext('2d');

            // å¡«æ»¿é»‘è‰²èƒŒæ™¯
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // ç¹ªè£½åŸå§‹åœ–ç‰‡åœ¨ä¸­é–“
            ctx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾å‡½æ•¸ - ä¸ä½¿ç”¨æœ‰å•é¡Œçš„éŠ³åŒ–æ¿¾é¡
         */
        function safeAdvancedImageScale(sourceCanvas, targetWidth, targetHeight, quality = 'balanced') {
            const sourceWidth = sourceCanvas.width;
            const sourceHeight = sourceCanvas.height;
            const scaleX = targetWidth / sourceWidth;
            const scaleY = targetHeight / sourceHeight;
            const minScale = Math.min(scaleX, scaleY);

            console.log(`ç¸®æ”¾å“è³ªé¸æ“‡: ${quality}, ç¸®æ”¾æ¯”ä¾‹: ${minScale.toFixed(3)}`);

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡ç¸®æ”¾ç­–ç•¥
            switch (quality) {
                case 'ultra':
                    // è¶…é«˜å“è³ªï¼šç¸½æ˜¯ä½¿ç”¨å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆç¸®å°æ™‚ï¼‰æˆ–é«˜å“è³ªç¸®æ”¾ï¼ˆæ”¾å¤§æ™‚ï¼‰
                    if (minScale < 1.0) {
                        return safeMultiStepScale(sourceCanvas, targetWidth, targetHeight);
                    } else {
                        return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);
                    }

                case 'high':
                    return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'balanced':
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'fast':
                    return simpleFastScale(sourceCanvas, targetWidth, targetHeight);

                default:
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);
            }
        }

        /**
         * å®‰å…¨çš„å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆä¸ä½¿ç”¨éŠ³åŒ–ï¼‰
         */
        function safeMultiStepScale(sourceCanvas, targetWidth, targetHeight) {
            let currentCanvas = sourceCanvas;
            const scaleX = targetWidth / sourceCanvas.width;
            const scaleY = targetHeight / sourceCanvas.height;
            const minScale = Math.min(scaleX, scaleY);

            // è¨ˆç®—æ­¥é©Ÿæ•¸ - æ¯æ­¥æœ€å¤šç¸®å°åˆ°50%
            const steps = Math.max(1, Math.ceil(Math.log(minScale) / Math.log(0.5)));

            console.log(`Ultraè³ªé‡æ¨¡å¼ï¼šåŸå§‹å°ºå¯¸ ${sourceCanvas.width}x${sourceCanvas.height} -> ç›®æ¨™ ${targetWidth}x${targetHeight}ï¼Œç¸®æ”¾æ¯”ä¾‹ ${minScale.toFixed(3)}ï¼Œä½¿ç”¨ ${steps} æ­¥ç¸®æ”¾`);

            for (let i = 0; i < steps; i++) {
                const isLastStep = (i === steps - 1);

                let stepTargetWidth, stepTargetHeight;
                if (isLastStep) {
                    stepTargetWidth = targetWidth;
                    stepTargetHeight = targetHeight;
                } else {
                    // æ¯æ­¥ç¸®å°åˆ°50%
                    stepTargetWidth = Math.max(targetWidth, Math.round(currentCanvas.width * 0.5));
                    stepTargetHeight = Math.max(targetHeight, Math.round(currentCanvas.height * 0.5));
                }

                const stepCanvas = document.createElement('canvas');
                stepCanvas.width = stepTargetWidth;
                stepCanvas.height = stepTargetHeight;
                const stepCtx = stepCanvas.getContext('2d');

                setupUltraQualityCanvas(stepCtx);
                stepCtx.drawImage(currentCanvas, 0, 0, stepTargetWidth, stepTargetHeight);

                console.log(`æ­¥é©Ÿ ${i + 1}/${steps}: ${currentCanvas.width}x${currentCanvas.height} -> ${stepTargetWidth}x${stepTargetHeight}`);
                currentCanvas = stepCanvas;
            }

            return currentCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜å“è³ªç¸®æ”¾
         */
        function safeHighQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`é«˜å“è³ªæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupHighQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * å¹³è¡¡å“è³ªç¸®æ”¾
         */
        function balancedQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¹³è¡¡æ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupBalancedQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * ç°¡å–®å¿«é€Ÿç¸®æ”¾
         */
        function simpleFastScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¿«é€Ÿæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupFastQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        // ============ å“è³ªé¸é …äº¤äº’é‚è¼¯ ============

        function updateQualityDescription() {
            const quality = document.getElementById('scalingQuality').value;
            const description = document.getElementById('qualityDescription');

            const descriptions = {
                ultra: '<span class="badge-ultra quality-badge">è¶…é«˜å“è³ª</span>å¤šæ­¥é©Ÿç¸®æ”¾ + æœ€é«˜JPEGå“è³ª(99%) - æª”æ¡ˆè¼ƒå¤§ä½†å“è³ªæœ€ä½³',
                high: '<span class="badge-high quality-badge">é«˜å“è³ª</span>é«˜å“è³ªç¸®æ”¾ + JPEGå“è³ª(95%) - å¹³è¡¡å“è³ªèˆ‡æª”æ¡ˆå¤§å°',
                balanced: '<span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>ä¸­ç­‰å“è³ªç¸®æ”¾ + JPEGå“è³ª(90%) - æ¨™æº–å“è³ªèˆ‡åˆç†æª”æ¡ˆå¤§å°',
                fast: '<span class="badge-fast quality-badge">å¿«é€Ÿæ¨¡å¼</span>å¿«é€Ÿç¸®æ”¾ + JPEGå“è³ª(80%) - è™•ç†é€Ÿåº¦å¿«ã€æª”æ¡ˆè¼ƒå°'
            };

            description.innerHTML = descriptions[quality];
        }

        // ============ åŸæœ‰åŠŸèƒ½ä»£ç¢¼ ============

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const resize320ModeBtn = document.getElementById('resize320Mode');
        const resize1080ModeBtn = document.getElementById('resize1080Mode');
        const addWatermarkModeBtn = document.getElementById('addWatermarkMode');
        const adaSpecialModeBtn = document.getElementById('adaSpecialMode');
        const screenshotArrangeModeBtn = document.getElementById('screenshotArrangeMode');
        const borderlessScreenshotArrangeModeBtn = document.getElementById('borderlessScreenshotArrangeMode');

        const cropImageModeBtn = document.getElementById('cropImageMode');
        const chineseConvModeBtn = document.getElementById('chineseConvMode');
        const magicRemoverModeBtn = document.getElementById('magicRemoverMode');
        const wordTableModeBtn = document.getElementById('wordTableMode');
        const logoInput = document.getElementById('logoInput');
        const logoStatus = document.getElementById('logoStatus');
        const logoPreview = document.getElementById('logoPreview');
        const pageTitle = document.getElementById('pageTitle');
        const selectLogoBtn = document.getElementById('selectLogoBtn');
        const selectAdaLogoBtn = document.getElementById('selectAdaLogoBtn');
        const screenshotArrangeDiv = document.getElementById('screenshotArrange');
        const borderlessScreenshotArrangeDiv = document.getElementById('borderlessScreenshotArrange');
        const cropImageArea = document.getElementById('cropImageArea');
        const chineseConvArea = document.getElementById('chineseConvArea');
        const magicRemoverArea = document.getElementById('magicRemoverArea');
        const wordTableToHtmlArea = document.getElementById('wordTableToHtmlArea');
        // const cropFileInput = document.getElementById('cropFileInput'); // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
        const cropCanvas = document.getElementById('cropCanvas');
        const cropCtx = cropCanvas.getContext('2d');
        const cropSelectionCanvas = document.getElementById('cropSelectionCanvas');
        const cropSelectionCtx = cropSelectionCanvas.getContext('2d');
        const executeCropButton = document.getElementById('executeCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // å“è³ªé¸é …å…ƒç´ 
        const scalingQuality = document.getElementById('scalingQuality');

        // é è¦½ç›¸é—œå…ƒç´ 
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const previewEditCanvas = document.getElementById('previewEditCanvas');
        const previewEditCtx = previewEditCanvas.getContext('2d');
        const previewDownloadButton = document.getElementById('previewDownloadButton');
        const processMoreButton = document.getElementById('processMoreButton');
        const clearPreviewButton = document.getElementById('clearPreviewButton');
        const downloadPNGButton = document.getElementById('downloadPNGButton');

        // é è¦½ç·¨è¼¯å·¥å…·
        const previewRectangleTool = document.getElementById('previewRectangleTool');
        const previewArrowTool = document.getElementById('previewArrowTool');
        const previewMosaicTool = document.getElementById('previewMosaicTool');
        const previewUndoButton = document.getElementById('previewUndoButton');
        const previewClearButton = document.getElementById('previewClearButton');

        // é è¦½ç·¨è¼¯ç‹€æ…‹è®Šé‡
        let previewIsDrawing = false;
        let previewStartX, previewStartY;
        let previewCurrentTool = null;
        let previewEditHistory = [];
        let previewBaseEditState = null;

        let currentMode = 'resize320';
        let logoImage = null;
        let logoFileName = '';
        let adaSpecialLogo = null;
        let adaSpecialLogoFileName = '';

        // è£åˆ‡åŠŸèƒ½ç›¸é—œè®Šæ•¸
        let originalCropImage = null;
        let cropStartX, cropStartY, cropEndX, cropEndY;
        let isCropping = false;
        let cropSelection = { x: 0, y: 0, width: 0, height: 0 };

        // å¾ localStorage è®€å–ä¸Šæ¬¡ä½¿ç”¨çš„ Logo
        const lastUsedLogo = localStorage.getItem('lastUsedLogo');
        const lastUsedLogoName = localStorage.getItem('lastUsedLogoName');
        const lastUsedAdaLogo = localStorage.getItem('lastUsedAdaLogo');
        const lastUsedAdaLogoName = localStorage.getItem('lastUsedAdaLogoName');

        if (lastUsedLogo && lastUsedLogoName) {
            logoImage = new Image();
            if (lastUsedLogo.startsWith('http')) logoImage.crossOrigin = "anonymous";
            logoImage.src = lastUsedLogo;
            logoFileName = lastUsedLogoName;
            updateLogoPreview(lastUsedLogo, lastUsedLogoName, 'ä¸€èˆ¬');
        }

        if (lastUsedAdaLogo && lastUsedAdaLogoName) {
            adaSpecialLogo = new Image();
            if (lastUsedAdaLogo.startsWith('http')) adaSpecialLogo.crossOrigin = "anonymous";
            adaSpecialLogo.src = lastUsedAdaLogo;
            adaSpecialLogoFileName = lastUsedAdaLogoName;
        }

        // å“è³ªé¸é …äº‹ä»¶ç›£è½å™¨
        scalingQuality.addEventListener('change', updateQualityDescription);

        dropZone.addEventListener('click', () => {
            console.log('dropZone clicked');
            fileInput.click();
        });
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', handleFiles);
        fileInput.addEventListener('change', handleFiles);
        resize320ModeBtn.addEventListener('click', () => setMode('resize320'));
        resize1080ModeBtn.addEventListener('click', () => setMode('resize1080'));
        addWatermarkModeBtn.addEventListener('click', () => setMode('addWatermark'));
        adaSpecialModeBtn.addEventListener('click', () => setMode('adaSpecial'));
        screenshotArrangeModeBtn.addEventListener('click', () => setMode('screenshotArrange'));
        cropImageModeBtn.addEventListener('click', () => setMode('cropImage')); // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼æŒ‰éˆ•äº‹ä»¶
        chineseConvModeBtn.addEventListener('click', () => setMode('chineseConv'));
        magicRemoverModeBtn.addEventListener('click', () => setMode('magicRemover'));
        const htmlCleanerModeBtn = document.getElementById('htmlCleanerMode');
        const htmlCleanerArea = document.getElementById('htmlCleanerArea');
        htmlCleanerModeBtn.addEventListener('click', () => setMode('htmlCleaner'));
        wordTableModeBtn.addEventListener('click', () => setMode('wordTable'));
        selectLogoBtn.addEventListener('click', () => logoInput.click());
        selectAdaLogoBtn.addEventListener('click', () => logoInput.click());

        // é è¦½åŠŸèƒ½äº‹ä»¶ç›£è½å™¨
        previewDownloadButton.addEventListener('click', downloadPreviewImage);
        processMoreButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
            fileInput.value = '';
        });
        clearPreviewButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
        });

        downloadPNGButton.addEventListener('click', downloadPreviewImageAsPNG);

        // é è¦½ç·¨è¼¯å·¥å…·äº‹ä»¶ç›£è½å™¨
        previewRectangleTool.addEventListener('click', () => {
            previewCurrentTool = 'rectangle';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewArrowTool.addEventListener('click', () => {
            previewCurrentTool = 'arrow';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewMosaicTool.addEventListener('click', () => {
            previewCurrentTool = 'mosaic';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewUndoButton.addEventListener('click', previewUndo);
        previewClearButton.addEventListener('click', previewClearEdits);

        // é è¦½ç·¨è¼¯canvasäº‹ä»¶ç›£è½å™¨
        previewEditCanvas.addEventListener('mousedown', previewStartDrawing);
        previewEditCanvas.addEventListener('mousemove', previewDraw);
        previewEditCanvas.addEventListener('mouseup', previewStopDrawing);
        previewEditCanvas.addEventListener('mouseout', previewStopDrawing);

        // è£åˆ‡åŠŸèƒ½äº‹ä»¶ç›£è½å™¨

        cropSelectionCanvas.addEventListener('mousedown', startCropDrawing);
        cropSelectionCanvas.addEventListener('mousemove', drawCropSelection);
        cropSelectionCanvas.addEventListener('mouseup', stopCropDrawing);
        cropSelectionCanvas.addEventListener('mouseout', stopCropDrawing);
        executeCropButton.addEventListener('click', executeCrop);
        cancelCropButton.addEventListener('click', cancelCrop);

        // ğŸ”¥ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const borderlessFileInput2 = document.getElementById('borderlessFileInput2');
        const borderlessFileCount = document.getElementById('borderlessFileCount');
        const borderlessProcessButton = document.getElementById('borderlessProcessButton');
        const borderlessDownloadButton = document.getElementById('borderlessDownloadButton');
        const borderlessCanvas = document.getElementById('borderlessCanvas');
        const borderlessCtx = borderlessCanvas.getContext('2d');
        const borderlessImageList = document.getElementById('borderlessImageList');
        const borderlessEditCanvas = document.getElementById('borderlessEditCanvas');
        const borderlessEditCtx = borderlessEditCanvas.getContext('2d');
        const borderlessRectangleTool = document.getElementById('borderlessRectangleTool');
        const borderlessArrowTool = document.getElementById('borderlessArrowTool');
        const borderlessWatermarkTool = document.getElementById('borderlessWatermarkTool');
        const borderlessMosaicTool = document.getElementById('borderlessMosaicTool');
        const borderlessUndoButton = document.getElementById('borderlessUndoButton');
        const borderlessClearButton = document.getElementById('borderlessClearButton');
        const borderlessClearAllButton = document.getElementById('borderlessClearAllButton');

        let borderlessUploadedImages = [];
        let borderlessIsDrawing = false;
        let borderlessStartX, borderlessStartY;
        let borderlessCurrentTool = null;
        let borderlessEditHistory = [];
        let borderlessBaseEditState = null;

        borderlessScreenshotArrangeModeBtn.addEventListener('click', () => setMode('borderlessScreenshotArrange'));
        borderlessFileInput2.addEventListener('change', borderlessHandleFileSelect);
        borderlessProcessButton.addEventListener('click', borderlessProcessImages);
        borderlessDownloadButton.addEventListener('click', borderlessDownloadProcessedImage);
        borderlessClearAllButton.addEventListener('click', borderlessClearAllImages);

        logoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    if (currentMode === 'adaSpecial') {
                        adaSpecialLogo = new Image();
                        // Only set crossOrigin for remote URLs to avoid file:// tainting
                        if (dataUrl.startsWith('http') && !dataUrl.startsWith('data:')) adaSpecialLogo.crossOrigin = "anonymous";
                        adaSpecialLogo.src = dataUrl;
                        adaSpecialLogoFileName = file.name;
                        localStorage.setItem('lastUsedAdaLogo', dataUrl);
                        localStorage.setItem('lastUsedAdaLogoName', file.name);
                        updateLogoPreview(dataUrl, file.name, 'é˜¿é”å°ˆç”¨');
                    } else if (currentMode === 'addWatermark') {
                        logoImage = new Image();
                        if (dataUrl.startsWith('http') && !dataUrl.startsWith('data:')) logoImage.crossOrigin = "anonymous";
                        logoImage.src = dataUrl;
                        logoFileName = file.name;
                        localStorage.setItem('lastUsedLogo', dataUrl);
                        localStorage.setItem('lastUsedLogoName', file.name);
                        updateLogoPreview(dataUrl, file.name, 'ä¸€èˆ¬');
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        function updateLogoPreview(src, name, type) {
            logoPreview.src = src;
            logoPreview.style.display = 'block';
            logoStatus.textContent = `å·²è¼‰å…¥${type} Logo: ${name}`;
        }

        function setMode(mode) {
            // å¦‚æœä½¿ç”¨è€…å†æ¬¡é»æ“Šç•¶å‰æ¨¡å¼çš„æŒ‰éˆ•ï¼Œå‰‡é‡ç½®è©²æ¨¡å¼çš„ä»‹é¢
            if (mode === currentMode) {
                if (mode === 'screenshotArrange') {
                    clearAllImages();
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    downloadButton.style.display = 'none';
                    document.getElementById('editTools').style.display = 'none';
                    updateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (mode === 'borderlessScreenshotArrange') {
                    borderlessClearAllImages();
                    borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
                    borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    borderlessDownloadButton.style.display = 'none';
                    document.getElementById('borderlessEditTools').style.display = 'none';
                    borderlessUpdateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (['resize320', 'resize1080', 'addWatermark', 'adaSpecial'].includes(mode)) {
                    previewArea.style.display = 'none';
                    status.innerHTML = '';
                    fileInput.value = '';
                    dropZone.style.display = 'flex';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
                if (mode === 'cropImage') {
                    cancelCrop();
                    cropImageArea.style.display = 'none';
                    dropZone.style.display = 'flex';
                    status.innerHTML = '';
                    fileInput.value = '';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
            }

            currentMode = mode;
            [resize320ModeBtn, resize1080ModeBtn, addWatermarkModeBtn, adaSpecialModeBtn, screenshotArrangeModeBtn, cropImageModeBtn, borderlessScreenshotArrangeModeBtn, chineseConvModeBtn, htmlCleanerModeBtn, magicRemoverModeBtn, wordTableModeBtn].forEach(btn => btn.classList.remove('active'));

            selectLogoBtn.style.display = 'none';
            selectAdaLogoBtn.style.display = 'none';
            logoPreview.style.display = 'none';
            logoStatus.textContent = '';
            screenshotArrangeDiv.style.display = 'none';
            borderlessScreenshotArrangeDiv.style.display = 'none';
            cropImageArea.style.display = 'none';
            chineseConvArea.style.display = 'none';
            htmlCleanerArea.style.display = 'none';
            magicRemoverArea.style.display = 'none';
            wordTableToHtmlArea.style.display = 'none';

            // æ¸…é™¤ä¹‹å‰çš„è™•ç†æª”æ¡ˆè³‡è¨Š
            status.innerHTML = '';

            // ç„¡è«–ä¹‹å‰çš„ç‹€æ…‹å¦‚ä½•ï¼Œåˆ‡æ›æ¨¡å¼æ™‚ä¸€å¾‹é‡ç½®ç‚ºåˆå§‹ç‹€æ…‹
            dropZone.style.display = 'flex';
            fileInput.style.display = 'none';
            previewArea.style.display = 'none';

            // æ¸…é™¤é è¦½ Canvas
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewCanvas.width = 0;
            previewCanvas.height = 0;
            previewEditCanvas.width = 0;
            previewEditCanvas.height = 0;

            if (mode === 'resize320') {
                resize320ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰';
            } else if (mode === 'resize1080') {
                resize1080ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰';
            } else if (mode === 'addWatermark') {
                addWatermarkModeBtn.classList.add('active');
                pageTitle.textContent = 'æ·»åŠ æµ®æ°´å°';
                selectLogoBtn.style.display = 'inline-block';
                if (logoImage) {
                    updateLogoPreview(logoImage.src, logoFileName, 'ä¸€èˆ¬');
                }
            } else if (mode === 'adaSpecial') {
                adaSpecialModeBtn.classList.add('active');
                pageTitle.textContent = 'é›»è…¦ç‹é˜¿é”å°ˆç”¨';
                selectAdaLogoBtn.style.display = 'inline-block';
                if (adaSpecialLogo) {
                    updateLogoPreview(adaSpecialLogo.src, adaSpecialLogoFileName, 'é˜¿é”å°ˆç”¨');
                }
            } else if (mode === 'screenshotArrange') {
                screenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'æˆªåœ–ä¸¦æ’';
                screenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'borderlessScreenshotArrange') {
                borderlessScreenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’';
                borderlessScreenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
                borderlessUpdateFileInputAndCount(); // ğŸ”§ Initialize file count display
            } else if (mode === 'cropImage') {
                cropImageModeBtn.classList.add('active');
                pageTitle.textContent = 'åœ–ç‰‡è£åˆ‡';
                cropImageArea.style.display = 'block';
                dropZone.style.display = 'flex';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'chineseConv') {
                chineseConvModeBtn.classList.add('active');
                pageTitle.textContent = 'ç¹ç°¡è½‰æ›';
                chineseConvArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'htmlCleaner') {
                htmlCleanerModeBtn.classList.add('active');
                pageTitle.textContent = 'å»é™¤ç„¡ç”¨å­—å…ƒ';
                htmlCleanerArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'magicRemover') {
                magicRemoverModeBtn.classList.add('active');
                pageTitle.textContent = 'å»æµ®æ°´å° (Gemini v2)';
                magicRemoverArea.style.display = 'block';
                dropZone.style.display = 'none'; // Hide global drop zone for this mode
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
                if (typeof mrRefreshCanvas === 'function') mrRefreshCanvas();
            } else if (mode === 'wordTable') {
                wordTableModeBtn.classList.add('active');
                pageTitle.textContent = 'Word è¡¨æ ¼è½‰ HTML';
                wordTableToHtmlArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
                setTimeout(() => document.getElementById('wtInput').focus(), 100);
            }

            // æ¸…é™¤æª”æ¡ˆè¼¸å…¥
            fileInput.value = '';
        }

        // Add event listener for One-Click button
        document.getElementById('mrOneClickBtn').addEventListener('click', mrOneClickProcess);

        // One-Click Process Function
        // One-Click Process Function
        async function mrOneClickProcess() {
            if (currentMode !== 'magicRemover' || mrIsProcessing) return;

            // Check if image is loaded
            if (!mrOriginalImage) {
                alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡ï¼');
                return;
            }

            // Check if ADA Logo is loaded
            if (!adaSpecialLogo) {
                alert('è«‹å…ˆåœ¨ã€Œé›»è…¦ç‹é˜¿é”å°ˆç”¨ã€æ¨¡å¼ä¸­è¨­å®š Logoï¼');
                return;
            }

            const btn = document.getElementById('mrOneClickBtn');
            const originalText = btn.innerHTML;

            try {
                // Set Processing State
                mrIsProcessing = true;
                btn.innerHTML = 'â³ è™•ç†ä¸­...';
                mrUpdateButtons(); // Disable all buttons

                // Initialize Engine if needed
                if (!mrEngine) {
                    try {
                        mrEngine = await GeminiWatermarkEngine.create();
                    } catch (e) {
                        throw new Error("å¼•æ“åˆå§‹åŒ–å¤±æ•—: " + e.message);
                    }
                }

                // 1. Prepare Image (Upscale if needed for better watermark removal)
                console.log('--- One-Click: Step 1: Upscale & Remove Watermark ---');
                const { canvas: upscaledCanvas } = await mrConditionalUpscale(mrOriginalImage);

                // 2. Remove Watermark
                await mrEngine.removeWatermark(upscaledCanvas);

                // 3. Resize to 1000px (Longest side)
                console.log('--- One-Click: Step 2: Resize to 1000px ---');
                let targetW = upscaledCanvas.width;
                let targetH = upscaledCanvas.height;
                const longSide = Math.max(targetW, targetH);

                if (longSide > 1000) {
                    if (targetW > targetH) {
                        targetW = 1000;
                        targetH = (upscaledCanvas.height / upscaledCanvas.width) * 1000;
                    } else {
                        targetH = 1000;
                        targetW = (upscaledCanvas.width / upscaledCanvas.height) * 1000;
                    }
                }

                // Use high quality scaling
                const resizedCanvas = safeAdvancedImageScale(upscaledCanvas, targetW, targetH, 'high');

                // 4. Add Black Border
                console.log('--- One-Click: Step 3: Add Border ---');
                const borderedCanvas = addBlackBorder(resizedCanvas);

                // 5. Add Ada Watermark
                console.log('--- One-Click: Step 4: Add Ada Logo ---');
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = borderedCanvas.width;
                finalCanvas.height = borderedCanvas.height;
                const ctx = finalCanvas.getContext('2d');
                setupHighQualityCanvas(ctx);
                ctx.drawImage(borderedCanvas, 0, 0);

                const logoWidth = adaSpecialLogo.width * 0.7;
                const logoHeight = adaSpecialLogo.height * 0.7;
                const logoX = finalCanvas.width - logoWidth - 15;
                const logoY = finalCanvas.height - logoHeight - 15;

                ctx.globalAlpha = 0.5;
                ctx.drawImage(adaSpecialLogo, logoX, logoY, logoWidth, logoHeight);

                // 6. Download & Preview
                console.log('--- One-Click: Step 5: Download & Preview ---');

                // Update Preview with the final result
                const previewImg = new Image();
                previewImg.onload = () => {
                    mrOriginalImage = previewImg;
                    mrHistory = []; // Reset history
                    mrHistoryIndex = -1;
                    if (mrMaskCanvas) {
                        const mCtx = mrMaskCanvas.getContext('2d');
                        mCtx.clearRect(0, 0, mrMaskCanvas.width, mrMaskCanvas.height);
                    }
                    mrRefreshCanvas(); // Update UI
                };
                previewImg.src = finalCanvas.toDataURL('image/jpeg', 0.85);

                finalCanvas.toBlob((blob) => {
                    if (blob) {
                        const timestamp = new Date().getTime();
                        const filename = `processed_${timestamp}.jpg`;
                        const file = new File([blob], filename, { type: "image/jpeg" });
                        saveAs(file);
                    } else {
                        throw new Error('Canvas conversions failed');
                    }
                }, 'image/jpeg', 0.85);

            } catch (err) {
                console.error('One-Click Process Error:', err);
                alert('è™•ç†ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
            } finally {
                // Restore State
                mrIsProcessing = false;
                btn.innerHTML = originalText;
                mrUpdateButtons(); // Re-enable buttons
            }
        }
        function handleFiles(e) {
            console.log('handleFiles triggered');
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
            processFiles(files);
        }

        async function processFiles(files) {
            console.log('processFiles triggered', files);
            status.innerHTML = 'é–‹å§‹è™•ç†æª”æ¡ˆ...';

            // åªè™•ç†ç¬¬ä¸€å¼µåœ–ç‰‡é€²è¡Œé è¦½
            const file = files[0];
            if (file && file.type.startsWith('image/')) {
                try {
                    let result = null;
                    if (currentMode === 'resize320') {
                        result = await processImageForPreview(file, 'resize320');
                    } else if (currentMode === 'resize1080') {
                        result = await processImageForPreview(file, 'resize1080');
                    } else if (currentMode === 'addWatermark') {
                        if (logoImage) {
                            result = await processImageForPreview(file, 'addWatermark');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'adaSpecial') {
                        if (adaSpecialLogo) {
                            result = await processImageForPreview(file, 'adaSpecial');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡é˜¿é”å°ˆç”¨ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'cropImage') { // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼è™•ç†
                        handleCropFileSelect({ target: { files: [file] } }); // æ¨¡æ“¬äº‹ä»¶å°è±¡
                        status.innerHTML += '<br>åœ–ç‰‡å·²è¼‰å…¥è£åˆ‡å€ï¼Œè«‹ç¹ªè£½è£åˆ‡ç¯„åœã€‚';
                        return; // è£åˆ‡æ¨¡å¼ä¸‹ä¸é€²å…¥é è¦½å€ï¼Œç›´æ¥é¡¯ç¤ºè£åˆ‡ä»‹é¢
                    } else if (currentMode === 'magicRemover') {
                        if (typeof mrLoadImage === 'function') {
                            mrLoadImage(file);
                            status.innerHTML += '<br>åœ–ç‰‡å·²è¼‰å…¥å»æµ®æ°´å°å€ï¼Œè«‹é–‹å§‹è™•ç†ã€‚';
                        }
                        return;
                    }

                    if (result && result.canvas) {
                        const filename = file.name.replace(/\.[^/.]+$/, ".jpg");
                        showPreview(result.canvas, filename);
                        status.innerHTML += '<br>è™•ç†å®Œæˆï¼è«‹æŸ¥çœ‹é è¦½çµæœã€‚';
                    }
                } catch (error) {
                    console.error('è™•ç†éŒ¯èª¤:', error);
                    status.innerHTML += '<br>è™•ç†å¤±æ•—: ' + error.message;
                }
            }
        }

        async function resizeImage(file, targetSize, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let newWidth, newHeight;

                        const longSide = Math.max(img.width, img.height);

                        if (longSide <= targetSize) {
                            newWidth = img.width;
                            newHeight = img.height;
                        } else if (img.width > img.height) {
                            newWidth = targetSize;
                            newHeight = (img.height / img.width) * targetSize;
                        } else {
                            newHeight = targetSize;
                            newWidth = (img.width / img.height) * targetSize;
                        }

                        // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾æŠ€è¡“
                        const sourceCanvas = document.createElement('canvas');
                        sourceCanvas.width = img.width;
                        sourceCanvas.height = img.height;
                        const sourceCtx = sourceCanvas.getContext('2d');
                        setupHighQualityCanvas(sourceCtx);
                        sourceCtx.drawImage(img, 0, 0);

                        const quality = scalingQuality.value;
                        const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                        canvas.width = scaledCanvas.width;
                        canvas.height = scaledCanvas.height;
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(scaledCanvas, 0, 0);

                        // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
                        let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
                        switch (quality) {
                            case 'ultra':
                                jpegQuality = 0.99; // æœ€é«˜å“è³ª
                                break;
                            case 'high':
                                jpegQuality = 0.95; // é«˜å“è³ª
                                break;
                            case 'balanced':
                                jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                                break;
                            case 'fast':
                                jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                                break;
                        }

                        console.log(`ä½¿ç”¨JPEGå“è³ª: ${jpegQuality}`);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const resizedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                console.log(`è¼¸å‡ºæª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                                if (returnBlob) {
                                    resolve(resizedFile);
                                } else {
                                    saveAs(resizedFile);
                                    status.innerHTML += ` - èª¿æ•´å¤§å°æˆåŠŸï¼(å“è³ª: ${quality}, æª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB)`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºèª¿æ•´å¤§å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', jpegQuality);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function addWatermark(file, logo, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        canvas.width = img.width;
                        canvas.height = img.height;

                        // è¨­ç½®é«˜å“è³ªç¸®æ”¾
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(img, 0, 0, img.width, img.height);

                        // Logo å°ºå¯¸ç¸®å°30%
                        const logoWidth = logo.width * 0.7;
                        const logoHeight = logo.height * 0.7;

                        // è¨ˆç®— Logo ä½ç½®ï¼ˆå³ä¸‹è§’ï¼Œè·é›¢é‚Šç·£ 15 åƒç´ ï¼‰
                        const logoX = img.width - logoWidth - 15;
                        const logoY = img.height - logoHeight - 15;

                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(logo, logoX, logoY, logoWidth, logoHeight);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const watermarkedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                if (returnBlob) {
                                    resolve(watermarkedFile);
                                } else {
                                    saveAs(watermarkedFile);
                                    status.innerHTML += ` - æ·»åŠ æµ®æ°´å°æˆåŠŸï¼`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºæ·»åŠ æµ®æ°´å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', 0.98);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function adaSpecialProcess(file) {
            try {
                console.log('é–‹å§‹é˜¿é”å°ˆç”¨è™•ç†');
                status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;

                console.log('æ­¥é©Ÿ 1: èª¿æ•´åœ–ç‰‡å¤§å°');
                status.innerHTML += `<br>- èª¿æ•´åœ–ç‰‡å¤§å°ä¸­...`;
                let processedImage = await resizeImage(file, 1000, true);

                console.log('æ­¥é©Ÿ 2: æ·»åŠ æµ®æ°´å°');
                status.innerHTML += `<br>- æ·»åŠ æµ®æ°´å°ä¸­...`;
                if (!adaSpecialLogo) {
                    throw new Error('é˜¿é”å°ˆç”¨ Logo æœªè¨­ç½®');
                }
                processedImage = await addWatermark(processedImage, adaSpecialLogo, true);

                console.log('å„²å­˜æœ€çµ‚åœ–ç‰‡');
                saveAs(processedImage);
                status.innerHTML += `<br>é›»è…¦ç‹é˜¿é”å°ˆç”¨è™•ç†å®Œæˆï¼`;
            } catch (error) {
                console.error('é˜¿é”å°ˆç”¨è™•ç†éŒ¯èª¤:', error);
                status.innerHTML += `<br>è™•ç†å¤±æ•—: ${error.message}`;
            }
        }

        // é«˜å“è³ªCanvasè¨­ç½®å‡½æ•¸
        function setupHighQualityCanvas(ctx) {
            // è¨­ç½®é«˜å“è³ªåœ–åƒç¸®æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            // é‡å°æ–‡å­—å„ªåŒ–çš„è¨­ç½®
            ctx.textRenderingOptimization = 'optimizeQuality';
        }

        // ============ ä¸åŒå“è³ªçš„Canvasè¨­ç½® ============

        function setupUltraQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            // è¶…é«˜å“è³ªè¨­ç½®
            ctx.globalCompositeOperation = 'source-over';
        }

        function setupBalancedQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        function setupFastQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'low';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        // æ·»åŠ é»‘æ¡†å‡½æ•¸
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            const borderedCtx = borderedCanvas.getContext('2d');

            // æ–°canvaså°ºå¯¸ç‚ºåŸå°ºå¯¸+2pxï¼ˆä¸Šä¸‹å„1pxï¼Œå·¦å³å„1pxï¼‰
            borderedCanvas.width = canvas.width + 2;
            borderedCanvas.height = canvas.height + 2;

            // å¡«å……é»‘è‰²èƒŒæ™¯
            borderedCtx.fillStyle = 'black';
            borderedCtx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // åœ¨ä¸­å¤®ç¹ªè£½åŸå§‹åœ–ç‰‡
            borderedCtx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        // è™•ç†åœ–ç‰‡ä¸¦è¿”å›canvasï¼ˆé è¦½æ¨¡å¼ï¼‰
        async function processImageForPreview(file, mode) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
                        const quality = scalingQuality.value;
                        console.log(`ğŸ¯ è™•ç†æ¨¡å¼: ${mode}, å“è³ªè¨­å®š: ${quality}`);

                        if (mode === 'resize320') {
                            // çŸ­é‚Šç¸®æ”¾åˆ°320px
                            const shortSide = Math.min(img.width, img.height);
                            let newWidth, newHeight;

                            if (shortSide <= 320) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width < img.height) {
                                // ç›´ç‰ˆåœ–ç‰‡ï¼Œå¯¬åº¦æ˜¯çŸ­é‚Š
                                newWidth = 320;
                                newHeight = (img.height / img.width) * 320;
                            } else {
                                // æ©«ç‰ˆåœ–ç‰‡ï¼Œé«˜åº¦æ˜¯çŸ­é‚Š
                                newHeight = 320;
                                newWidth = (img.width / img.height) * 320;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'resize1080') {
                            // é•·é‚Šç¸®æ”¾åˆ°1000px
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'addWatermark') {
                            // æ·»åŠ æµ®æ°´å° - ğŸ”¥ ä½¿ç”¨å“è³ªè¨­å®š
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');

                            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
                            switch (quality) {
                                case 'ultra':
                                    setupUltraQualityCanvas(ctx);
                                    break;
                                case 'high':
                                    setupHighQualityCanvas(ctx);
                                    break;
                                case 'balanced':
                                    setupBalancedQualityCanvas(ctx);
                                    break;
                                case 'fast':
                                    setupFastQualityCanvas(ctx);
                                    break;
                                default:
                                    setupBalancedQualityCanvas(ctx);
                            }

                            ctx.drawImage(img, 0, 0);

                            // æ·»åŠ æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = logoImage.width * 0.7;
                            const logoHeight = logoImage.height * 0.7;
                            const logoX = img.width - logoWidth - 15;
                            const logoY = img.height - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);

                            resolve({ canvas: canvas });

                        } else if (mode === 'adaSpecial') {
                            // é˜¿é”å°ˆç”¨ï¼šç¸®æ”¾ + æµ®æ°´å° + é»‘æ¡†
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                            const canvas = document.createElement('canvas');
                            canvas.width = scaledCanvas.width;
                            canvas.height = scaledCanvas.height;
                            const ctx = canvas.getContext('2d');
                            setupHighQualityCanvas(ctx);
                            ctx.drawImage(scaledCanvas, 0, 0);

                            // æ·»åŠ é˜¿é”å°ˆç”¨æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = adaSpecialLogo.width * 0.7;
                            const logoHeight = adaSpecialLogo.height * 0.7;
                            const logoX = newWidth - logoWidth - 15;
                            const logoY = newHeight - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(adaSpecialLogo, logoX, logoY, logoWidth, logoHeight);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(canvas);
                            resolve({ canvas: borderedCanvas });
                        }

                    } catch (error) {
                        reject(error);
                    }
                };
                img.onerror = () => reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    // Data URLs from same session are usually considered safe.
                    // No crossOrigin needed for locally read files.
                    img.src = dataUrl;
                };
                reader.readAsDataURL(file);
            });
        }

        // é¡¯ç¤ºé è¦½çµæœ
        function showPreview(canvas, filename) {
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCtx.drawImage(canvas, 0, 0);

            // è¨­ç½®ç·¨è¼¯canvas
            previewEditCanvas.width = canvas.width;
            previewEditCanvas.height = canvas.height;
            previewEditCanvas.style.display = 'block';

            // å„²å­˜ä¸‹è¼‰ä¿¡æ¯
            previewCanvas.downloadFilename = filename;

            // åˆå§‹åŒ–ç·¨è¼¯æ­·å²
            previewClearEdits();
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];

            // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•å’Œé è¦½å€åŸŸ
            previewDownloadButton.style.display = 'block';
            downloadPNGButton.style.display = 'inline-block';
            previewArea.style.display = 'block';
            dropZone.style.display = 'none';
        }

        // é è¦½ç·¨è¼¯å·¥å…·å‡½æ•¸
        function previewStartDrawing(e) {
            if (!previewCurrentTool) return;
            previewIsDrawing = true;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            previewStartX = (e.clientX - rect.left) * scaleX;
            previewStartY = (e.clientY - rect.top) * scaleY;

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewStopDrawing() {
            if (!previewIsDrawing) return;
            previewIsDrawing = false;
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));
        }

        function previewDraw(e) {
            if (!previewIsDrawing || !previewCurrentTool) return;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            if (previewEditHistory.length > 0) {
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
            }

            previewEditCtx.beginPath();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.lineWidth = 3;

            if (previewCurrentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX + 3, previewStartY + 3, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'red';
                previewEditCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX, previewStartY, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();
            } else if (previewCurrentTool === 'arrow') {
                previewDrawArrow(previewStartX, previewStartY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (previewCurrentTool === 'mosaic') {
                // ğŸ”¥ ä¿®æ­£ï¼šé¦¬è³½å…‹å·¥å…·éœ€è¦æ•´æ•¸åº§æ¨™
                const x = Math.round(Math.min(previewStartX, endX));
                const y = Math.round(Math.min(previewStartY, endY));
                const width = Math.round(Math.abs(endX - previewStartX));
                const height = Math.round(Math.abs(endY - previewStartY));

                if (width > 0 && height > 0) {
                    previewDrawMosaic(x, y, width, height);
                }
            }

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX + 2, fromY + 2);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX + 2, toY + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.fillStyle = 'red';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';
            previewEditCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX, fromY);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX, toY);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();
        }

        function previewDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = previewCtx.getImageData(x, y, width, height);
            const stride = imageData.width; // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨å¯¦éš›çš„ imageData å¯¬åº¦ä½œç‚º stride

            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = previewGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height, stride);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                            const index = ((j + my) * stride + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            previewEditCtx.putImageData(imageData, x, y);
        }

        function previewGetAverageColor(imageData, startX, startY, size, width, height, stride) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                    const index = ((startY + j) * stride + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        function previewUndo() {
            if (previewEditHistory.length > 1) {
                previewEditHistory.pop();
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
                previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            } else {
                previewClearEdits();
            }
        }

        function previewClearEdits() {
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];
            previewBaseEditState = null;
        }

        // ä¸‹è¼‰é è¦½åœ–ç‰‡
        function downloadPreviewImage() {
            const filename = previewCanvas.downloadFilename || 'processed_image.jpg';

            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰JPG: å“è³ªè¨­å®š ${quality}`);

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            // ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦ç¸®æ”¾è‡³ 1000px (é‡å°è£åˆ‡æ¨¡å¼çš„é«˜è§£æåº¦åœ–ç‰‡)
            // æ³¨æ„ï¼šå¦‚æœå·²ç¶“æ˜¯è£åˆ‡æ¨¡å¼ä¸”å·²ç¶“åœ¨ executeCrop ä¸­ç¸®æ”¾éå¯¬åº¦ï¼Œé€™è£¡å°±ä¸æ‡‰è©²å†å¼·åˆ¶ç¸®æ”¾é•·é‚Š
            // é™¤éä½¿ç”¨è€…æ²’æœ‰ç¶“éè£åˆ‡æµç¨‹ (ä¸å¤ªå¯èƒ½ï¼Œå› ç‚º cropImage æ¨¡å¼ä¸‹å¿…é ˆå…ˆè£åˆ‡)
            // ä½†ç‚ºäº†ä¿éšªèµ·è¦‹ï¼Œæˆ‘å€‘å¯ä»¥æª¢æŸ¥ currentMode

            let outputCanvas = finalCanvas;
            const longSide = Math.max(finalCanvas.width, finalCanvas.height);

            // åªæœ‰åœ¨éè£åˆ‡æ¨¡å¼ä¸‹ï¼Œæˆ–è€…è£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦ç•°å¸¸å¤§æ™‚æ‰åŸ·è¡Œæ­¤è™•çš„ç¸®æ”¾
            // ä½†æ ¹æ“šæ–°éœ€æ±‚ï¼Œè£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦å·²ç¶“æ˜¯ 1000pxï¼Œæ‰€ä»¥é€™è£¡æ‡‰è©²è·³é
            if (currentMode !== 'cropImage' && longSide > 1000) {
                console.log(`ğŸ”½ ä¸‹è¼‰å‰ç¸®æ”¾: åŸå§‹å°ºå¯¸ ${finalCanvas.width}x${finalCanvas.height} -> é•·é‚Šé™åˆ¶ 1000px`);
                let newWidth, newHeight;
                if (finalCanvas.width > finalCanvas.height) {
                    newWidth = 1000;
                    newHeight = (finalCanvas.height / finalCanvas.width) * 1000;
                } else {
                    newHeight = 1000;
                    newWidth = (finalCanvas.width / finalCanvas.height) * 1000;
                }

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾
                outputCanvas = safeAdvancedImageScale(finalCanvas, newWidth, newHeight, quality);
            }

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰JPG: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            outputCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename, { type: "image/jpeg" });
                    console.log(`ğŸ”½ ä¸‹è¼‰JPG: æª”æ¡ˆå¤§å° ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                    saveAs(file);
                }
            }, 'image/jpeg', jpegQuality);
        }

        // ä¸‹è¼‰PNGæ ¼å¼é è¦½åœ–ç‰‡ï¼ˆæœ€é«˜ç•«è³ªï¼‰
        function downloadPreviewImageAsPNG() {
            const filename = previewCanvas.downloadFilename || 'processed_image.png';

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // è¨­ç½®é«˜å“è³ªç¸®æ”¾
            setupHighQualityCanvas(finalCtx);

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            finalCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename.replace(/\.[^/.]+$/, ".png"), { type: "image/png" });
                    saveAs(file);
                }
            }, 'image/png');
        }

        function saveAs(blob) {
            const a = document.createElement("a");
            document.body.appendChild(a);
            a.style.display = "none";
            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = blob.name;

            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Crop Watermark Variables
        let cropLogoImage = null;
        // const cropLogoInput = document.getElementById('cropLogoInput'); // Removed
        // const cropLogoStatus = document.getElementById('cropLogoStatus'); // Removed

        // Preview Watermark Tool Variables
        const previewWatermarkTool = document.getElementById('previewWatermarkTool');
        const previewWatermarkInput = document.getElementById('previewWatermarkInput');

        // Load saved watermark from localStorage
        const savedWatermarkData = localStorage.getItem('cropWatermarkData');
        if (savedWatermarkData) {
            cropLogoImage = new Image();
            cropLogoImage.src = savedWatermarkData;
        }

        if (previewWatermarkTool) {
            previewWatermarkTool.addEventListener('click', () => {
                if (cropLogoImage) {
                    applyWatermarkToPreview();
                } else {
                    previewWatermarkInput.click();
                }
            });
        }

        if (previewWatermarkInput) {
            previewWatermarkInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        cropLogoImage = new Image();
                        cropLogoImage.onload = function () {
                            // Save to localStorage
                            localStorage.setItem('cropWatermarkData', event.target.result);

                            // Determine which mode is active and apply watermark accordingly
                            if (document.getElementById('previewArea').style.display !== 'none') {
                                applyWatermarkToPreview();
                            } else if (document.getElementById('screenshotArrange').style.display !== 'none') {
                                applyWatermarkToArrange(cropLogoImage);
                            } else if (document.getElementById('borderlessScreenshotArrange').style.display !== 'none') {
                                applyWatermarkToBorderlessArrange(cropLogoImage);
                            }
                        };
                        cropLogoImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function applyWatermarkToPreview() {
            if (!cropLogoImage) return;

            // Save current state for undo
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));

            const ctx = previewEditCtx;

            // Watermark scaling (shrink 30%)
            const logoWidth = cropLogoImage.width * 0.7;
            const logoHeight = cropLogoImage.height * 0.7;

            // Position: Bottom-right, 15px margin
            // Note: previewEditCanvas size matches the preview image size
            const logoX = previewEditCanvas.width - logoWidth - 15;
            const logoY = previewEditCanvas.height - logoHeight - 15;

            ctx.save();
            ctx.globalAlpha = 0.5; // 50% opacity
            ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            ctx.restore();

            console.log('Watermark applied to preview edit canvas');
        }

        function handleCropFileSelect(event) {
            console.log('handleCropFileSelect triggered', event);
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                console.log('File is an image:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    console.log('FileReader onload triggered');
                    originalCropImage = new Image();
                    originalCropImage.onload = () => {
                        console.log('originalCropImage onload triggered', originalCropImage.width, originalCropImage.height);
                        let displayWidth = originalCropImage.width;
                        let displayHeight = originalCropImage.height;
                        let scaleFactor = 1; // æ–°å¢ï¼šç¸®æ”¾å› å­

                        // å¦‚æœåœ–ç‰‡å¯¬åº¦æˆ–é«˜åº¦è¶…éæœ€å¤§é™åˆ¶ï¼Œå‰‡æŒ‰æ¯”ä¾‹ç¸®æ”¾
                        if (displayWidth > MAX_CROP_WIDTH || displayHeight > MAX_CROP_HEIGHT) {
                            const aspectRatio = displayWidth / displayHeight;
                            if (displayWidth / MAX_CROP_WIDTH > displayHeight / MAX_CROP_HEIGHT) {
                                scaleFactor = MAX_CROP_WIDTH / displayWidth;
                                displayWidth = MAX_CROP_WIDTH;
                                displayHeight = displayWidth / aspectRatio;
                            } else {
                                scaleFactor = MAX_CROP_HEIGHT / displayHeight;
                                displayHeight = MAX_CROP_HEIGHT;
                                displayWidth = displayHeight * aspectRatio;
                            }
                        }

                        cropCanvas.width = displayWidth;
                        cropCanvas.height = displayHeight;
                        cropCtx.drawImage(originalCropImage, 0, 0, displayWidth, displayHeight);

                        cropSelectionCanvas.width = displayWidth;
                        cropSelectionCanvas.height = displayHeight;
                        cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

                        // é‡ç½®è£åˆ‡é¸å€
                        cropSelection = { x: 0, y: 0, width: 0, height: 0, scaleFactor: scaleFactor }; // æ–°å¢ï¼šå„²å­˜ç¸®æ”¾å› å­
                        isCropping = false;
                        cropImageArea.style.display = 'block'; // ç¢ºä¿è£åˆ‡å€åŸŸé¡¯ç¤º
                    };
                    originalCropImage.onerror = () => {
                        console.error('Error loading originalCropImage');
                        status.innerHTML += '<br>åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥åœ–ç‰‡æª”æ¡ˆã€‚';
                    };
                    originalCropImage.src = e.target.result;
                    console.log('originalCropImage.src set');
                };
                reader.readAsDataURL(file);
            }
        }

        function startCropDrawing(e) {
            console.log('startCropDrawing triggered');
            isCropping = true;
            [cropStartX, cropStartY] = [e.offsetX, e.offsetY];
            cropEndX = cropStartX;
            cropEndY = cropStartY;
        }

        function drawCropSelection(e) {
            if (!isCropping) return;
            cropEndX = e.offsetX;
            cropEndY = e.offsetY;

            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);

            // ç¹ªè£½åŠé€æ˜é®ç½© (å››å€‹çŸ©å½¢è¦†è“‹é¸å€å¤–)
            cropSelectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            // Top rectangle
            cropSelectionCtx.fillRect(0, 0, cropSelectionCanvas.width, y);
            // Bottom rectangle
            cropSelectionCtx.fillRect(0, y + height, cropSelectionCanvas.width, cropSelectionCanvas.height - (y + height));
            // Left rectangle
            cropSelectionCtx.fillRect(0, y, x, height);
            // Right rectangle
            cropSelectionCtx.fillRect(x + width, y, cropSelectionCanvas.width - (x + width), height);

            // ç¹ªè£½é¸å€é‚Šæ¡†
            cropSelectionCtx.strokeStyle = 'red';
            cropSelectionCtx.lineWidth = 2;
            cropSelectionCtx.strokeRect(x, y, width, height);

            cropSelection = { x, y, width, height, scaleFactor: cropSelection.scaleFactor };
        }

        function stopCropDrawing() {
            isCropping = false;
        }

        function executeCrop() {
            if (!originalCropImage || cropSelection.width === 0 || cropSelection.height === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ä¸¦ç¹ªè£½è£åˆ‡ç¯„åœã€‚');
                return;
            }

            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨åŸå§‹åœ–ç‰‡çš„çœŸå¯¦å°ºå¯¸é€²è¡Œè£åˆ‡ï¼Œè€Œä¸æ˜¯é è¦½å°ºå¯¸
            // cropSelection ç´€éŒ„çš„æ˜¯åœ¨ canvas (é è¦½åœ–) ä¸Šçš„åº§æ¨™
            // æˆ‘å€‘éœ€è¦å°‡å…¶è½‰æ›å›åŸå§‹åœ–ç‰‡çš„åº§æ¨™

            // 1. è¨ˆç®—é è¦½åœ–èˆ‡åŸå§‹åœ–çš„æ¯”ä¾‹
            // cropCanvas.width æ˜¯é è¦½ canvas çš„å¯¬åº¦
            // originalCropImage.width æ˜¯åŸå§‹åœ–ç‰‡çš„å¯¬åº¦
            // ä½†æ³¨æ„ï¼šåœ¨ handleCropFileSelect ä¸­ï¼Œæˆ‘å€‘å¯èƒ½å·²ç¶“å°é¡¯ç¤ºé€²è¡Œäº†ç¸®æ”¾ (scaleFactor)
            // å¯¦éš›ä¸Šï¼ŒcropSelection.scaleFactor å·²ç¶“ç´€éŒ„äº† (é è¦½å¯¬åº¦ / åŸå§‹å¯¬åº¦) çš„æ¯”ä¾‹å—ï¼Ÿ
            // è®“æˆ‘å€‘é‡æ–°æª¢æŸ¥ handleCropFileSelect çš„é‚è¼¯

            // åœ¨ handleCropFileSelect ä¸­:
            // scaleFactor = MAX_CROP_WIDTH / displayWidth; (å¦‚æœéœ€è¦ç¸®å°é¡¯ç¤º)
            // cropCanvas.width = displayWidth (é€™æ˜¯ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦)
            // cropCtx.drawImage(originalCropImage, ..., displayWidth, displayHeight)

            // æ‰€ä»¥ï¼ŒcropSelection ä¸Šçš„åº§æ¨™æ˜¯åŸºæ–¼ "ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦"
            // è¦æ‹¿åˆ°åŸå§‹åœ–ç‰‡çš„åº§æ¨™ï¼Œæˆ‘å€‘éœ€è¦é™¤ä»¥ scaleFactor (å¦‚æœ scaleFactor æ˜¯ é¡¯ç¤º/åŸå§‹)
            // ç­‰ç­‰ï¼ŒhandleCropFileSelect ä¸­çš„ scaleFactor å®šç¾©æ˜¯ï¼š
            // if (displayWidth > MAX_CROP_WIDTH ...) { scaleFactor = MAX_CROP_WIDTH / original_width }
            // æ‰€ä»¥ cropSelection.x / scaleFactor æ‡‰è©²å°±æ˜¯åŸå§‹åº§æ¨™

            // è®“æˆ‘å€‘ç¢ºèªä¸€ä¸‹ cropSelection.scaleFactor çš„å€¼
            const scale = cropSelection.scaleFactor || 1;

            const sourceX = cropSelection.x / scale;
            const sourceY = cropSelection.y / scale;
            const sourceWidth = cropSelection.width / scale;
            const sourceHeight = cropSelection.height / scale;

            console.log(`è£åˆ‡è³‡è¨Š:
            é è¦½é¸å€: ${cropSelection.x}, ${cropSelection.y}, ${cropSelection.width}x${cropSelection.height}
            ç¸®æ”¾å› å­: ${scale}
            åŸå§‹åº§æ¨™: ${sourceX}, ${sourceY}, ${sourceWidth}x${sourceHeight}
            åŸå§‹åœ–ç‰‡: ${originalCropImage.width}x${originalCropImage.height}
            `);

            const croppedCanvas = document.createElement('canvas');
            // è¨­å®š canvas ç‚ºåŸå§‹è§£æåº¦çš„å¤§å°
            croppedCanvas.width = sourceWidth;
            croppedCanvas.height = sourceHeight;
            const croppedCtx = croppedCanvas.getContext('2d');

            // ä½¿ç”¨é«˜å“è³ªè¨­å®š
            setupHighQualityCanvas(croppedCtx);

            croppedCtx.drawImage(
                originalCropImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // ä¾†æºåº§æ¨™ (åŸå§‹è§£æåº¦)
                0, 0, sourceWidth, sourceHeight              // ç›®æ¨™åº§æ¨™ (åŸå§‹è§£æåº¦)
            );

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡å¯¬åº¦ç¸®è‡³ 1000px
            let finalCanvas = croppedCanvas;
            if (croppedCanvas.width > 1000) {
                console.log(`è£åˆ‡å¾Œè‡ªå‹•ç¸®æ”¾: åŸå§‹å¯¬åº¦ ${croppedCanvas.width} -> ç›®æ¨™å¯¬åº¦ 1000px`);
                const newWidth = 1000;
                const newHeight = (croppedCanvas.height / croppedCanvas.width) * 1000;

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ (é è¨­ä½¿ç”¨ balanced å“è³ª)
                finalCanvas = safeAdvancedImageScale(croppedCanvas, newWidth, newHeight, 'balanced');
            }

            // ğŸ”¥ Removed auto-apply watermark logic
            // if (cropLogoImage) {
            //     const ctx = finalCanvas.getContext('2d');

            //     // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            //     const logoWidth = cropLogoImage.width * 0.7;
            //     const logoHeight = cropLogoImage.height * 0.7;

            //     // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            //     // æ³¨æ„ï¼šå¦‚æœåœ–ç‰‡è¢«ç¸®æ”¾åˆ° 1000pxï¼Œé‚Šè·ä¹Ÿæ‡‰è©²ç›¸å°èª¿æ•´ï¼Œä½†é€™è£¡å›ºå®š 15px æ‡‰è©²é‚„å¥½
            //     const logoX = finalCanvas.width - logoWidth - 15;
            //     const logoY = finalCanvas.height - logoHeight - 15;

            //     ctx.save();
            //     ctx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            //     ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            //     ctx.restore();

            //     console.log('å·²æ·»åŠ æµ®æ°´å°åˆ°è£åˆ‡åœ–ç‰‡');
            // }

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•åœ¨åœ–ç‰‡æœ€å¤–åœåŠ ä¸Š 1px é»‘é‚Š
            finalCanvas = addBlackBorder(finalCanvas);

            // å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡é¡¯ç¤ºåœ¨é è¦½å€
            showPreview(finalCanvas, 'cropped_image.jpg');
            status.innerHTML = 'åœ–ç‰‡è£åˆ‡å®Œæˆï¼å·²è‡ªå‹•èª¿æ•´å¯¬åº¦ç‚º 1000pxã€‚';

            // è£åˆ‡å®Œæˆå¾Œï¼Œéš±è—è£åˆ‡å€åŸŸä¸¦é‡ç½®ç‹€æ…‹
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            cropImageArea.style.display = 'none';

            // å°‡æ¨¡å¼åˆ‡æ›å›é è¨­çš„ resize320ï¼Œä¸¦æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥
            dropZone.style.display = 'none'; // ç¢ºä¿æ‹–æ›³å€éš±è—ï¼Œå› ç‚ºé è¦½å€æœƒé¡¯ç¤º
        }

        function cancelCrop() {
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥ // å–æ¶ˆå¾Œï¼Œåˆ‡æ›å›é è¨­æ¨¡å¼
        }

        // æ–°å¢çš„æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const fileInput2 = document.getElementById('fileInput2');
        const fileCount = document.getElementById('fileCount');
        const processButton = document.getElementById('processButton');
        const downloadButton = document.getElementById('downloadButton');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageList = document.getElementById('imageList');
        const editCanvas = document.getElementById('editCanvas');
        const editCtx = editCanvas.getContext('2d');
        const rectangleTool = document.getElementById('rectangleTool');
        const arrowTool = document.getElementById('arrowTool');
        const watermarkTool = document.getElementById('watermarkTool');
        const undoButton = document.getElementById('undoButton');
        const clearButton = document.getElementById('clearButton');
        const clearAllButton = document.getElementById('clearAllButton');

        const ARRANGE_MAX_WIDTH = 996;
        const ARRANGE_MAX_HEIGHT = 996;
        const SPACING = 2;
        const ARRANGE_MAX_IMAGES = 4;
        const BORDER_WIDTH = 2;

        let uploadedImages = [];
        let isDrawing = false;
        let startX, startY;
        let currentTool = null;
        let editHistory = [];
        let baseEditState = null;

        fileInput2.addEventListener('change', handleFileSelect);
        processButton.addEventListener('click', processImages);
        downloadButton.addEventListener('click', downloadProcessedImage);
        rectangleTool.addEventListener('click', () => {
            currentTool = 'rectangle';
            editCanvas.style.cursor = 'crosshair';
        });
        arrowTool.addEventListener('click', () => {
            currentTool = 'arrow';
            editCanvas.style.cursor = 'crosshair';
        });
        watermarkTool.addEventListener('click', () => {
            // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
            const savedWatermark = localStorage.getItem('cropWatermarkData');
            if (savedWatermark) {
                const img = new Image();
                if (savedWatermark.startsWith('http')) img.crossOrigin = "anonymous";
                img.onload = () => {
                    applyWatermarkToArrange(img);
                };
                img.src = savedWatermark;
            } else {
                // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                previewWatermarkInput.click();
            }
        });
        // ç›£è½ previewWatermarkInput çš„è®ŠåŒ–ï¼Œä»¥ä¾¿åœ¨é¸æ“‡å¾Œæ‡‰ç”¨æ–¼ä¸¦æ’æ¨¡å¼
        // æ³¨æ„ï¼šé€™è£¡éœ€è¦ä¸€å€‹æ©Ÿåˆ¶ä¾†å€åˆ†æ˜¯é è¦½æ¨¡å¼é‚„æ˜¯ä¸¦æ’æ¨¡å¼è§¸ç™¼çš„
        // ç°¡å–®è§£æ³•ï¼šåœ¨ previewWatermarkInput çš„ change äº‹ä»¶ä¸­ï¼Œæª¢æŸ¥ç•¶å‰æ¨¡å¼
        // ä½†å› ç‚º previewWatermarkInput å·²ç¶“ç¶å®šäº† applyWatermarkToPreviewï¼Œ
        // æˆ‘å€‘å¯èƒ½éœ€è¦ä¸€å€‹æ–°çš„ input æˆ–è€…ä¿®æ”¹ç¾æœ‰çš„é‚è¼¯ã€‚
        // ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘é‡ç”¨ previewWatermarkInputï¼Œä½†åœ¨å…¶ change handler ä¸­åˆ¤æ–·
        // æˆ–è€…ï¼Œæˆ‘å€‘ç›´æ¥åœ¨é€™è£¡æ·»åŠ ä¸€å€‹å°ˆç”¨çš„ handlerï¼Œä½†é€™æœƒå°è‡´é‡è¤‡ç¶å®š
        // æ›´å¥½çš„æ–¹æ³•ï¼šå‰µå»ºä¸€å€‹é€šç”¨çš„è™•ç†å‡½æ•¸

        undoButton.addEventListener('click', undo);
        clearButton.addEventListener('click', clearEdits);
        clearAllButton.addEventListener('click', clearAllImages);

        editCanvas.addEventListener('mousedown', startDrawing);
        editCanvas.addEventListener('mousemove', draw);
        editCanvas.addEventListener('mouseup', stopDrawing);
        editCanvas.addEventListener('mouseout', stopDrawing);

        function updateFileInputAndCount() {
            const remainingSlots = ARRANGE_MAX_IMAGES - uploadedImages.length;
            fileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            fileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            clearAllButton.style.display = uploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, ARRANGE_MAX_IMAGES - uploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = e.target.result;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        uploadedImages.push(img);
                        updateImageList();
                        updateFileInputAndCount();
                    }
                }
                reader.readAsDataURL(file);
            });
        }

        function createImageItem(img, index) {
            const div = document.createElement('div');
            div.className = 'image-item';
            div.draggable = true;
            div.dataset.uid = img._uid; // Store unique ID in DOM
            div.innerHTML = `
                <img src="${img.src}" alt="Image ${index + 1}">
                <button class="delete-button">åˆªé™¤</button>
            `;

            div.addEventListener('dragstart', dragStart);
            div.addEventListener('dragend', dragEnd);
            div.addEventListener('dragenter', dragEnter);
            div.addEventListener('dragleave', dragLeave);
            div.addEventListener('dragover', dragOver);
            div.addEventListener('drop', drop);
            div.querySelector('.delete-button').addEventListener('click', () => deleteImage(index));

            return div;
        }

        function dragStart(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.index);
        }

        function dragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function dragEnter(e) {
            e.preventDefault();
            if (!this.classList.contains('dragging')) {
                this.classList.add('drag-over');
            }
        }

        function dragLeave(e) {
            this.classList.remove('drag-over');
        }

        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function drop(e) {
            e.preventDefault();
            const draggable = document.querySelector('.dragging');
            if (this !== draggable) {
                const allItems = [...imageList.querySelectorAll('.image-item')];
                const draggedIndex = allItems.indexOf(draggable);
                const targetIndex = allItems.indexOf(this);
                if (draggedIndex < targetIndex) {
                    this.parentNode.insertBefore(draggable, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggable, this);
                }
                updateImageOrder();
            }
            this.classList.remove('drag-over');
        }

        function updateImageOrder() {
            const newOrderIds = Array.from(imageList.children).map(item => item.dataset.uid);
            uploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));
        }

        function deleteImage(index) {
            uploadedImages.splice(index, 1);
            updateImageList();
            updateFileInputAndCount();
        }

        function updateImageList() {
            imageList.innerHTML = '';
            uploadedImages.forEach((img, index) => {
                const imageItem = createImageItem(img, index);
                imageItem.dataset.index = index;
                imageList.appendChild(imageItem);
            });
        }

        function clearAllImages() {
            uploadedImages = [];
            updateImageList();
            updateFileInputAndCount();
            fileInput2.value = '';
        }

        function processImages() {
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            const newOrder = Array.from(imageList.children).map(item => item.querySelector('img').src);
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            // Ensure order is correct before processing
            updateImageOrder();

            arrangeImages(uploadedImages);
            downloadButton.style.display = 'block';

            clearEdits();
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
        }

        function arrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šç‚ºæ¯å¼µåœ–ç‰‡æ·»åŠ é»‘æ¡†ä¸¦è¨ˆç®—å°ºå¯¸
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // å‰µå»ºæ–°çš„Imageå°è±¡ç”¨æ–¼å¾ŒçºŒè™•ç†
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ä½¿ç”¨è™•ç†å¾Œçš„åœ–ç‰‡é€²è¡Œå¾ŒçºŒç¸®æ”¾è¨ˆç®—
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(ARRANGE_MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > ARRANGE_MAX_HEIGHT) {
                    newHeight = ARRANGE_MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // ç‚ºç¸®æ”¾å¾Œçš„åœ–ç‰‡æ·»åŠ é»‘æ¡†
                const borderedCanvas = addBlackBorder(scaledCanvas);

                totalWidth += borderedCanvas.width;
                maxHeight = Math.max(maxHeight, borderedCanvas.height);

                return { canvas: borderedCanvas, width: borderedCanvas.width, height: borderedCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            canvas.width = Math.min(ARRANGE_MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            canvas.height = Math.min(ARRANGE_MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡å¸¶é»‘æ¡†çš„åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (canvas.height - height) / 2;
                ctx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            resizeEditCanvas();

            document.getElementById('editTools').style.display = 'block';
        }

        function resizeEditCanvas() {
            editCanvas.width = canvas.width;
            editCanvas.height = canvas.height;
            editCanvas.style.display = 'block';
        }

        function startDrawing(e) {
            if (!currentTool) return;
            isDrawing = true;
            [startX, startY] = [e.offsetX, e.offsetY];
            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function draw(e) {
            if (!isDrawing || !currentTool) return;
            const [endX, endY] = [e.offsetX, e.offsetY];

            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            if (editHistory.length > 0) {
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
            }

            editCtx.beginPath();
            editCtx.strokeStyle = 'red';
            editCtx.lineWidth = 3;

            if (currentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                editCtx.save();
                editCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                editCtx.beginPath();
                editCtx.rect(startX + 3, startY + 3, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                editCtx.save();
                editCtx.strokeStyle = 'red';
                editCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                editCtx.beginPath();
                editCtx.rect(startX, startY, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();
            } else if (currentTool === 'arrow') {
                drawArrow(startX, startY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (currentTool === 'mosaic') {
                const x = Math.min(startX, endX);
                const y = Math.min(startY, endY);
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);
                drawMosaic(x, y, width, height);
            }

            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            editCtx.save();
            editCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            editCtx.fillStyle = 'rgba(0,0,0,0.3)';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX + 2, fromY + 2);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            editCtx.beginPath();
            editCtx.moveTo(toX + 2, toY + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            editCtx.save();
            editCtx.strokeStyle = 'red';
            editCtx.fillStyle = 'red';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';
            editCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX, fromY);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            editCtx.beginPath();
            editCtx.moveTo(toX, toY);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();
        }

        function undo() {
            if (editHistory.length > 1) {
                editHistory.pop();
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
                baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
            } else {
                clearEdits();
            }
        }

        function clearEdits() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
            baseEditState = null;
        }

        function applyWatermarkToArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = editCanvas.width - logoWidth - 15;
            const logoY = editCanvas.height - logoHeight - 15;

            editCtx.save();
            editCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            editCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            editCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function downloadProcessedImage() {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(canvas, 0, 0);
            finalCtx.drawImage(editCanvas, 0, 0);

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }

        window.addEventListener('load', function () {
            setMode('cropImage');
            updateFileInputAndCount();
            document.getElementById('editTools').style.display = 'none';
            updateQualityDescription(); // åˆå§‹åŒ–å“è³ªæè¿°
        });

        const mosaicTool = document.getElementById('mosaicTool');
        let isMosaicMode = false;
        const MOSAIC_SIZE = 10;

        mosaicTool.addEventListener('click', () => {
            currentTool = 'mosaic';
            isMosaicMode = true;
            editCanvas.style.cursor = 'crosshair';
        });

        function drawMosaic(x, y, width, height) {
            const imageData = ctx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = getAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            editCtx.putImageData(imageData, x, y);
        }

        function getAverageColor(imageData, startX, startY, size, width, height) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    const index = ((startY + j) * width + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        let lastX, lastY;
        editCanvas.addEventListener('mousemove', (e) => {
            lastX = e.offsetX;
            lastY = e.offsetY;
        });

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶é¸æ“‡è™•ç†
        function borderlessHandleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, MAX_IMAGES - borderlessUploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    const dataUrl = e.target.result;
                    if (dataUrl.startsWith('http')) img.crossOrigin = "anonymous";
                    img.src = dataUrl;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        borderlessUploadedImages.push(img);
                        borderlessUpdateImageList();
                        borderlessUpdateFileInputAndCount();
                    }
                    img.onerror = function () {
                        console.error('åœ–ç‰‡è¼‰å…¥å¤±æ•—:', file.name);
                    };
                }
                reader.readAsDataURL(file);
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶è¼¸å…¥æ›´æ–°
        function borderlessUpdateFileInputAndCount() {
            const remainingSlots = MAX_IMAGES - borderlessUploadedImages.length;
            borderlessFileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            borderlessFileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            borderlessClearAllButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆ—è¡¨æ›´æ–°
        function borderlessUpdateImageList() {
            borderlessImageList.innerHTML = '';
            borderlessUploadedImages.forEach((img, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.draggable = true;
                div.dataset.index = index;
                div.dataset.uid = img._uid; // Store unique ID in DOM

                const imgElement = document.createElement('img');
                imgElement.src = img.src;
                imgElement.alt = `åœ–ç‰‡ ${index + 1}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-button';
                deleteBtn.textContent = 'åˆªé™¤';
                deleteBtn.addEventListener('click', () => borderlessRemoveImage(index));

                div.appendChild(imgElement);
                div.appendChild(deleteBtn);
                borderlessImageList.appendChild(div);

                // æ‹–æ‹½åŠŸèƒ½
                div.addEventListener('dragstart', borderlessHandleDragStart);
                div.addEventListener('dragover', borderlessHandleDragOver);
                div.addEventListener('drop', borderlessHandleDrop);
                div.addEventListener('dragend', borderlessHandleDragEnd);
            });

            borderlessProcessButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆªé™¤
        function borderlessRemoveImage(index) {
            borderlessUploadedImages.splice(index, 1);
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ‹–æ‹½è™•ç†å‡½æ•¸
        function borderlessHandleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.index);
        }

        function borderlessHandleDragOver(e) {
            e.preventDefault();
            e.target.closest('.image-item').classList.add('drag-over');
        }

        function borderlessHandleDrop(e) {
            e.preventDefault();
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = parseInt(e.target.closest('.image-item').dataset.index);

            if (draggedIndex !== targetIndex) {
                const draggedItem = borderlessUploadedImages[draggedIndex];
                borderlessUploadedImages.splice(draggedIndex, 1);
                borderlessUploadedImages.splice(targetIndex, 0, draggedItem);
                borderlessUpdateImageList();
            }

            e.target.closest('.image-item').classList.remove('drag-over');
        }

        function borderlessHandleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('#borderlessImageList .image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡è™•ç†
        function borderlessProcessImages() {
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            // Re-sort based on DOM order to ensure consistency
            const newOrderIds = Array.from(borderlessImageList.children).map(item => item.dataset.uid);
            borderlessUploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));

            borderlessArrangeImages(borderlessUploadedImages);
            borderlessDownloadButton.style.display = 'block';

            borderlessClearEdits();
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
        }

        // ğŸ”¥ ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡æ’åˆ—ï¼ˆèˆ‡åŸç‰ˆå®Œå…¨ä¸€è‡´ï¼Œåªæ˜¯ä¸æ·»åŠ é»‘æ¡†ï¼‰
        function borderlessArrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šè™•ç†åœ–ç‰‡ä½†ä¸æ·»åŠ é»‘æ¡†ï¼ˆèˆ‡åŸç‰ˆé‚è¼¯ä¸€è‡´ï¼‰
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // ğŸ”§ ä¿®å¾©ï¼šèˆ‡é‚Šæ¡†ç‰ˆæœ¬ä¸€è‡´ï¼Œå‰µå»ºå°è±¡è€Œä¸æ˜¯æ–°Image
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨èˆ‡é‚Šæ¡†ç‰ˆæœ¬ç›¸åŒçš„ç¸®æ”¾é‚è¼¯
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > MAX_HEIGHT) {
                    newHeight = MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // âœ¨ é—œéµå·®ç•°ï¼šç„¡é‚Šæ¡†ç‰ˆæœ¬ä¸æ·»åŠ é»‘æ¡†
                // åŸç‰ˆæœƒèª¿ç”¨: const borderedCanvas = addBlackBorder(scaledCanvas);
                // ç„¡é‚Šæ¡†ç‰ˆæœ¬ç›´æ¥ä½¿ç”¨ scaledCanvas

                totalWidth += scaledCanvas.width;
                maxHeight = Math.max(maxHeight, scaledCanvas.height);

                return { canvas: scaledCanvas, width: scaledCanvas.width, height: scaledCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            borderlessCanvas.width = Math.min(MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            borderlessCanvas.height = Math.min(MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            borderlessCtx.fillStyle = 'white';
            borderlessCtx.fillRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (borderlessCanvas.height - height) / 2;
                borderlessCtx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            // è¨­ç½®ç·¨è¼¯canvas
            borderlessEditCanvas.width = borderlessCanvas.width;
            borderlessEditCanvas.height = borderlessCanvas.height;
            borderlessEditCanvas.style.display = 'block';

            document.getElementById('borderlessEditTools').style.display = 'block';
            borderlessInitializeEditTools();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç·¨è¼¯å·¥å…·åˆå§‹åŒ–
        function borderlessInitializeEditTools() {
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);

            borderlessRectangleTool.addEventListener('click', () => borderlessSetTool('rectangle'));
            borderlessArrowTool.addEventListener('click', () => borderlessSetTool('arrow'));
            borderlessWatermarkTool.addEventListener('click', () => {
                // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
                const savedWatermark = localStorage.getItem('cropWatermarkData');
                if (savedWatermark) {
                    const img = new Image();
                    img.onload = () => {
                        applyWatermarkToBorderlessArrange(img);
                    };
                    img.src = savedWatermark;
                } else {
                    // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                    // é€™è£¡æˆ‘å€‘éœ€è¦ä¸€å€‹è®Šé‡ä¾†æ¨™è¨˜ç•¶å‰æ˜¯å“ªå€‹æ¨¡å¼è§¸ç™¼çš„æµ®æ°´å°é¸æ“‡
                    // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘å‡è¨­ä½¿ç”¨è€…å·²ç¶“åœ¨è£åˆ‡æ¨¡å¼è¨­å®šå¥½æµ®æ°´å°ï¼Œæˆ–è€…æˆ‘å€‘å¼•å°ä»–å€‘å»è¨­å®š
                    // æˆ–è€…ï¼Œæˆ‘å€‘å¯ä»¥è‡¨æ™‚å€Ÿç”¨ previewWatermarkInput
                    previewWatermarkInput.click();
                }
            });
            borderlessMosaicTool.addEventListener('click', () => borderlessSetTool('mosaic'));
            borderlessUndoButton.addEventListener('click', borderlessUndo);
            borderlessClearButton.addEventListener('click', borderlessClearAllEdits);

            borderlessEditCanvas.addEventListener('mousedown', borderlessStartDrawing);
            borderlessEditCanvas.addEventListener('mousemove', borderlessDraw);
            borderlessEditCanvas.addEventListener('mouseup', borderlessStopDrawing);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å·¥å…·è¨­ç½®
        function borderlessSetTool(tool) {
            borderlessCurrentTool = tool;
            document.querySelectorAll('#borderlessEditTools button').forEach(btn => btn.classList.remove('active'));
            if (tool === 'rectangle') {
                borderlessRectangleTool.classList.add('active');
            } else if (tool === 'arrow') {
                borderlessArrowTool.classList.add('active');
            } else if (tool === 'mosaic') {
                borderlessMosaicTool.classList.add('active');
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç¹ªåœ–äº‹ä»¶è™•ç†
        function borderlessStartDrawing(e) {
            if (!borderlessCurrentTool) return;
            borderlessIsDrawing = true;
            const rect = borderlessEditCanvas.getBoundingClientRect();
            borderlessStartX = e.clientX - rect.left;
            borderlessStartY = e.clientY - rect.top;
        }

        function borderlessDraw(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            // é è¦½åŠŸèƒ½å¯ä»¥åœ¨é€™è£¡æ·»åŠ 
        }

        function borderlessStopDrawing(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            borderlessIsDrawing = false;

            const rect = borderlessEditCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„
            if (borderlessEditHistory.length > 10) {
                borderlessEditHistory.shift();
            }

            borderlessEditCtx.beginPath();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.lineWidth = 3;

            if (borderlessCurrentTool === 'rectangle') {
                // çŸ©å½¢å·¥å…· - æ·»åŠ é™°å½±æ•ˆæœ
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                borderlessEditCtx.lineWidth = 3;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX + 3, borderlessStartY + 3, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'red';
                borderlessEditCtx.lineWidth = 2;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX, borderlessStartY, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();
            } else if (borderlessCurrentTool === 'arrow') {
                borderlessDrawArrow(borderlessStartX, borderlessStartY, endX, endY);
            } else if (borderlessCurrentTool === 'mosaic') {
                const x = Math.min(borderlessStartX, endX);
                const y = Math.min(borderlessStartY, endY);
                const width = Math.abs(endX - borderlessStartX);
                const height = Math.abs(endY - borderlessStartY);
                borderlessDrawMosaic(x, y, width, height);
            }

            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç®­é ­ç¹ªè£½å‡½æ•¸
        function borderlessDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ç¹ªè£½é™°å½±æ•ˆæœ
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX + 2, fromY + 2);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2);
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX + 2, toY + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.fillStyle = 'red';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';
            borderlessEditCtx.lineJoin = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX, fromY);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle));
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX, toY);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„é¦¬è³½å…‹ç¹ªè£½å‡½æ•¸
        function borderlessDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = borderlessCtx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = borderlessGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            borderlessEditCtx.putImageData(imageData, x, y);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å¹³å‡é¡è‰²è¨ˆç®—å‡½æ•¸
        function borderlessGetAverageColor(imageData, startX, startY, size, totalWidth, totalHeight) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let x = startX; x < startX + size && x < totalWidth; x++) {
                for (let y = startY; y < startY + size && y < totalHeight; y++) {
                    const index = (y * totalWidth + x) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.floor(r / count), Math.floor(g / count), Math.floor(b / count)];
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ’¤éŠ·åŠŸèƒ½
        function borderlessUndo() {
            if (borderlessEditHistory.length > 1) {
                borderlessEditHistory.pop();
                borderlessEditCtx.putImageData(borderlessEditHistory[borderlessEditHistory.length - 1], 0, 0);
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰ç·¨è¼¯
        function borderlessClearAllEdits() {
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = null;
        }

        function applyWatermarkToBorderlessArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = borderlessEditCanvas.width - logoWidth - 15;
            const logoY = borderlessEditCanvas.height - logoHeight - 15;

            borderlessEditCtx.save();
            borderlessEditCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            borderlessEditCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            borderlessEditCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰åœ–ç‰‡
        function borderlessClearAllImages() {
            borderlessUploadedImages = [];
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
            borderlessDownloadButton.style.display = 'none';
            document.getElementById('borderlessEditTools').style.display = 'none';
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
            borderlessFileInput2.value = ''; // æ¸…é™¤æ–‡ä»¶è¼¸å…¥
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ä¸‹è¼‰åŠŸèƒ½
        function borderlessDownloadProcessedImage() {
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = borderlessCanvas.width;
            finalCanvas.height = borderlessCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(borderlessCanvas, 0, 0);
            finalCtx.drawImage(borderlessEditCanvas, 0, 0);

            // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98;
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99;
                    break;
                case 'high':
                    jpegQuality = 0.95;
                    break;
                case 'balanced':
                    jpegQuality = 0.90;
                    break;
                case 'fast':
                    jpegQuality = 0.80;
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'borderless_processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }
        // ============ ç¹ç°¡è½‰æ›åŠŸèƒ½ ============

        const convInput = document.getElementById('convInput');
        const convOutputTrad = document.getElementById('convOutputTrad');
        const convOutputSimp = document.getElementById('convOutputSimp');
        const dictBtn = document.getElementById('dictBtn');
        const dictDialog = document.getElementById('dictDialog');
        const closeDictBtn = document.getElementById('closeDictBtn');
        const addDictBtn = document.getElementById('addDictBtn');
        const dictList = document.getElementById('dictList');
        const newSimple = document.getElementById('newSimple');
        const newTrad = document.getElementById('newTrad');
        const dictCountBadge = document.getElementById('dictCountBadge');

        // è½‰æ›å™¨ç‹€æ…‹
        let converterS2T = null;
        let converterT2S = null;
        let customDictionary = JSON.parse(localStorage.getItem('custom_dictionary') || '[]');

        // åˆå§‹åŒ– OpenCC
        async function initOpenCC() {
            if (window.OpenCC && !converterS2T) {
                converterS2T = window.OpenCC.Converter({ from: 'cn', to: 'tw' });
                converterT2S = window.OpenCC.Converter({ from: 'tw', to: 'cn' });
                console.log('OpenCC initialized');
            }
        }

        // å­—å…¸åŠŸèƒ½
        function updateDictUI() {
            dictList.innerHTML = '';

            if (customDictionary.length === 0) {
                dictList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">å°šç„¡è‡ªå®šç¾©è¦å‰‡</div>';
                dictCountBadge.style.display = 'none';
                return;
            }

            dictCountBadge.textContent = customDictionary.length;
            dictCountBadge.style.display = 'inline-block';

            customDictionary.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'dict-item';
                item.innerHTML = `
                    <div style="flex:1; display:flex; gap:10px; align-items:center;">
                        <span style="flex:1; text-align:right;">${entry.simplified}</span>
                        <span style="color:#999;">â‡Œ</span>
                        <span style="flex:1; font-weight:bold;">${entry.traditional}</span>
                    </div>
                    <button class="btn-danger" style="margin-left:10px;">ğŸ—‘ï¸</button>
                `;
                item.querySelector('.btn-danger').addEventListener('click', () => {
                    customDictionary = customDictionary.filter(e => e.id !== entry.id);
                    saveDictionary();
                    updateDictUI();
                    performConversion(); // é‡æ–°è½‰æ›
                });
                dictList.appendChild(item);
            });
        }

        function saveDictionary() {
            localStorage.setItem('custom_dictionary', JSON.stringify(customDictionary));
        }

        // è½‰æ›é‚è¼¯
        function preProcess(text, type) {
            let result = text;
            customDictionary.forEach(entry => {
                if (type === 'trad') {
                    result = result.split(entry.simplified).join(entry.traditional);
                } else {
                    result = result.split(entry.traditional).join(entry.simplified);
                }
            });
            return result;
        }

        function applyDictionary(text, type) {
            let result = text;
            customDictionary.forEach(entry => {
                if (type === 'trad') {
                    result = result.split(entry.simplified).join(entry.traditional);
                } else {
                    result = result.split(entry.traditional).join(entry.simplified);
                }
            });
            return result;
        }

        async function performConversion() {
            const text = convInput.value;
            if (!text) {
                convOutputTrad.textContent = '';
                convOutputSimp.textContent = '';
                return;
            }

            if (!converterS2T || !converterT2S) await initOpenCC();

            // ç¹é«”è½‰æ›æµç¨‹
            const preTrad = preProcess(text, 'trad');
            let tradResult = converterS2T ? converterS2T(preTrad) : preTrad;
            tradResult = applyDictionary(tradResult, 'trad');
            convOutputTrad.textContent = tradResult;

            // ç°¡é«”è½‰æ›æµç¨‹
            const preSimp = preProcess(text, 'simp');
            let simpResult = converterT2S ? converterT2S(preSimp) : preSimp;
            simpResult = applyDictionary(simpResult, 'simp');
            convOutputSimp.textContent = simpResult;
        }

        // äº‹ä»¶ç›£è½
        document.addEventListener('DOMContentLoaded', () => {
            initOpenCC();
            updateDictUI();
        });

        convInput.addEventListener('input', performConversion);

        // Dictionary modal
        dictBtn.addEventListener('click', () => {
            dictDialog.style.display = 'flex';
            updateDictUI();
        });

        closeDictBtn.addEventListener('click', () => {
            dictDialog.style.display = 'none';
        });

        dictDialog.addEventListener('click', (e) => {
            if (e.target === dictDialog) dictDialog.style.display = 'none';
        });

        addDictBtn.addEventListener('click', () => {
            const s = newSimple.value.trim();
            const t = newTrad.value.trim();
            if (s && t) {
                customDictionary.push({ id: Date.now().toString(), simplified: s, traditional: t });
                saveDictionary();
                newSimple.value = '';
                newTrad.value = '';
                updateDictUI();
                performConversion();
            } else {
                alert('è«‹è¼¸å…¥ç°¡é«”å’Œç¹é«”è©å½™');
            }
        });

        // Tools
        document.getElementById('convClearBtn').addEventListener('click', () => {
            convInput.value = '';
            performConversion();
        });

        document.getElementById('convCopyInputBtn').addEventListener('click', () => navigator.clipboard.writeText(convInput.value));
        document.getElementById('convCopyTradBtn').addEventListener('click', () => navigator.clipboard.writeText(convOutputTrad.textContent));
        document.getElementById('convCopySimpBtn').addEventListener('click', () => navigator.clipboard.writeText(convOutputSimp.textContent));

        // Download
        const downloadText = (text, filename) => {
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };

        document.getElementById('convDownloadTradBtn').addEventListener('click', () => downloadText(convOutputTrad.textContent, 'converted_trad.txt'));
        document.getElementById('convDownloadSimpBtn').addEventListener('click', () => downloadText(convOutputSimp.textContent, 'converted_simp.txt'));

        // File Upload
        const convFileInput = document.getElementById('convFileInput');
        document.getElementById('convUploadBtn').addEventListener('click', () => convFileInput.click());
        convFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    convInput.value = e.target.result;
                    performConversion();
                };
                reader.readAsText(file);
                e.target.value = '';
            }
        });





        /* =========================================
           End HTML Cleaner Logic
           ========================================= */

        /* =========================================
           Gemini Watermark Remover Logic (v2)
           ========================================= */
        let mrEngine = null;
        let mrOriginalImage = null; // Store the original loaded image
        let mrCurrentCanvas = document.getElementById('mrCanvas');
        let mrMaskCanvas = null;
        let mrIsProcessing = false;
        let mrHistory = [];
        let mrHistoryIndex = -1;

        const MR_BG_48_DATA = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAGVElEQVR4nMVYvXIbNxD+FvKMWInXmd2dK7MTO7sj9QKWS7qy/Ab2o/gNmCp0JyZ9dHaldJcqTHfnSSF1R7kwlYmwKRYA93BHmkrseMcjgzgA++HbH2BBxhhmBiB/RYgo+hkGSFv/ZOY3b94w89u3b6HEL8JEYCYATCAi2JYiQ8xMDADGWsvMbfVagm6ZLxKGPXr0qN/vJ0mSpqn0RzuU//Wu9MoyPqxmtqmXJYwxxpiAQzBF4x8/fiyN4XDYoZLA5LfEhtg0+glMIGZY6wABMMbs4CaiR8brkYIDwGg00uuEMUTQ1MYqPBRRYZjZ+q42nxEsaYiV5VOapkmSSLvX62VZprUyM0DiQACIGLCAESIAEINAAAEOcQdD4a+2FJqmhDd/YEVkMpmEtrU2igCocNHW13swRBQYcl0enxbHpzEhKo0xSZJEgLIsC4Q5HJaJ2Qg7kKBjwMJyCDciBBcw7fjSO4tQapdi5vF43IZ+cnISdh9Y0At2RoZWFNtLsxr8N6CUTgCaHq3g+Pg4TVO1FACSaDLmgMhYC8sEQzCu3/mQjNEMSTvoDs4b+nXny5cvo4lBJpNJmKj9z81VrtNhikCgTsRRfAklmurxeKx9JZIsy548eeITKJgAQwzXJlhDTAwDgrXkxxCD2GfqgEPa4rnBOlApFUC/39fR1CmTyWQwGAQrR8TonMRNjjYpTmPSmUnC8ODgQHqSJDk7O9uNBkCv15tOp4eHh8SQgBICiCGu49YnSUJOiLGJcG2ydmdwnRcvXuwwlpYkSabTaZS1vyimc7R2Se16z58/f/jw4Z5LA8iy7NmzZ8J76CQ25F2UGsEAJjxo5194q0fn9unp6fHx8f5oRCQ1nJ+fbxtA3HAjAmCMCaGuAQWgh4eH0+k0y7LGvPiU3CVXV1fz+by+WQkCJYaImKzL6S' +
            'EN6uMpjBVMg8FgOp3GfnNPQADqup79MLv59AlWn75E/vAlf20ibmWg0Pn06dPJZNLr9e6nfLu8//Ahv/gFAEdcWEsgZnYpR3uM9KRpOplMGmb6SlLX9Ww2q29WyjH8+SI+pD0GQJIkJycn/8J/I4mWjaQoijzPb25uJJsjmAwqprIsG4/HbVZ2L/1fpCiKoijKqgTRBlCWZcPhcDQafUVfuZfUdb1cLpfL5cePf9Lr16/3zLz/g9T1quNy+F2FiYjSNB0Oh8Ph8HtRtV6vi6JYLpdVVbmb8t3dnSAbjUbRNfmbSlmWeZ6XHytEUQafEo0xR0dHUdjvG2X3Sd/Fb0We56t6BX8l2mTq6BCVnqOjo7Ozs29hRGGlqqrOr40CIKqeiGg8Hn/xcri/rG/XeZ7/evnrjjGbC3V05YC/BSRJ8urVq36/3zX7Hjaq63o+n19fX/upUqe5VxFok7UBtQ+T6XQ6GAz2Vd6Ssizn8/nt7a3ay1ZAYbMN520XkKenpx0B2E2SLOo+FEWxWPwMgMnC3/adejZMYLLS42r7oH4LGodpsVgURdHQuIcURbFYLDYlVKg9sCk5wpWNiHym9pUAEQGG6EAqSxhilRQWi0VZVmrz23yI5cPV1dX5TwsmWGYrb2TW36OJGjdXhryKxEeHvjR2Fgzz+bu6XnVgaHEmXhytEK0W1aUADJPjAL6CtPZv5rsGSvUKtv7r8/zdj+v1uoOUpsxms7qunT6+g1/TvTQCxE6XR2kBqxjyZo6K66gsAXB1fZ3neQdJSvI8X61WpNaMWCFuKNrkGuGGmMm95fhpvPkn/f6lAgAuLy/LstyGpq7r9+8d4rAr443qaln/ehHt1siv3dvt2B/RDpJms5lGE62gEy9az0XGcQCK3DL4DTPr0pPZEjPAZVlusoCSoihWqzpCHy7ODRXhbUTJly9oDr4fKDaV9NZJUrszPOjsI0a/FzfwNt4eHH+BSyICqK7rqqo0u0VRrFYrid' +
            'yN87L3pBYf7qvq3wqc3DMldJmiK06pgi8uLqQjAAorRG+p+zLUxks+z7rOkOzlIUy8yrAcQFVV3a4/ywBPmJsVMcTM3l/h9xDlLga4I1PDGaD7UNBPuCKBleUfy2gd+DOrPWubGHJJyD+L+LCTjEXEgH//2uSxhu1/Xzocy+VSL+2cUhrqLVZ/jTYL0IMtQEklT3/iWCutzUljDDNXVSVHRFWW7SOtccHag6V/AF1/slVRyOkZAAAAAElFTkSuQmCC';
        const MR_BG_96_DATA = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAIAAABt+uBvAAAfrElEQVR4nJV9zXNc15Xf75zXIuBUjG45M7GyEahFTMhVMUEvhmQqGYJeRPTG1mokbUL5v5rsaM/CkjdDr4b2RqCnKga9iIHJwqCyMCgvbG/ibparBGjwzpnF+bjnvm7Q9isU2Hj93r3nno/f+bgfJOaZqg4EJfglSkSXMtLAKkRETKqqRMM4jmC1Z5hZVZEXEylUiYgAISKBf8sgiKoqDayqIkJEKBeRArh9++7BwcHn558/+8XRz//30cDDOI7WCxGBCYCIZL9EpKoKEKCqzFzpr09aCzZAb628DjAAggBin5UEBCPfuxcRiIpIG2+On8TuZ9Ot9eg+Pxt9+TkIIDBZL9lU/yLv7Czeeeedra2txWLxzv948KXtL9WxGWuS1HzRvlKAFDpKtm8yGMfRPmc7diVtRcA+8GEYGqMBEDEgIpcABKqkSiIMgYoIKQjCIACqojpmQ+v8IrUuRyVJ9pk2qY7Gpon0AIAAJoG+8Z/eaGQp9vb2UloCFRWI6igQJQWEmGbeCBGI7DMpjFpmBhPPBh/zbAATRCEKZSgn2UzEpGyM1iZCKEhBopzq54IiqGqaWw5VtXAkBl9V3dlUpG2iMD7Yncpcex7eIO/tfb3IDbu7u9kaFTv2Xpi1kMUAmJi5ERDWnZprJm/jomCohjJOlAsFATjJVcIwzFgZzNmKqIg29VNVIiW2RkLD1fGo2hoRQYhBAInAmBW/Z0SD9y9KCmJ9663dVB8o3n77bSJ7HUQ08EBEzMxGFyuxjyqErwLDt1FDpUzfBU6n2w6JYnRlrCCljpXMDFUEv9jZFhDoRAYo8jDwMBiVYcwAYI0Y7xuOAvW3KS0zM7NB5jAMwdPR/jSx77755ny+qGqytbV1/fr11Oscnph+a1PDqphErjnGqqp0eYfKlc1mIz4WdStxDWJms8+0II' +
            'TdyeWoY2sXgHFalQBiEClctswOBETqPlEASXAdxzGG5L7JsA/A/q1bQDEkAoAbN27kDbN6/1FVHSFjNyS3LKLmW1nVbd9NHsRwxBCoYaKqmpyUREl65IYzKDmaVo1iO0aEccHeGUdXnIo4CB+cdpfmrfHA5eVlEXvzdNd3dxtF4V/39/cFKujIJSIaWMmdReqFjGO2ZpaCUGRXc1COvIIOhbNL3acCQDb2Es5YtIIBI3SUgZw7Ah1VBKpQmH0RlCAQ81noVd16UnKMpOBa93twRbvx9t5ivnC1MQ4Rwaxsd7eyu36wUQzkxDMxmd9Rl6uxyaU+du6/sEBERkMrUmSgY97DyGN7pwlc4UqUuq1q0Cgi6LlrHtY0yNQnv5qMZ/23iHexf/OmhXr5ajZycHC/oklqsT1BAYK1lxy/RtCUNphW0uDCZUdJP3UBCgAwmEYVoiEBmyBEauFJ0w4JnGdWSvCHJHK5TimY3BW5hUqNnoxpNkYiWuzM927sdWakjUfXd3cX83mMzBVcRaAGgo0wOA5YvGZdiMjo5sZEA4NLMK2SKAZpumZDViWMgBjgFoHXq0p7YpberAgA5iC0iMgF7r4fKX/nZDSmqvfu3attrne0f+tWCsmxdhhSlao/yp5SkZkpoj6dtN/rshANptFVfZgtsHAJSKYmREqkDNWxSYM5GjWvpIAoGIJIgkR1lPBrEQCqQiwzM91G+ACGYLHz+q39W5UlTkC5c/f2nWvXrjnQBLKk3WlkdqRQESIGKPwdjxp4Fw4XmaVYKKUQqKE+GEqw4COIIZHwYqkpqtpsLeJOs50ItFpgYoJJL1Dl74lEoobLChbqARiGYX9/XzHV3OzU/tza2rp7925VE44rlcJlTi2VqcplXWeQMfVTmg63Cak+UIIXVQXzbHAzjywnHhsQTtSkoapE3GJiu6Tpp/VYs1PjkcHBl+c7+/v7BKoaQ2SOCCDNb27fuX1t65qJmgYWBIIw0eDphRJM8l' +
            'r426ROMABSQs3FwAB5EDMMM+ZZlXc+gprFQDnMm2salYFGdQEosU+2aFmuMdX+ybdM8kb3/YP788WihUONJiViTVgnbG9/6c7du0Q0ljCKIoJvFBY3VEU2USuQELdMkJhNhKZiGmlTY5CZTyZyImLGLlBNpRUikKmRB2/mHUM7Mj50iYWXcUMI6YmKBX47Ozs3b36jKg4oYgKFNUupWap3bt+Z7+xYDigiSiygcRyppNkM0lHM1ZICMjJUVCz4NtlbVcfZqgohHaEQwUgtlyoYJ9KKT6lKIpLp/LpbMV3wBKIm0OKZoaq/raOM/3qJgkQUEj44OLCRh4ynvjLU2f/c3tp68OBBakcx2FYkMDmJiNmIB3PULjT1j7ciQKnxXQ2UeBgYUHMzAEQvFSNYlYQwQFrEGVA1dE2IQERMAgMEYjCRDzPPKmX2+e0be/vfuBkKktgIoqaGwbMmmL29vTff3I1xewUqC0Cq5nOK6TFqrquqyqoOUi11hPnZsUV8FLHiQAxRRoG0asNExMNg+XdVv57TbQAWR4hLz6Dh0kJEVU0LB/BO6MJEObuakY2td3Hvfvfd7e1t6omMyAUAtBaOyxUm1hHfY5NbwBClC2Sg51qmYJANzx2JjtAxogZk7uspj3PNQx6DYCJmmmkEqESkKqZlKfaDeweL+VxrvFwGktwBoAnU4c4W88X9gwNS8TqBR+3+UGW4KQcR7GGyorcIhyKnETAzgxkDqZKKoZiqZNbUkm/K8K5wfRIUVAiotfcUiKpSqwB6Vqnq6PPVr3713r17zfLXL+rvR9ICdSC/ffvO7u51J52b+mdklLDNnNoRH/q6lUZoHmQjm2UmzUpGhElehIZ0fHE8F4XoQDOGFRXJ80e28iKrEmGQEYl/RMqzGZhFHC/mX955/72/s8jMR7+RR21U8bV9DA159913t7f/HdEAZVI2s4o40Avno14Gs9j9aY1CGth7nsjMEX+LYIQQKUcVqahAKkhyN0' +
            'EhYajoUfMpLWpwf+/Ba7mDg4OD+c7CzCgUr5MwjCkGF9IqCl0pjTBfLL77ne8YiQ0uu8C6hdfVRWRMv24Wlo4F9Gg+Q0RliqMRMdjT1fWYfKxCmDcBj1kAWADmwAYmZfMCYFXC3x7cu7l/s3aSvxQgTutWr5umi4sPYWoAsHdj787f3CZS1bFiykAzCBGxjKo0jIFKqqPIZdR61GZZmBkggM39JdYyD9mmiLAqVDDhKFFXh88Xwr6iqoQWQVRWpg4CgOj169cP7h1URdCsKJKDVGOcexxMwoCJur3zzjtvvvlmEWpTZx3B/BplfBQSjVG0cC+RyzNEbSqGzPtIiSnQziom7AVgcJ+2mYoSaPAqTxbx3PGJVtS3Mtt8/vr7f/felWijUFFMHFpGiRWzC2Db9f7777/++rwW5y/FFEqho1uHKBMDnGhrHj39jE8ujqqqIMdsq4VZENfGU6UBQGS0e7XMXJ9J866/VTNphkB3dnYePny4tbVV360aMf1btUEzrX3f5+vb29sPH364mM9TZw1rndpWq3HK1wsAOQoeuijRO7Q2lUSQDlut7mPqbNZYp5KJyGZfqjVx5Htl1ghgnr8+//B7Hy4WiylrvK3yO3lAoLCyyENexdT54vXvffi9+Zd3krzWPCmjhoJUw+6cNVNVUlYlJcEwad7wNN8n8vpGIr/VSqg9AAf5Rk1KI8DbMkVsb29/+DC4c7U77741gK55WSIRNXY2ZbTocbH44IMPtra2mNnTV3fBha/FRyNYv0mp1+4ARAOriAXDSqIK5kEtrFQwD5k0O/sJsNS5xARtxYUCTPPXd95/7/2v/sc3oo/SNSHgxP5qk/QETy+d1sI4f4DQyiB5RwFguVz94B9+sFwumVkuPd2hCBpVRxXYDGiUotlm7pQ8MRAoiAY0F6SjqcXANjBVtaUtEQwrs8fvlgTGMwT48pc6Z5D8ev311x9++HA+n1OIpDGIHEpy6M6g6uJTa6x8BlKrqC' +
            'O8WyffxrXVavXo0aPVapVZVap/zBrYSNtnJWmCV62fAZByA+nIGxiIUiBskYy7ZGtLCb5GoiS3KOoa3FkAJXGpHrrVEBUTPbcgsY83jF+K9dpspmz+13w+//Dhhzs7O4YGCYh1MqrhdLzV1i6VycUasvgaEcN80ybEjBUNHDBkDnxQ7bhjgsolI2+99dZ77723tbUVaw7Mhf8lFxUdydBR+/trPKJ4CsD5+fnHH398dnZm34dTK1ojwp57kJJHaomzFafYqoLD7Jqqyviv5iOTQV3oSMX02yxeV/S8fef2tx98GxvB7y+6NvJigkf9Y+Ytar+Hh4eHP3uao1ARtnRd1Tz1RschyGURREQDzVSViGeqHllVDVJV046CTVZAaBUr++e1115799139/b2/oIB/5nf+3dmlpFuxFfUMwW9ChyfHB8+fbparXzsANEACKACxxq7HD3JEk57nckKzRRrEOr0rk+o2qPsXPeyb/gvr5Ardnd3v/Pud82dV/q6QeJP8GjKkfyNeHddg9Y4st77arX64ccf/f73v4cID1CBxMIdtizMWSMI7xzYxMmBzFAasqShWdBd4uP2GoBr167dPzi4fefOnzvsyajSneczsAC8Wk7vuSjuqm7UoI3COPzZ039+eig2HUDwWg+8dgxEEkIWqDqDEJ6deDYQKcTr8LGMzCbsWwJBRKphVord3d3vfue788V8M3HNbVOSEXyJxyYMqhxZG2TXxeSP3g9ufHH1cvlPT56cnp5G+JmFSDe9EqmIGVchakDeyuds2seZyTyOl4AHkPOdnQcPvr1344ZFfH0E6ExxRhRV8BrN1CG194nR0qwW9BbDqdwpZjjVIwoaqvYRYKj0yeHy5UvYmuVSFOw6goeOnq/Nrr3WKo9j1ZqWyAhGAFuvbd+9e/f2ndvb29ubHA2Zs82eJpy6Mthr/KXmrjc/ENyZ3J+E6Y2hrsDEbfAnJ8efHD5dLpdMM1UFCW2EToB8RqPN0r' +
            'j9ZyUo37y2de3u3Tt3bt/1GOcV+l+tqR+AM+iqd5uou/rQn8GgK9halcsTDn9/uVwdnxwf//JfVqsVD6gFE9iyX26RdHPtlkZYSgHAErSdxfyb3/zm7dt/s7W1vWlkV4/zFWpy1firt9qoTVfx6CpyOvPsX1aAcHJ8cnh4uFqtmFnkkpkrr+CxDDvuGu6kHu2++ebBwf3d67vxKLDuNeqw1z3OVfHeK4Zn6sCEUcG2WGYtpvuL4tA1oytNOGT/6lenJycnn356CkDEc4OEFwJ7+AdAFbu71/f29m7d2u9UpoYnVw3sFXrRkRufuupUfEFrjVwdBF3ZC2LsiKrAelSl3TvM/Ic//OHs7Ozk5P+enZ3lYigzMWxtbb99Y+/69et7e3tXmhKV1oMEb4XNvF2DpgBUjSX5EP62Mah5/U2hzSsYtNFsJ8C0Rnx8pUmMmkmKrlarFy/Onj9//tvf/na5XNKd/3rnwTsPGgUdCnh+0cF87SZ1ta2gaBR2JE/AuwsCE8ZfwQWahpT55JW2TNMQqQ6qNexfhKQ6Mf/0pz/lO7dbKFwmgaxbLVyaEFy7105lJhFyzyqvJKxHwGVSrNKdXXR8mejZ5FnP4LXeL2sl2jYDiqmaYE0Tvjnxe/fuzba3m02VMnCIND53I6qmUc1nSjQBWise6WiNYi39IZEh6JtyhLLmuHZV9TRnIvF6amqngGZPhgzkAiZE+wbJpIrPzy/48OnTJpM1BEAKk6b369gmH6+6GXpBU4doItA11KgtaNPojV2o1yK5GW8PfOtXgE+17q7jo6NnRAN/5Stf+ev/8Fdf//rXd3enm0omUeYr/Nhffl0BORT68oqoEuXVDS5s7ZWNnNoI4UrnFxfPT391dnZ2enp6cXER6yBdD8fd3es3b+6/9dZb8/l8I+VY49qfc00z1Y6u9ac3RxUdmmn/cG1yveUJg7Sgftw8Pz8/Pjk+PX3+4uw3sdRHPZImanXZTMG+duNrt27t3/' +
            'jaXhJxZbmno6/knzUXWwvSYClSK25c4Yw6gIdepcSb4G/DY5PnCQDOzl4cPj08++zXICLL46XlsV6Trjuw/GJV1fmXF/fv379586bfs2nDnBhZj32ok0/mX5EuUoQejJgNmPJi3aP/ycG/ysSom0FC082Li4ufPzs6OTlZLpeAwFKuEcaNnA0lWxgdjQ0gYZBqrIwQArCzmO/v79+6ub9YLCpTYOFPDuwqkitY2AjDH13hl4IxtBbLKCZhgze6ITQl0HqmQoCen58/Ozo6Ojq6uDi3u5ZmCSmJTe359AQREc+GtqJFGSQQJfKikk2ejSrMvPPvv3z//v2b+zfTrVYoVcvjwoF0SlyVCx3FmxiU4fb6yHsG1cFr90wPN63li4vznx/9/Ojo6PKLL2SSmDIJKSuRwnbrkA9zKLPPZWrQ9gXaQit7wOrQO/Odb33rW9/4L9+oGjSpARGzqnS2UEOVdW5sMCKsffEnUKWZ/BXX6enzJz958vLlS1X1FQheWeS0GFtCZ3X3WIo5+KKY5stiupaI6opMz3GZANz4z1978ODBYrFoeUKfgmX9xW+/gkEbsXnCkbU7V3iM4v+K7qxWy398/Pizz36TrwwE9X3ABoheurcimRtXaJBnEiWf4GSQ1Wvd58XmGYQ23bt3r+1n2ui101w2lUr6Ofu+KDEpg1IkhH0jU/ZuigmPnh09fXp4fn6eKzU2XsoKUQjIdkBlyZVn4c/iVkxoxzrNXL9xOdb5eHvrjTfe+OCDDyp4b2SQm6F/bgtLu2pHA/5N0L0mgA0S6Rm0XC4f//jxixdnceNKBhGR2L567eaWYRoEoJ/0aK95Md+wRpQAHmw7kACggSG6WCwODg5u7u9vcM9XaRCF9+3jvaicYN15rcfWVzDIGz09ff74x48vLi4A9FseNzNLWZNB1KHqAIqDSMLq6mDK/pmOr6Q2ly+qqsMw/Le//e8H9w4azYRalNow9+AimUxaxCsVa9KR2/Kq0P' +
            'e4vcYz4MmTJ89+8YtCrU4MPKew2h0SU6QEk4yk850oWnmtk0EEjHmmi/VRS/q5CMaM8vr16++/957PeRBitdhVCzNcI7qAux+nZ4/UsQxTEXZQdH5+/tGPPn7x4oWq5GxwQQ+NhWXJoDjxhe2Ui6G0HBPWRCTSlpo7BCkTs+olgG4e0rkZGsfJaVLVxWLx8H8+XMznyEmFcCydEoW+ELKy8cqSGLCBy0hccxnYEqHly1UObxPuCMfydj91Bc2LDTSrs/CqI2EGYFMtmOx+S2VhSUZZ4u9QLQS2A1QEwM7O3BffrYWF6YIzBdkQ2uGK53WNWzViUl2ulo++/2i5XKLUQNOOTIQiYqbEakstxRb2JINIbXkU5wrGXGmPbAgZJdcVMOl3y0Ly/M3lWJ9VEkrTMJ84Qu0WW1MutfBV7dO3+ue7y5RTAf3d73//6PuPVqsl+c4aSiKnjdTRZgUvky3/t+zUj09TmjBFNcc5W31suyL8RCHKw3B8N81yufz7//X3v/vd79aGWWq36zqbVW2DHu0fs5ps7GktjdByufqHH/zgjy//qLEsNVdC2+4dKqXV2oCtb23jL1LPq+UZlUrPRAqDc7N0ZVY04SqtfpKJEuHi4vyjH320XC2nbGj+qTXXfdW7+ahBxsq9CMqT0cvl8tH3H33++YWI5BkYuTbQ9rvVrQGq+SFsIltTtYAmFwnDViSWJasEMCnn+o/c/7O+oc46U4UgVGno9GK1XD569Gi5XPYimVgdHGK1vFt4qCV8d0ii6JuwXK3MnAVj2TuWg9dRR49gYhE086BKNVMloE1Lw/fca9jWZJ10YAqocrrpZ2RYkQAUi7EZ2u78L1qtlo8ePfr88/PKlLoDeO3qgc9/ty4pC+SE8/PzR99/9PLly/SheS5FwWYQkc2419XubaRxpd1pH0O0fQwASGEnvqgqg9HtAnEzti0yOQoiUoIyUZyhkZdt0lwtlx9/9BEZpqjz28ZNayq5XpmncF' +
            'XFLJxzH/3wRy9Xf6y8HmjI0AwA0WDrEicupfQ2ilzqeGknGZF6WFwpKkd0qdoJQxOZNlQKh1/QqY1wcpiGxoJGIrx4cfbkyZP1Nifkls/Ni657Hvv+8PDwsxcv1llsM+vWRJtij73y651edeUzTCozbh5RMAqUZ4PtpFcdY3NGxKDEqcLKUKaBZmzbHdqPeZA2tl8cPXt+ejrhjmqBmG5uVpsfy3XVoYBQHP/yl08PnyLO74PFYoCq2lqvcpnDFekPb/SKDw2qJJ1c/SQT1VFVBlsK3JxixIe2/WCC9iJQ6jCrEqL98QLsx9IN7tmZ/vHx4+VyOZGSa3QN+Vro539NnOZqtfrZz35GsRLOVDt3E0a/1K3QoC4di3NrbPd4t0esrSVXEEFE2OM7AdFA4ExG1NYMeZ1ogLRtjxZIqCorsfp+USJqG/YNgFiVxM4bEugXX3zx+PHjwh7TIMkAoxO8OlxXL2aG98OPP1q+XNnhlVHbU8VIZPu8eojlmalJ4qwL2z2vY/BAea7MyGz5w8DMEWUrQCSxtb1qR9TSNFfJUnDHuCCSu+3HtSCgk7wSPvvss2fPnrW/C+iU9xqUhsdsPvjw6WGNP3PxYI58EkOPl7a6su2P7i9XpWyHSlo7jgrf9MJ22EoXCnpQBLYzUbrWc9QM2DlDMqqVckQYHnl5A/aGuK89PDy06JGyJOQA07kYNbCpnRKtVsunh/88EA/E0QsZPtr+2BybBXuqo51t1vsZCtJtpKNvs40f5pkveGYCD75OkcrG4Xq5JKk75mEiCe9U1SBIPaPoQIqIbLnkxcXF4x//GBQ1HXRtBkpXvrTf//Tkie10HscxZ2JUDZvrTrHkVAviaqSS4p1koFouS/dlHNk2/ChBMJop+k876ETJjpKFxQm2J3qwmDsxi5RFkpUAQCqx9wgqlyFJefHrs+enzwGN0zO7ALlX0XYdnxx/+umnNEQXwyw5q6o0wE5wycsLOHYOCakhDhHleY' +
            'l+PlnQ7D9gUX/G9rt2WpMMrla9LoHq3aoEXC6bAmWeDRqbEYnoyZMn5+clvHY3EcoySU0IAA4/+aSBURwYpKWGV0liP/CttNLTHF4vM7/UJQGVPd0A2zG/REqkdi6inT4QN4nIj5AzjTBtyvOk1eq4QhAdiAEWOy3DXBwx+dFhY+44U8Ly5erZs6OOhZG71KSMfFETjk9OVqs/QuPssHIsj/q2d/LN3d6bbXGiyBNINY7osfMa1N8gZtsCh/YT3AQrnNNpqE2iVV9SPnX/Uy1RZ0K/rlP+LkesF/WaOvNL7Jm69vhj7S2Xq6dPn5psiwV1dfjCL53NZgapWYGwr7rTZXoie4WX2jjXpzUOJwzAUyUZ9dJ0x2S1TpOI5L4FirMw86AuWPBZKl7G988vzn9+dGQG1ZG9hkLHx79cLv+/siprFKFaO86XEYhzPBKnS17aVMPxxVro9mQ0r+L+SkeCdBhERDU7GwbWmKrLYwZrpBCPDQlSE1fIE9nUkA84enbUIdHkCh6d/Mux1vSvBPf5mW2XUwQ1Odqr9LoqeK24Z+SVLbTxiHSFIiWMowBkx1dmKXNUyd0L1p4hgB/22icc4eDayKwr1ZGBL87PjwyJJl6rGNrxyfFqtWImUmYvALIhZh9JiOrY7acFkba9uDl7wxgMNEnZbFbgAbMQyI9pkIx789gYSz1aME7M5Afx+AL9DZYfR12lrDJCSe5svPKb4+NjoAt2Jn8eHh5WfcmcK1WDqK3+Sl02SiZHLayTRJlzAwrGpm85lMrYDFX4nP5ovPAT4jTP/kIjCAZAZZ6kqnRV2u6ID3CcKc4vly9fnL3oyon+Mgg4PT19+XIVMS6SNZE65MYJrsgdWqyqY0bYSR5EGWTxkZNqft1nt9rJs65B9kdh9rQqmNdEbtXOq21TXwN2ppe0oz4J4JNPPuk1p0XVx8fH6TRblWf0//7AQJB51o7RXkvNxnL8Y3XKG7V7ctOMI3IQ0ZhBHcAzRV' +
            'ffWX/Z74jmUXTrWFjY5xFtHMLWziFSwovffHZ+cR4ZmbMGhOVydfr/Ts1DEClIBaPIZZFfqFU4xzykzjggInZOq/HOUQk6qV4nUJLC4MlwygWAUB8ugOLlPO6CgGwxFSo9yEQyhcrW/bpw0iKOT46zn+AQXrx4kTcA+LKuiVeMRLQ5nYghM5LOqvNGEebYs5HJk8FysjMiRxHBCBKCHUQIAH7y+ERFs3UpR20nFjYbDIBnxH9+ArZKQtJ6evo8JZpx0Mnx/4Hk+fmceUGG4wz1gmHQlrGPqsLOktI4KiKQiJllHHWU/CFVHS8l0heL4DJA4RSy/VscZ5V2A51kSnLBGjUFro4jPgAS/jGqSxM3d3Z2dn5+UaeqV6vl2dlZfdi/KuR5Hk1NHimk6jqqXsOKpakvDg5O8ETq4cVKZEl21LglbDqa9O0ANCOl7vSdzWZZu0SEHhmJ+JKPPINXAIniKwXeNBPW0+e/qkHlr399FosuOs/o+Q3Zrv8WYRANFHBhg7RgbRgGK/INQwisnAOJQC6jqtkBtUUZXcmiqFLnsCYHu6U2orr52NTpZxFwpyP5n3mkVKuSEuHs12f1zumnz52zExQzhBRHfrMA0qYmteWkTbU7T7o9Foe4V12bqN5MR2Do4y772ghXVgiYRUfyVRCggWNWgDRiVq0g2tkp217+MtfsJ+ygDOn09LQG0L/77W+pLSrxBIIpAMGgnAReEgUgtovFqLLsUMNSfAkCQ3IFK1GS6px3LhtIj83iiHydXWVt8wHBzDijwqcE8j9eco+WI1ZLm6zM7RP2Whxfrzit34svzn/ykyfLPyzPz8+f/OTJ6uVLNLrF9qsbd2owXSWan6U73q47YXrioeqVEF4fBvBvwZvfB2giLLAAAAAASUVORK5CYII=';

        // Core Constants
        const MR_ALPHA_THRESHOLD = 0.001;
        const MR_MAX_ALPHA = 0.99;
        const MR_LOGO_VALUE = 255;

        // Assets and Engine
        class GeminiWatermarkEngine {
            constructor(bg48, bg96) {
                this.bg48 = bg48;
                this.bg96 = bg96;
                this.alphaMaps = {};
            }

            static async create() {
                const loadImg = (dataUrl) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`ç„¡æ³•è§£æèƒŒæ™¯æ•¸æ“š`));
                    img.src = dataUrl;
                });
                const [bg48, bg96] = await Promise.all([loadImg(MR_BG_48_DATA), loadImg(MR_BG_96_DATA)]);
                return new GeminiWatermarkEngine(bg48, bg96);
            }

            async getAlphaMap(size) {
                if (this.alphaMaps[size]) return this.alphaMaps[size];
                const bgImage = size === 48 ? this.bg48 : this.bg96;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(bgImage, 0, 0);
                const data = ctx.getImageData(0, 0, size, size).data;
                const alphaMap = new Float32Array(size * size);
                for (let i = 0; i < alphaMap.length; i++) {
                    alphaMap[i] = Math.max(data[i * 4], data[i * 4 + 1], data[i * 4 + 2]) / 255.0;
                }
                this.alphaMaps[size] = alphaMap;
                return alphaMap;
            }

            detectConfig(w, h) {
                return (w > 1024 && h > 1024) ? { size: 96, mr: 64, mb: 64 } : { size: 48, mr: 32, mb: 32 };
            }

            async removeWatermark(canvas) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const config = this.detectConfig(w, h);
                const alphaMap = await this.getAlphaMap(config.size);
                const imgData = ctx.getImageData(0, 0, w, h);

                const startX = w - config.mr - config.size;
                const startY = h - config.mb - config.size;

                for (let row = 0; row < config.size; row++) {
                    for (let col = 0; col < config.size; col++) {
                        const imgIdx = ((startY + row) * w + (startX + col)) * 4;
                        const alphaIdx = row * config.size + col;
                        let alpha = alphaMap[alphaIdx];
                        if (alpha < MR_ALPHA_THRESHOLD) continue;
                        alpha = Math.min(alpha, MR_MAX_ALPHA);
                        const oneMinusAlpha = 1.0 - alpha;
                        for (let c = 0; c < 3; c++) {
                            const val = imgData.data[imgIdx + c];
                            const original = (val - alpha * MR_LOGO_VALUE) / oneMinusAlpha;
                            imgData.data[imgIdx + c] = Math.max(0, Math.min(255, Math.round(original)));
                        }
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            }
        }

        // Image Upscaler logic
        async function mrConditionalUpscale(image) {
            const w = image.width;
            const h = image.height;
            const ratio = w / h;
            let targetW = w, targetH = h;
            let upscaled = false;

            const is4_3 = Math.abs(ratio - 4 / 3) < 0.05 || Math.abs(ratio - 3 / 4) < 0.05;
            const is16_9 = Math.abs(ratio - 16 / 9) < 0.05 || Math.abs(ratio - 9 / 16) < 0.05;

            if (is4_3 && Math.max(w, h) < 2400) {
                const scale = 2400 / Math.max(w, h);
                targetW = Math.round(w * scale);
                targetH = Math.round(h * scale);
                upscaled = true;
            } else if (is16_9 && Math.max(w, h) < 1376) {
                const scale = 1376 / Math.max(w, h);
                targetW = Math.round(w * scale);
                targetH = Math.round(h * scale);
                upscaled = true;
            }

            const canvas = document.createElement('canvas');
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(image, 0, 0, targetW, targetH);
            return { canvas, upscaled };
        }

        // Flood Fill
        function mrFloodFill(data, maskData, x, y, width, height, tolerance, r, g, b, a) {
            const stack = [[x, y]];
            const startIdx = (y * width + x) * 4;
            const startR = data[startIdx], startG = data[startIdx + 1], startB = data[startIdx + 2];
            const visited = new Uint8Array(width * height);

            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const idx = cy * width + cx;
                if (visited[idx]) continue;
                visited[idx] = 1;

                const pIdx = idx * 4;
                const dr = data[pIdx] - startR, dg = data[pIdx + 1] - startG, db = data[pIdx + 2] - startB;
                if (Math.sqrt(dr * dr + dg * dg + db * db) <= tolerance) {
                    maskData[pIdx] = r; maskData[pIdx + 1] = g; maskData[pIdx + 2] = b; maskData[pIdx + 3] = a;
                    if (cx > 0) stack.push([cx - 1, cy]);
                    if (cx < width - 1) stack.push([cx + 1, cy]);
                    if (cy > 0) stack.push([cx, cy - 1]);
                    if (cy < height - 1) stack.push([cx, cy + 1]);
                }
            }
        }

        // Inpainting (simplified patch-based)
        async function mrInpaint(ctx, maskCtx, width, height, onProgress) {
            const imgData = ctx.getImageData(0, 0, width, height);
            const maskData = maskCtx.getImageData(0, 0, width, height);
            const pixels = imgData.data;
            let isMasked = new Uint8Array(width * height);
            let maskedCount = 0;

            for (let i = 0; i < width * height; i++) {
                if (maskData.data[i * 4 + 3] > 50) { isMasked[i] = 1; maskedCount++; }
            }

            // Start with mask dilation to cover edges
            const dilatedMask = new Uint8Array(width * height);
            const dilationRadius = 2; // Expand mask by 2px
            maskedCount = 0; // Recount after dilation

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (isMasked[idx] === 1) {
                        dilatedMask[idx] = 1;
                        maskedCount++;
                        continue;
                    }
                    // Check neighbors
                    let isNearMask = false;
                    checkNeighbor:
                    for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                        for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                            const ny = y + dy, nx = x + dx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                if (isMasked[ny * width + nx] === 1) {
                                    isNearMask = true;
                                    break checkNeighbor;
                                }
                            }
                        }
                    }
                    if (isNearMask) {
                        dilatedMask[idx] = 1;
                        maskedCount++;
                    }
                }
            }
            isMasked = dilatedMask; // Use dilated mask for processing

            console.log(`[Inpaint Debug] Masked Pixels: ${maskedCount}`);
            if (maskedCount === 0) {
                alert("éŒ¯èª¤ï¼šæ²’æœ‰æª¢æ¸¬åˆ°é¸å–ç¯„åœï¼è«‹ç¢ºä¿æ‚¨å·²ç¶“ä½¿ç”¨é­”æ³•æ£’åœˆé¸äº†æµ®æ°´å°ã€‚");
                return;
            }

            const initialCount = maskedCount;
            const patchRadius = 3;
            // Limit search radius to improve speed/relevance
            const searchRadius = Math.min(Math.min(width, height) / 2, 200);

            while (maskedCount > 0) {
                const contour = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        if (isMasked[idx] === 1) {
                            if ((x > 0 && isMasked[idx - 1] === 0) || (x < width - 1 && isMasked[idx + 1] === 0) ||
                                (y > 0 && isMasked[idx - width] === 0) || (y < height - 1 && isMasked[idx + width] === 0)) {
                                contour.push({ x, y });
                            }
                        }
                    }
                }
                if (contour.length === 0) break;

                for (const p of contour) {
                    let bestScore = Infinity;
                    let bR = 0, bG = 0, bB = 0;

                    // Increased sampling for better quality (15 -> 50)
                    // If still poor, we can go higher, but 50 is a good balance for browser JS
                    for (let s = 0; s < 50; s++) {
                        const a = Math.random() * Math.PI * 2;
                        const d = Math.random() * searchRadius;
                        const sx = Math.floor(p.x + Math.cos(a) * d), sy = Math.floor(p.y + Math.sin(a) * d);
                        if (sx < patchRadius || sx >= width - patchRadius || sy < patchRadius || sy >= height - patchRadius) continue;
                        if (isMasked[sy * width + sx] === 1) continue;

                        let score = 0;
                        let validPixels = 0;
                        for (let py = -patchRadius; py <= patchRadius; py += 2) {
                            for (let px = -patchRadius; px <= patchRadius; px += 2) {
                                // Target pixel coordinates relative to P (boundary point)
                                const ty = p.y + py;
                                const tx = p.x + px;

                                // Source pixel coordinates relative to S (search point)
                                const sy_ = sy + py;
                                const sx_ = sx + px;

                                // Bounds check for target
                                if (tx < 0 || tx >= width || ty < 0 || ty >= height) continue;

                                // KEY FIX: Only compare against known pixels (unmasked)
                                // If target pixel is masked (part of watermark), we don't know its color, so skip it.
                                if (isMasked[ty * width + tx] === 1) continue;

                                const sIdx = (sy_ * width + sx_) * 4;
                                const tIdx = (ty * width + tx) * 4;

                                const dr = pixels[tIdx] - pixels[sIdx];
                                const dg = pixels[tIdx + 1] - pixels[sIdx + 1];
                                const db = pixels[tIdx + 2] - pixels[sIdx + 2];
                                score += dr * dr + dg * dg + db * db;
                                validPixels++;
                            }
                        }
                        // Normalize score by valid pixels to allow fair comparison
                        if (validPixels > 0) {
                            score /= validPixels;
                        } else {
                            score = Infinity; // No valid matching context
                        }
                        if (score < bestScore) { bestScore = score; const idx = (sy * width + sx) * 4; bR = pixels[idx]; bG = pixels[idx + 1]; bB = pixels[idx + 2]; }
                    }
                    if (bestScore !== Infinity) {
                        const idx = (p.y * width + p.x) * 4; pixels[idx] = bR; pixels[idx + 1] = bG; pixels[idx + 2] = bB;
                        isMasked[p.y * width + p.x] = 0; maskedCount--;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                onProgress(Math.round(((initialCount - maskedCount) / initialCount) * 100));
                await new Promise(r => setTimeout(r, 0));
            }
        }

        function mrRefreshCanvas() {
            if (!mrOriginalImage) return;
            const wrap = document.getElementById('mrCanvasWrapper');
            const inner = document.getElementById('mrCanvasInner');
            const empty = document.getElementById('mrEmptyState');

            empty.style.display = 'none';
            inner.style.display = 'inline-block'; // Allow wrapper to shrink to fit content
            mrCurrentCanvas.style.display = 'block';

            // Always redraw original image to ensure we have a clean state (Undo/Reset logic)
            mrCurrentCanvas.width = mrOriginalImage.width;
            mrCurrentCanvas.height = mrOriginalImage.height;
            const ctx = mrCurrentCanvas.getContext('2d');
            ctx.drawImage(mrOriginalImage, 0, 0);

            if (!mrMaskCanvas) {
                mrMaskCanvas = document.createElement('canvas');
                mrMaskCanvas.id = 'mrMaskCanvas';
                inner.appendChild(mrMaskCanvas); // Append to INNER wrapper
                mrMaskCanvas.style.position = 'absolute';
                mrMaskCanvas.style.top = '0';
                mrMaskCanvas.style.left = '0';
                mrMaskCanvas.style.width = '100%'; // Match rendered size of mrCanvas
                mrMaskCanvas.style.height = '100%';
                mrMaskCanvas.style.pointerEvents = 'none'; // Click-through
                mrMaskCanvas.width = mrCurrentCanvas.width;
                mrMaskCanvas.height = mrCurrentCanvas.height;

                // Event Handling
                mrCurrentCanvas.addEventListener('mousedown', (e) => {
                    if (mrIsProcessing || document.getElementById('mrGeminiMode').checked) return;
                    const rect = mrCurrentCanvas.getBoundingClientRect();
                    const scale = mrCurrentCanvas.width / rect.width;
                    const x = Math.floor((e.clientX - rect.left) * scale);
                    const y = Math.floor((e.clientY - rect.top) * scale);

                    const ctx = mrCurrentCanvas.getContext('2d');
                    const mCtx = mrMaskCanvas.getContext('2d');
                    const imgData = ctx.getImageData(0, 0, mrCurrentCanvas.width, mrCurrentCanvas.height);
                    const mData = mCtx.getImageData(0, 0, mrMaskCanvas.width, mrMaskCanvas.height);

                    const tol = parseInt(document.getElementById('mrBrushSize').value);
                    mrFloodFill(imgData.data, mData.data, x, y, mrCurrentCanvas.width, mrCurrentCanvas.height, tol, 255, 0, 0, 150);
                    mCtx.putImageData(mData, 0, 0);
                    mrAddToHistory();
                });
            }

            // Always update mask canvas size to match current image
            if (mrMaskCanvas) {
                mrMaskCanvas.width = mrCurrentCanvas.width;
                mrMaskCanvas.height = mrCurrentCanvas.height;
            }
            mrUpdateButtons();
        }

        function mrUpdateButtons() {
            const hasImg = !!mrOriginalImage;
            document.getElementById('mrProcessBtn').disabled = !hasImg || mrIsProcessing;
            document.getElementById('mrDownloadBtn').disabled = !hasImg || mrIsProcessing;
            const oneClickBtn = document.getElementById('mrOneClickBtn');
            if (oneClickBtn) oneClickBtn.disabled = !hasImg || mrIsProcessing;
            document.getElementById('mrBrushSizeGroup').style.display = document.getElementById('mrGeminiMode').checked ? 'none' : 'block';
        }

        function mrAddToHistory() {
            const ctx = mrCurrentCanvas.getContext('2d');
            const mCtx = mrMaskCanvas.getContext('2d');
            const state = {
                img: ctx.getImageData(0, 0, mrCurrentCanvas.width, mrCurrentCanvas.height),
                mask: mCtx.getImageData(0, 0, mrMaskCanvas.width, mrMaskCanvas.height)
            };
            mrHistory = mrHistory.slice(0, mrHistoryIndex + 1);
            mrHistory.push(state);
            mrHistoryIndex++;
        }

        // External Hook for file upload
        window.mrLoadImage = async (file) => {
            const img = new Image();
            const reader = new FileReader();
            const dataUrl = await new Promise((resolve) => {
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            img.src = dataUrl;
            await new Promise(r => img.onload = r);

            mrOriginalImage = img;

            // Critical: Reset History and State when loading new image
            mrHistory = [];
            mrHistoryIndex = -1;
            mrIsProcessing = false;

            mrCurrentCanvas.width = 0; // Trigger redraw
            setMode('magicRemover');
            mrRefreshCanvas();
        };

        // Event Listeners Initialization
        document.getElementById('mrGeminiMode').addEventListener('change', mrUpdateButtons);
        document.getElementById('mrBrushSize').addEventListener('input', (e) => document.getElementById('mrBrushSizeVal').textContent = e.target.value);

        // New UI Event Listeners
        const mrFileInput = document.getElementById('mrFileInput');
        const mrEmptyState = document.getElementById('mrEmptyState');
        const mrCloseBtn = document.getElementById('mrCloseBtn');

        mrEmptyState.addEventListener('click', () => mrFileInput.click());
        mrFileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                mrLoadImage(e.target.files[0]);
                mrFileInput.value = ''; // Reset input to allow re-selecting same file
            }
        });

        // Use same reset logic for Close Button
        const mrPerformReset = () => {
            mrOriginalImage = null;
            mrHistory = [];
            mrHistoryIndex = -1;
            mrIsProcessing = false;

            mrEmptyState.style.display = 'flex'; // Use flex to center content
            document.getElementById('mrCanvasInner').style.display = 'none';
            document.getElementById('mrCanvas').style.display = 'none';

            if (mrMaskCanvas) {
                const mCtx = mrMaskCanvas.getContext('2d');
                mCtx.clearRect(0, 0, mrMaskCanvas.width, mrMaskCanvas.height);
            }

            mrUpdateButtons();
        };

        mrCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent bubbling if needed
            mrPerformReset();
        });

        // Reset/Undo Button Logic
        document.getElementById('mrResetImageBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('ç¢ºå®šè¦å¾©åŸåˆ°åˆå§‹ç‹€æ…‹å—ï¼Ÿ(ç›®å‰çš„ç·¨è¼¯å°‡æœƒéºå¤±)')) {
                mrRefreshCanvas(); // Re-draws original image and clears mask
            }
        });

        // Loophole: We removed mrResetBtn/Undo/Clear from DOM. 
        // If we want to support Undo/Clear in the future, we need to add them back to UI.
        // For now, we remove the listeners to avoid errors.

        // Batch Mode Logic
        const mrBatchMode = document.getElementById('mrBatchMode');
        const mrBatchContainer = document.getElementById('mrBatchContainer');
        const mrCanvasWrapper = document.getElementById('mrCanvasWrapper');
        const mrBatchInput = document.getElementById('mrBatchInput');
        const mrBatchDropZone = document.getElementById('mrBatchDropZone');
        const mrBatchStartBtn = document.getElementById('mrBatchStartBtn');
        const mrBatchDownloadBtn = document.getElementById('mrBatchDownloadBtn');
        const mrBatchClearBtn = document.getElementById('mrBatchClearBtn');

        // Batch File Handling
        window.updateBatchStats = () => {
            const files = window.mrBatchFiles || [];
            document.getElementById('mrBatchTotalCount').textContent = files.length;
            mrBatchStartBtn.disabled = files.length === 0 || mrIsProcessing;
            mrBatchDownloadBtn.disabled = true;
        };

        window.updateBatchStats(); // Init

        mrBatchMode.addEventListener('change', (e) => {
            const isBatch = e.target.checked;
            mrBatchContainer.style.display = isBatch ? 'block' : 'none';
            mrCanvasWrapper.style.display = isBatch ? 'none' : 'flex';

            // Disable Single Image controls in Batch Mode
            document.getElementById('mrProcessBtn').parentElement.style.display = isBatch ? 'none' : 'flex';

            // Auto-check Gemini mode when entering Batch, but don't disable (allow interaction for feedback)
            if (isBatch) {
                document.getElementById('mrGeminiMode').checked = true;
                mrUpdateButtons();
            }
        });

        // Enforce Gemini Mode in Batch with Feedback
        document.getElementById('mrGeminiMode').addEventListener('click', (e) => {
            if (document.getElementById('mrBatchMode').checked && !e.target.checked) {
                // User tried to uncheck Gemini while in Batch
                e.preventDefault(); // Prevent unchecking if possible (click event)
                e.target.checked = true; // Force back
                alert("ç›®å‰ã€Œæ‰¹æ¬¡è™•ç†ã€åƒ…æ”¯æ´ Gemini å°ˆç”¨æ¨¡å¼ï¼Œç„¡æ³•åˆ‡æ›è‡³èˆŠç‰ˆæ¼”ç®—æ³•ã€‚");
            }
        });

        // Batch File Handling
        window.renderBatchList = () => {
            mrBatchDropZone.innerHTML = '';
            const files = window.mrBatchFiles || [];

            if (files.length === 0) {
                // Empty State
                mrBatchDropZone.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.8; margin-bottom: 15px;">ğŸ“¤</div>
                    <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 8px;">æ‹–æ”¾åœ–ç‰‡åˆ°æ­¤è™•</div>
                    <div style="opacity: 0.8; font-size: 0.9rem;">æˆ–é»æ“Šå·¦å´ã€Œé¸æ“‡åœ–ç‰‡ã€æŒ‰éˆ•ä¸Šå‚³</div>
                    <div style="opacity: 0.6; font-size: 0.8rem; margin-top: 5px;">æ”¯æ´ PNGã€JPG æ ¼å¼ï¼Œå¯ä¸€æ¬¡ä¸Šå‚³å¤šå¼µ</div>
                 `;
                mrBatchDropZone.style.display = 'flex';
                mrBatchDropZone.className = '';
            } else {
                // Grid State
                mrBatchDropZone.style.display = 'block';
                const grid = document.createElement('div');
                grid.className = 'mr-batch-grid';

                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'mr-batch-item';
                    item.id = `batch-item-${index}`;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = item.querySelector('img');
                        if (img) img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);

                    item.innerHTML = `
                        <img src="" alt="preview">
                        <span class="mr-batch-badge" id="badge-${index}">ç­‰å¾…ä¸­</span>
                        <div class="mr-batch-delete" onclick="removeBatchFile(${index})">âœ•</div>
                     `;
                    grid.appendChild(item);
                });
                mrBatchDropZone.appendChild(grid);
            }
        };

        // Global function for inline onclick
        window.removeBatchFile = (index) => {
            if (mrIsProcessing) return;
            if (window.mrBatchFiles) {
                window.mrBatchFiles.splice(index, 1);
                window.updateBatchStats();
                window.renderBatchList();
            }
        };

        // Global mrBatchFiles to prevent scope issues
        window.mrBatchFiles = window.mrBatchFiles || [];

        // Handle File Input Selection
        mrBatchInput.addEventListener('change', (e) => {
            const files = e.target.files;

            try {
                if (files && files.length > 0) {
                    const newFiles = Array.from(files);

                    // Use global variable
                    window.mrBatchFiles = [...window.mrBatchFiles, ...newFiles];

                    window.updateBatchStats();
                    window.renderBatchList();
                }
            } catch (err) {
                alert("Error: " + err.message);
            } finally {
                mrBatchInput.value = '';
            }
        });

        // Batch Drag and Drop Implementation
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            mrBatchDropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        mrBatchDropZone.addEventListener('dragover', () => {
            mrBatchDropZone.style.background = 'rgba(255,255,255,0.1)';
            mrBatchDropZone.style.border = '2px dashed #fff';
        });

        mrBatchDropZone.addEventListener('dragleave', () => {
            mrBatchDropZone.style.background = 'transparent';
            mrBatchDropZone.style.border = '2px dashed rgba(255,255,255,0.3)';
        });

        mrBatchDropZone.addEventListener('drop', (e) => {
            mrBatchDropZone.style.background = 'transparent';
            mrBatchDropZone.style.border = '2px dashed rgba(255,255,255,0.3)';

            const dt = e.dataTransfer;
            const files = dt.files;

            if (files && files.length > 0) {
                // Filter only images
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (imageFiles.length > 0) {
                    window.mrBatchFiles = [...window.mrBatchFiles, ...imageFiles];
                    window.updateBatchStats();
                    window.renderBatchList();
                } else {
                    alert("è«‹åªæ‹–æ”¾åœ–ç‰‡æª”æ¡ˆ (JPG, PNG)");
                }
            }
        });

        mrBatchClearBtn.addEventListener('click', () => {
            window.mrBatchFiles = [];
            window.updateBatchStats();
            window.renderBatchList();
            document.getElementById('mrBatchProcessedCount').textContent = 0;
            document.getElementById('mrBatchSuccessCount').textContent = 0;
        });

        // Batch Processing Logic with JSZip
        window.mrBatchZip = null;

        // Global V3 Batch Handler - Cache Buster
        window.mrStartBatchV3 = async () => {
            const files = window.mrBatchFiles || [];
            if (mrIsProcessing || files.length === 0) return;

            mrIsProcessing = true;
            mrBatchStartBtn.disabled = true;
            mrBatchDownloadBtn.disabled = true;
            window.mrBatchZip = new JSZip();

            let processed = 0;
            let success = 0;
            const total = files.length;

            if (!mrEngine) {
                try {
                    mrEngine = await GeminiWatermarkEngine.create();
                } catch (e) {
                    alert("å¼•æ“åˆå§‹åŒ–å¤±æ•—: " + e.message);
                    mrIsProcessing = false;
                    window.updateBatchStats();
                    return;
                }
            }

            // Safe Timestamp
            const now = new Date();
            const pad = (n) => n.toString().padStart(2, '0');
            const batchTimestamp = now.getFullYear() +
                pad(now.getMonth() + 1) +
                pad(now.getDate()) +
                pad(now.getHours()) +
                pad(now.getMinutes()) +
                pad(now.getSeconds());

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const badge = document.getElementById(`badge-${i}`);
                if (badge) {
                    badge.textContent = "è™•ç†ä¸­...";
                    badge.style.background = "#ed8936";
                }

                try {
                    processed++;
                    document.getElementById('mrBatchProcessedCount').textContent = `${processed} / ${total}`;

                    const img = new Image();
                    const reader = new FileReader();
                    const dataUrl = await new Promise((resolve) => {
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });
                    img.src = dataUrl;
                    await new Promise(r => img.onload = r);

                    const { canvas } = await mrConditionalUpscale(img);
                    await mrEngine.removeWatermark(canvas);

                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));

                    // V3 Naming
                    const seq = (i + 1).toString().padStart(3, '0');
                    const fileName = `Waterremove${batchTimestamp}_${seq}.jpg`;

                    window.mrBatchZip.file(fileName, blob);

                    success++;
                    document.getElementById('mrBatchSuccessCount').textContent = success;

                    if (badge) {
                        badge.textContent = "å®Œæˆ";
                        badge.className = "mr-batch-badge success";
                    }
                } catch (err) {
                    console.error(err);
                    if (badge) {
                        badge.textContent = "å¤±æ•—";
                        badge.style.background = "#e53e3e";
                    }
                }
            }

            mrIsProcessing = false;
            window.updateBatchStats();
            mrBatchStartBtn.disabled = false;
            mrBatchDownloadBtn.disabled = false;
            alert("æ‰¹æ¬¡è™•ç†å®Œæˆ (V3-Final)ï¼è«‹é»æ“Šã€Œä¸‹è¼‰å…¨éƒ¨ã€æŒ‰éˆ•ã€‚");
        };

        // Aggressively assign onclick
        mrBatchStartBtn.removeEventListener('click', Object); // Try to clear old (symbolic)
        mrBatchStartBtn.onclick = window.mrStartBatchV3;
        console.log("V3 Batch Handler Attached");

        // Global Download Handler to bypass listener issues
        // Global Download Handler to bypass listener issues
        // Global Download Handler to bypass listener issues
        window.mrDownloadAll = () => {
            if (!window.mrBatchZip) {
                alert("éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°å£“ç¸®æª”ï¼Œè«‹å…ˆåŸ·è¡Œæ‰¹æ¬¡è™•ç†ã€‚");
                return;
            }

            const zipObj = window.mrBatchZip;
            const count = Object.keys(zipObj.files).length;

            if (count === 0) {
                alert("éŒ¯èª¤ï¼šå£“ç¸®æª”æ˜¯ç©ºçš„ï¼");
                return;
            }

            const btn = document.getElementById('mrBatchDownloadBtn');
            if (btn) btn.textContent = "â³ æ‰“åŒ…ä¸­...";

            zipObj.generateAsync({ type: "blob" }).then(function (content) {
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);

                // Format: WaterremoveYYYYMMDDHHmm
                const now = new Date();
                const pad = (n) => n.toString().padStart(2, '0');
                const timestamp = now.getFullYear() +
                    pad(now.getMonth() + 1) +
                    pad(now.getDate()) +
                    pad(now.getHours()) +
                    pad(now.getMinutes());

                link.download = `Waterremove${timestamp}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                if (btn) btn.textContent = "ğŸ“¥ ä¸‹è¼‰å…¨éƒ¨ (ZIP)";
            }).catch(function (err) {
                alert("ä¸‹è¼‰å¤±æ•—: " + err.message);
                if (btn) btn.textContent = "ğŸ“¥ ä¸‹è¼‰å…¨éƒ¨ (ZIP)";
            });
        };

        // Assign to button explicitly
        const dlBtn = document.getElementById('mrBatchDownloadBtn');
        if (dlBtn) {
            dlBtn.onclick = window.mrDownloadAll;
            console.log("Download handler attached via onclick");
        } else {
            console.error("Critical: mrBatchDownloadBtn not found");
        }

        document.getElementById('mrProcessBtn').addEventListener('click', async () => {
            if (mrIsProcessing || !mrOriginalImage) return;
            mrIsProcessing = true;
            mrUpdateButtons();

            const prog = document.getElementById('mrProgressContainer');
            const fill = document.getElementById('mrProgressFill');
            const val = document.getElementById('mrProgressVal');
            prog.style.display = 'block';

            const onProgress = (p) => { fill.style.width = p + '%'; val.textContent = p; };

            try {
                if (document.getElementById('mrGeminiMode').checked) {
                    onProgress(10);
                    if (!mrEngine) mrEngine = await GeminiWatermarkEngine.create();
                    onProgress(30);
                    const { canvas, upscaled } = await mrConditionalUpscale(mrOriginalImage);
                    onProgress(60);
                    await mrEngine.removeWatermark(canvas);
                    onProgress(100);

                    mrCurrentCanvas.width = canvas.width;
                    mrCurrentCanvas.height = canvas.height;
                    mrCurrentCanvas.getContext('2d').drawImage(canvas, 0, 0);
                } else {
                    const ctx = mrCurrentCanvas.getContext('2d');
                    const mCtx = mrMaskCanvas.getContext('2d');
                    await mrInpaint(ctx, mCtx, mrCurrentCanvas.width, mrCurrentCanvas.height, onProgress);
                    mCtx.clearRect(0, 0, mrMaskCanvas.width, mrMaskCanvas.height);
                }
                alert('è™•ç†å®Œæˆï¼');
            } catch (e) {
                alert('éŒ¯èª¤: ' + e.message);
            } finally {
                mrIsProcessing = false;
                mrUpdateButtons();
                setTimeout(() => prog.style.display = 'none', 2000);
            }
        });

        document.getElementById('mrDownloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'watermark_removed.jpg';
            link.href = mrCurrentCanvas.toDataURL('image/jpeg', 0.85);
            link.click();
        });

        /* =========================================
           End Magic Remover Logic (v2)
           ========================================= */

        /* =========================================
           HTML Cleaner Logic
           ========================================= */
        const cleanerInput = document.getElementById('cleanerInput');
        const cleanerOutput = document.getElementById('cleanerOutput');
        const cleanerRemovePath = document.getElementById('cleanerRemovePath');
        const cleanerRemoveIndex = document.getElementById('cleanerRemoveIndex');
        const cleanerNewAttr = document.getElementById('cleanerNewAttr');
        const cleanerAddAttrBtn = document.getElementById('cleanerAddAttrBtn');
        const cleanerAttrList = document.getElementById('cleanerAttrList');
        const cleanerNewTag = document.getElementById('cleanerNewTag');
        const cleanerAddTagBtn = document.getElementById('cleanerAddTagBtn');
        const cleanerTagList = document.getElementById('cleanerTagList');
        const cleanerClearBtn = document.getElementById('cleanerClearBtn');
        const cleanerUploadBtn = document.getElementById('cleanerUploadBtn');
        const cleanerFileInput = document.getElementById('cleanerFileInput');
        const cleanerDownloadBtn = document.getElementById('cleanerDownloadBtn');
        const cleanerCopyBtn = document.getElementById('cleanerCopyBtn');
        const cleanerAutocorrectPunct = document.getElementById('cleanerAutocorrectPunct');
        const cleanerAutocorrectSpace = document.getElementById('cleanerAutocorrectSpace');

        let cleanerOptions = {
            removeDataPathToNode: true,
            removeDataIndexInNode: true,
            autocorrectPunct: true,
            autocorrectSpace: true,
            customAttributes: [],
            customTags: []
        };

        function updateCleaner() {
            const html = cleanerInput.value;
            cleanerOptions.removeDataPathToNode = cleanerRemovePath.checked;
            cleanerOptions.removeDataIndexInNode = cleanerRemoveIndex.checked;
            cleanerOptions.autocorrectPunct = cleanerAutocorrectPunct.checked;
            cleanerOptions.autocorrectSpace = cleanerAutocorrectSpace.checked;
            const cleaned = cleanHtmlLogic(html, cleanerOptions);
            cleanerOutput.value = cleaned;
        }

        function cleanHtmlLogic(html, options) {
            if (!html) return "";
            const parser = new DOMParser();

            // å˜—è©¦è§£æ HTML
            let doc;
            try {
                doc = parser.parseFromString(html, "text/html");
            } catch (e) {
                console.error("HTML è§£æå¤±æ•—:", e);
                return html;
            }

            const walk = (node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node;

                    // ç§»é™¤å±¬æ€§
                    if (options.removeDataPathToNode) {
                        if (el.hasAttribute("data-path-to-node")) el.removeAttribute("data-path-to-node");
                    }
                    if (options.removeDataIndexInNode) {
                        if (el.hasAttribute("data-index-in-node")) el.removeAttribute("data-index-in-node");
                    }

                    options.customAttributes.forEach(rawAttr => {
                        if (!rawAttr) return;
                        const attrName = rawAttr.split('=')[0].trim();
                        if (attrName && el.hasAttribute(attrName)) el.removeAttribute(attrName);
                    });
                } else if (node.nodeType === Node.TEXT_NODE) {
                    let text = node.textContent;
                    if (options.autocorrectPunct) {
                        // 1. Temporarily replace URLs with placeholders to protect them
                        const urls = [];
                        const urlRegex = /((https?|ftp):\/\/[^\s/$.?#].[^\s]*)|(www\.[^\s/$.?#].[^\s]*)/gi;

                        text = text.replace(urlRegex, (match) => {
                            urls.push(match);
                            return `__URL_PLACEHOLDER_${urls.length - 1}__`;
                        });

                        // 2. Perform replacements
                        text = text.replace(/(?<!\d),|,(?!\d)/g, 'ï¼Œ')
                            .replace(/;/g, 'ï¼›')
                            .replace(/:/g, 'ï¼š')
                            .replace(/(?<!\d)\.|\.(?!\d)/g, 'ã€‚')
                            .replace(/\(/g, 'ï¼ˆ')
                            .replace(/\)/g, 'ï¼‰');

                        // 3. Restore URLs
                        text = text.replace(/__URL_PLACEHOLDER_(\d+)__/g, (match, index) => {
                            return urls[index];
                        });
                    }
                    if (options.autocorrectSpace) {
                        // ä¸­è‹±æ–‡é–“è·å„ªåŒ–ï¼šä¸­æ–‡èˆ‡è‹±æ–‡/æ•¸å­—ä¹‹é–“åŠ ç©ºæ ¼
                        text = text.replace(/([\u4e00-\u9fa5])([a-zA-Z0-9])/g, '$1 $2')
                            .replace(/([a-zA-Z0-9])([\u4e00-\u9fa5])/g, '$1 $2');
                    }
                    node.textContent = text;
                }

                // éè¿´è™•ç†å­ç¯€é»
                let child = node.firstChild;
                while (child) {
                    const next = child.nextSibling;
                    walk(child);
                    child = next;
                }

                // è™•ç†æ¨™ç±¤å±•é–‹ (Unwrap)
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node;
                    const tagName = el.tagName.toLowerCase();
                    if (options.customTags.includes(tagName)) {
                        const parent = el.parentNode;
                        if (parent) {
                            while (el.firstChild) {
                                parent.insertBefore(el.firstChild, el);
                            }
                            parent.removeChild(el);
                        }
                    }
                }
            };

            const isFullDocument = html.trim().toLowerCase().startsWith("<!doctype") || html.trim().toLowerCase().startsWith("<html");

            if (isFullDocument) {
                walk(doc.documentElement);
                return doc.documentElement.outerHTML;
            } else {
                walk(doc.body);
                return doc.body.innerHTML;
            }
        }

        function renderCleanerTags() {
            cleanerAttrList.innerHTML = '';
            cleanerOptions.customAttributes.forEach(attr => {
                const tag = document.createElement('div');
                tag.className = 'cleaner-tag';
                tag.innerHTML = `<span>${attr}</span><span class="cleaner-tag-remove" onclick="removeCleanerAttr('${attr}')">Ã—</span>`;
                cleanerAttrList.appendChild(tag);
            });

            cleanerTagList.innerHTML = '';
            cleanerOptions.customTags.forEach(tagName => {
                const tag = document.createElement('div');
                tag.className = 'cleaner-tag';
                tag.innerHTML = `<span>${tagName}</span><span class="cleaner-tag-remove" onclick="removeCleanerTag('${tagName}')">Ã—</span>`;
                cleanerTagList.appendChild(tag);
            });
        }

        window.removeCleanerAttr = (attr) => {
            cleanerOptions.customAttributes = cleanerOptions.customAttributes.filter(a => a !== attr);
            renderCleanerTags();
            updateCleaner();
        };

        window.removeCleanerTag = (tagName) => {
            cleanerOptions.customTags = cleanerOptions.customTags.filter(t => t !== tagName);
            renderCleanerTags();
            updateCleaner();
        };

        cleanerAddAttrBtn.addEventListener('click', () => {
            const val = cleanerNewAttr.value.trim();
            if (val && !cleanerOptions.customAttributes.includes(val)) {
                cleanerOptions.customAttributes.push(val);
                cleanerNewAttr.value = '';
                renderCleanerTags();
                updateCleaner();
            }
        });

        cleanerAddTagBtn.addEventListener('click', () => {
            const val = cleanerNewTag.value.trim().toLowerCase();
            if (val && !cleanerOptions.customTags.includes(val)) {
                cleanerOptions.customTags.push(val);
                cleanerNewTag.value = '';
                renderCleanerTags();
                updateCleaner();
            }
        });

        cleanerInput.addEventListener('input', updateCleaner);
        cleanerRemovePath.addEventListener('change', updateCleaner);
        cleanerRemoveIndex.addEventListener('change', updateCleaner);
        cleanerAutocorrectPunct.addEventListener('change', updateCleaner);
        cleanerAutocorrectSpace.addEventListener('change', updateCleaner);

        cleanerClearBtn.addEventListener('click', () => {
            cleanerInput.value = '';
            updateCleaner();
        });

        cleanerUploadBtn.addEventListener('click', () => cleanerFileInput.click());
        cleanerFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                cleanerInput.value = event.target.result;
                updateCleaner();
            };
            reader.readAsText(file);
        });

        cleanerCopyBtn.addEventListener('click', () => {
            cleanerOutput.select();
            document.execCommand('copy');
            alert('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿');
        });

        cleanerDownloadBtn.addEventListener('click', () => {
            const blob = new Blob([cleanerOutput.value], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cleaned.html';
            a.click();
            URL.revokeObjectURL(url);
        });

        /* =========================================
           End HTML Cleaner Logic
           ========================================= */
        /* =========================================
           Word Table to HTML Logic
           ========================================= */
        const wtInput = document.getElementById('wtInput');
        const wtPreview = document.getElementById('wtPreview');
        const wtCode = document.getElementById('wtCode');
        const wtClearBtn = document.getElementById('wtClearBtn');
        const wtCopyBtn = document.getElementById('wtCopyBtn');
        const wtTabs = document.querySelectorAll('.wt-tab-item');

        // Tab Switching
        wtTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const target = tab.dataset.tab;

                // Update tabs
                wtTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Show content
                document.querySelectorAll('.wt-tab-content').forEach(c => c.classList.remove('active'));

                if (target === 'preview') {
                    document.getElementById('wtTabPreview').classList.add('active');
                } else {
                    document.getElementById('wtTabCode').classList.add('active');
                }
            });
        });

        // Paste Handler
        wtInput.addEventListener('paste', (e) => {
            e.preventDefault();
            const html = e.clipboardData.getData('text/html');
            const text = e.clipboardData.getData('text/plain');

            if (html) {
                // Determine if it's a full document or fragment and extract body content if needed
                let contentToProcess = html;

                // Convert
                const result = convertWordTableToHtml(contentToProcess);

                // Insert original (simplified) into input for visual feedback
                // We actually just want to show the text representation or a simple preview in the input box
                // But since it's contentEditable, let's just insert the text or a placeholder
                document.execCommand('insertHTML', false, html);

                updateWtOutput(result);
            } else {
                // Plain text fallback
                document.execCommand('insertText', false, text);
            }
        });

        // Clear Handler
        wtClearBtn.addEventListener('click', () => {
            wtInput.innerHTML = '';
            // Reset preview
            const emptyState = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 300px; color: #94a3b8; text-align: center;">
                    <div style="width: 64px; height: 64px; background: #f1f5f9; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 16px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.5;"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></svg>
                    </div>
                    <p style="font-size: 16px; margin-bottom: 8px;">ç­‰å¾…è¼¸å…¥...</p>
                    <p style="font-size: 13px; opacity: 0.7;">è²¼ä¸Šè¡¨æ ¼å¾Œå°‡åœ¨æ­¤è™•é¡¯ç¤ºé è¦½</p>
                </div>`;
            wtPreview.innerHTML = emptyState;
            wtCode.value = '';
            wtCopyBtn.disabled = true;
        });

        // Copy Handler
        wtCopyBtn.addEventListener('click', () => {
            if (!wtCode.value) return;
            wtCode.select();
            document.execCommand('copy');
            alert('HTML ä»£ç¢¼å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿');
        });

        function updateWtOutput(result) {
            if (result.error) {
                alert(result.error);
                return;
            }
            // Update Preview
            wtPreview.innerHTML = result.html;
            // Update Code
            wtCode.value = result.html;
            // Enable Copy
            wtCopyBtn.disabled = false;
        }

        function convertWordTableToHtml(inputHtml) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(inputHtml, 'text/html');
                const table = doc.querySelector('table');

                if (!table) {
                    return { error: 'æœªæª¢æ¸¬åˆ°è¡¨æ ¼ï¼Œè«‹ç¢ºä¿æ‚¨è¤‡è£½çš„æ˜¯ Word è¡¨æ ¼å…§å®¹ã€‚' };
                }

                const newTable = document.createElement('table');
                newTable.style.width = '100%';
                newTable.style.borderCollapse = 'collapse';
                newTable.style.border = '1px solid black';
                newTable.style.color = 'black';
                newTable.style.backgroundColor = 'transparent';

                const rows = Array.from(table.rows);

                // Calculate total width for percentages
                let totalWidth = 0;
                const firstRowCells = Array.from(rows[0]?.cells || []);
                const cellWidths = [];

                firstRowCells.forEach(cell => {
                    let width = 0;
                    const styleWidth = cell.style.width;
                    const attrWidth = cell.getAttribute('width');

                    if (styleWidth && styleWidth.includes('px')) {
                        width = parseFloat(styleWidth);
                    } else if (attrWidth) {
                        width = parseFloat(attrWidth);
                    }
                    else if (cell.style.width && cell.style.width.includes('%')) {
                        // If already %, we might just use it, but converting to absolute first is safer for normalization
                        // For now, let's just try to parse it as is if we can't find px
                        // Actually, Word usually gives px or pts.
                    }

                    cellWidths.push(width);
                    totalWidth += width;
                });

                const hasValidWidths = totalWidth > 10;

                rows.forEach((row) => {
                    const newRow = document.createElement('tr');

                    Array.from(row.cells).forEach((cell, index) => {
                        const newCell = document.createElement(cell.tagName.toLowerCase() === 'th' ? 'th' : 'td');

                        // Width
                        if (hasValidWidths && cellWidths[index]) {
                            const percent = (cellWidths[index] / totalWidth) * 100;
                            newCell.style.width = `${percent.toFixed(2)}%`;
                        } else if (!hasValidWidths) {
                            // If no valid widths found, maybe distribute evenly or let auto?
                            // Let's force equal width if only 1 row (header)? No, let's just let it be auto.
                        }

                        // Border
                        newCell.style.border = '1px solid black';
                        newCell.style.padding = '4px';
                        newCell.style.backgroundColor = 'transparent';

                        // Content processing
                        const content = cell.innerHTML;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = content;

                        // Strip styles from p tags
                        const paragraphs = tempDiv.querySelectorAll('p');
                        paragraphs.forEach(p => {
                            p.removeAttribute('style');
                            p.removeAttribute('class');
                            p.style.margin = '0';
                            p.style.padding = '0';
                            p.style.lineHeight = '1.2';
                            p.style.color = 'black';
                        });

                        const allElements = tempDiv.querySelectorAll('*');
                        allElements.forEach(el => {
                            if (el instanceof HTMLElement) {
                                el.style.color = 'black';
                                el.style.backgroundColor = 'transparent';
                            }
                        });

                        if (paragraphs.length === 0) {
                            newCell.style.lineHeight = '1.2';
                        }

                        newCell.innerHTML = tempDiv.innerHTML;

                        if (cell.colSpan > 1) newCell.colSpan = cell.colSpan;
                        if (cell.rowSpan > 1) newCell.rowSpan = cell.rowSpan;

                        const align = cell.style.textAlign || cell.getAttribute('align');
                        if (align) newCell.style.textAlign = align;

                        newRow.appendChild(newCell);
                    });

                    newTable.appendChild(newRow);
                });

                return {
                    html: newTable.outerHTML,
                    preview: newTable.outerHTML
                };

            } catch (e) {
                console.error(e);
                return { error: 'è½‰æ›éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: ' + e.message };
            }
        }
    </script>



</body>

</html>