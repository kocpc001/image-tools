<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 20px;
            width: 100%;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        #dropZone.dragover {
            background-color: #e1e1e1;
        }

        #fileInput,
        #logoInput {
            display: none;
        }

        #status {
            margin-top: 20px;
        }

        .mode-buttons {
            margin-bottom: 20px;
        }

        .mode-button {
            margin-right: 10px;
            padding: 10px 15px;
            background-color: #ccc;
            border: none;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .mode-button.active {
            background-color: #007bff;
            color: #fff;
        }

        #logoPreview {
            max-width: 100px;
            max-height: 100px;
            margin-top: 10px;
            display: none;
        }

        #screenshotArrange,
        #borderlessScreenshotArrange {
            margin-top: 30px;
            text-align: center;
        }

        #fileInput2,
        #borderlessFileInput2 {
            margin-bottom: 10px;
        }

        #canvasContainer,
        #borderlessCanvasContainer {
            position: relative;
            display: inline-block;
        }

        #canvas,
        #borderlessCanvas {
            border: 1px solid #000;
        }

        #imageList,
        #borderlessImageList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .image-item {
            width: 150px;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: move;
            position: relative;
            user-select: none;
        }

        .image-item img {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
        }

        .image-item.dragging {
            opacity: 0.5;
        }

        .image-item.drag-over {
            border: 2px dashed #000;
        }

        .delete-button {
            margin-top: 5px;
            padding: 2px 5px;
            background-color: #cc0000;
            color: white;
            border: none;
            cursor: pointer;
        }

        #downloadButton,
        #borderlessDownloadButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            display: none;
        }

        #editTools,
        #borderlessEditTools {
            margin-top: 10px;
        }

        #editTools button,
        #borderlessEditTools button,
        #previewEditTools button {
            margin-right: 5px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        #editTools button:hover,
        #borderlessEditTools button:hover,
        #previewEditTools button:hover {
            background-color: #e0e0e0;
        }

        #editCanvas,
        #borderlessEditCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #clearAllButton,
        #borderlessClearAllButton {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            cursor: pointer;
        }

        /* ç¸®æ”¾å“è³ªé¸é …æ¨£å¼ */
        .quality-control {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .quality-control label {
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
            color: #495057;
        }

        .quality-control select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: white;
            font-size: 14px;
        }

        .quality-info {
            margin-top: 8px;
            font-size: 12px;
            color: #6c757d;
            line-height: 1.4;
        }

        .quality-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 5px;
        }

        .badge-ultra {
            background-color: #28a745;
            color: white;
        }

        .badge-high {
            background-color: #17a2b8;
            color: white;
        }

        .badge-balanced {
            background-color: #ffc107;
            color: black;
        }

        .badge-fast {
            background-color: #dc3545;
            color: white;
        }

        /* ç¹ç°¡è½‰æ›å™¨æ¨£å¼ */
        #chineseConvArea {
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .conv-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .conv-title {
            font-size: 24px;
            font-weight: bold;
        }

        .conv-subtitle {
            font-size: 14px;
            color: #888;
            margin-left: 10px;
        }

        .conv-main {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .conv-section {
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f8fafc;
        }

        .conv-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #edf2f7;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 8px 8px 0 0;
        }

        .conv-label {
            font-weight: bold;
            color: #2d3748;
        }

        .conv-tag {
            font-size: 12px;
            color: #718096;
            font-family: monospace;
        }

        .conv-textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: none;
            resize: none;
            background-color: transparent;
            font-size: 16px;
            line-height: 1.6;
            outline: none;
            box-sizing: border-box;
        }

        .conv-output-area {
            height: 150px;
            padding: 15px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 16px;
            line-height: 1.6;
        }

        .conv-output-container {
            display: flex;
            gap: 20px;
        }

        .conv-output-box {
            flex: 1;
        }

        .conv-tools {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .conv-section:hover .conv-tools {
            opacity: 1;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            color: #718096;
        }

        .icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: #2d3748;
        }

        /* Dictionary Dialog */
        #dictDialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .dict-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 500px;
            max-width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .dict-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .dict-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
        }

        .dict-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .dict-item:last-child {
            border-bottom: none;
        }

        .dict-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .dict-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
        }

        .btn-primary {
            background-color: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-primary:hover {
            background-color: #2c5282;
        }

        .btn-danger {
            color: #e53e3e;
            background: none;
            border: none;
            cursor: pointer;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-outline:hover {
            background-color: #f7fafc;
        }

        /* HTML Cleaner æ¨£å¼ */
        #htmlCleanerArea {
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .cleaner-tag {
            background: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .cleaner-tag-remove {
            cursor: pointer;
            color: #e53e3e;
            font-weight: bold;
        }

        .mr-header {
            background-color: #1e293b;
            border-bottom: 1px solid #334155;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
        }

        .mr-title-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .mr-icon-box {
            background-color: #2563eb;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mr-title {
            font-size: 18px;
            font-weight: bold;
            color: #f1f5f9;
            margin: 0;
        }

        .mr-mode-switch {
            display: flex;
            background-color: #334155;
            padding: 4px;
            border-radius: 8px;
            gap: 4px;
        }

        .mr-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            background: transparent;
            color: #94a3b8;
        }

        .mr-btn:hover {
            color: white;
        }

        .mr-btn-active {
            background-color: white;
            color: #0f172a;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Main Layout */
        .mr-main {
            display: flex;
            flex-direction: column;
            gap: 24px;
            padding: 16px;
            background-color: #0f172a;
            color: #f1f5f9;
            min-height: 600px;
        }

        @media (min-width: 1024px) {
            .mr-main {
                flex-direction: row;
            }
        }

        .mr-canvas-container {
            flex: 1;
            background-color: #020617;
            border-radius: 12px;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #1e293b;
            position: relative;
            overflow: hidden;
            min-height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mr-upload-prompt {
            text-align: center;
            padding: 40px;
            max-width: 400px;
        }

        .mr-upload-icon-circle {
            width: 80px;
            height: 80px;
            background-color: #1e293b;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 24px;
            border: 2px dashed #475569;
        }

        .mr-upload-icon {
            width: 40px;
            height: 40px;
            color: #64748b;
        }

        .mr-upload-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #f1f5f9;
        }

        .mr-upload-desc {
            color: #94a3b8;
            font-size: 14px;
            margin-bottom: 24px;
        }

        .mr-upload-btn {
            background-color: #2563eb;
            color: white;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: background-color 0.2s;
            box-shadow: 0 4px 6px -1px rgba(30, 58, 138, 0.2);
        }

        .mr-upload-btn:hover {
            background-color: #3b82f6;
        }

        /* Canvas Wrapper */
        .mr-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mrImageCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
            pointer-events: none;
        }

        #mrMaskCanvas {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
            opacity: 0.6;
            touch-action: none;
        }

        .mr-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 8px;
            background-color: rgba(15, 23, 42, 0.8);
            color: white;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            backdrop-filter: blur(4px);
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }

        .mr-close-btn:hover {
            background-color: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }

        /* Sidebar */
        .mr-sidebar {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (min-width: 1024px) {
            .mr-sidebar {
                width: 320px;
            }
        }

        .mr-panel {
            background-color: #1e293b;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .mr-panel-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .text-green-400 {
            color: #4ade80;
        }

        .text-yellow-400 {
            color: #facc15;
        }

        .text-blue-400 {
            color: #60a5fa;
        }

        .text-purple-400 {
            color: #c084fc;
        }

        .text-white {
            color: white;
        }

        .mr-info-box {
            background-color: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }

        .mr-control-group {
            margin-bottom: 24px;
        }

        .mr-toggle-group {
            display: flex;
            background-color: #0f172a;
            padding: 4px;
            border-radius: 8px;
        }

        .mr-toggle-btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            background: transparent;
            color: #64748b;
            transition: color 0.2s;
        }

        .mr-toggle-btn:hover {
            color: #cbd5e1;
        }

        .mr-toggle-btn.active {
            background-color: #334155;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .mr-label-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #cbd5e1;
        }

        .mr-val {
            font-family: monospace;
            font-weight: bold;
        }

        .mr-slider {
            width: 100%;
            height: 8px;
            background-color: #0f172a;
            border-radius: 8px;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .mr-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .mr-slider.accent-green::-webkit-slider-thumb {
            background-color: #4ade80;
        }

        .mr-slider.accent-blue::-webkit-slider-thumb {
            background-color: #60a5fa;
        }

        .mr-slider.accent-purple::-webkit-slider-thumb {
            background-color: #c084fc;
        }

        /* Inpainting */
        .mr-desc-text {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .mr-action-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s;
        }

        .mr-action-btn:active {
            transform: scale(0.98);
        }

        .bg-yellow {
            background-color: #ca8a04;
        }

        .bg-yellow:hover {
            background-color: #eab308;
        }

        /* Tools */
        .mr-section-title {
            font-size: 12px;
            font-weight: bold;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 16px;
        }

        .mr-tool-select {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }

        .mr-tool-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #334155;
            background-color: #334155;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mr-tool-btn:hover {
            background-color: #475569;
        }

        .mr-tool-btn.active {
            background-color: #2563eb;
            border-color: #1d4ed8;
            color: white;
        }

        .mr-small-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            background-color: #334155;
            border-radius: 8px;
            color: #cbd5e1;
            font-size: 12px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mr-small-btn:hover {
            background-color: #475569;
        }

        .mr-action-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        /* Result */
        .mr-result-box {
            background-color: #0f172a;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            border: 1px solid #1e293b;
            margin-top: 8px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .mr-result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            border-bottom: 1px solid #1e293b;
            padding-bottom: 16px;
        }

        .mr-result-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: bold;
            color: white;
        }

        .mr-download-btn {
            padding: 10px 24px;
            background-color: #2563eb;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
        }

        .mr-download-btn:hover {
            background-color: #3b82f6;
        }

        .mr-coffee-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background-color: #FFDD00;
            color: black;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
            font-family: cursive;
        }

        .mr-coffee-btn:hover {
            background-color: #ffea55;
        }

        .mr-result-img-wrapper {
            display: flex;
            justify-content: center;
            background-color: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid rgba(30, 41, 59, 0.5);
        }

        .mr-result-img-wrapper img {
            max-height: 600px;
            width: auto;
            border-radius: 4px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        .mr-loading-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(4px);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .mr-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .mr-loading-text {
            color: white;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .mr-loading-subtext {
            font-size: 12px;
            color: #94a3b8;
        }
    </style>

</head>

<body>
    <h1 id="pageTitle">åœ–ç‰‡è™•ç†å·¥å…· v11 - å®‰å…¨ç‰ˆ <small style="color: #666; font-size: 0.6em;">(ä¿®å¾©ç·šæ¢å•é¡Œ)</small></h1>

    <!-- ç¸®æ”¾å“è³ªæ§åˆ¶ -->
    <div class="quality-control">
        <label for="scalingQuality">ğŸ¯ ç¸®æ”¾å“è³ªé¸æ“‡ï¼š</label>
        <select id="scalingQuality">
            <option value="ultra">è¶…é«˜å“è³ª - å¤šæ­¥é©Ÿç¸®æ”¾ (ç„¡éŠ³åŒ–)</option>
            <option value="high">é«˜å“è³ª - é«˜å“è³ªCanvasç¸®æ”¾</option>
            <option value="balanced" selected>å¹³è¡¡ - æ¨™æº–é«˜å“è³ªç¸®æ”¾ (é è¨­)</option>
            <option value="fast">å¿«é€Ÿ - èˆ‡åŸç‰ˆç›¸åŒ</option>
        </select>
        <div class="quality-info">
            <div id="qualityDescription">
                <span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>
                ä½¿ç”¨é«˜å“è³ªCanvasç¸®æ”¾ï¼Œåœ¨å“è³ªå’Œé€Ÿåº¦é–“å–å¾—å¹³è¡¡ï¼Œå·²ä¿®å¾©ç·šæ¢å•é¡Œ
            </div>
        </div>
    </div>

    <div class="mode-buttons">
        <button id="cropImageMode" class="mode-button active">åœ–ç‰‡è£åˆ‡</button>
        <button id="resize320Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰</button>
        <button id="resize1080Mode" class="mode-button">ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰</button>
        <button id="addWatermarkMode" class="mode-button">æ·»åŠ æµ®æ°´å°</button>
        <button id="adaSpecialMode" class="mode-button">é›»è…¦ç‹é˜¿é”å°ˆç”¨</button>
        <button id="screenshotArrangeMode" class="mode-button">æˆªåœ–ä¸¦æ’</button>
        <button id="borderlessScreenshotArrangeMode" class="mode-button">ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’</button>
        <button id="chineseConvMode" class="mode-button">ç°¡ç¹è½‰æ›</button>
        <button id="htmlCleanerMode" class="mode-button">å»é™¤ç„¡ç”¨å­—å…ƒ</button>
        <button id="magicRemoverMode" class="mode-button"
            onclick="window.open('https://watermarkrem-l7wtq3nz.manus.space/', '_blank')">å»æµ®æ°´å°</button>
        <button id="advancedMagicRemoverMode" class="mode-button"
            onclick="window.open('https://gemini.google.com/share/846c59512fa9', '_blank')">é€²éšå»æµ®æ°´å°</button>
    </div>
    <div id="dropZone">
        <p>æ‹–æ›³åœ–ç‰‡åˆ°é€™è£¡æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*">
    <div id="status"></div>

    <!-- çµ±ä¸€é è¦½å’Œç·¨è¼¯å€åŸŸ -->
    <div id="previewArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>è™•ç†çµæœé è¦½</h3>
        <div id="previewCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="previewCanvas"
                style="border: 1px solid #000; max-width: 100%; height: auto; display: block;"></canvas>
            <canvas id="previewEditCanvas"
                style="position: absolute; top: 0; left: 0; cursor: crosshair; width: 100%; height: 100%;"></canvas>
            <button id="previewDownloadButton"
                style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="previewEditTools" style="margin-top: 10px;">
            <button id="previewRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="previewWatermarkTool">æµ®æ°´å°</button>
            <input type="file" id="previewWatermarkInput" accept="image/*" style="display: none;">
            <button id="previewArrowTool">ç®­é ­å·¥å…·</button>
            <button id="previewMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="previewUndoButton">å¾©åŸ</button>
            <button id="previewClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
        <div style="margin-top: 10px;">
            <button id="processMoreButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; margin-right: 10px;">è™•ç†æ›´å¤šåœ–ç‰‡</button>
            <button id="clearPreviewButton"
                style="padding: 10px 15px; background-color: #6c757d; color: white; border: none; cursor: pointer; margin-right: 10px;">æ¸…é™¤é è¦½</button>
            <button id="downloadPNGButton"
                style="padding: 10px 15px; background-color: #28a745; color: white; border: none; cursor: pointer; display: none;">ä¸‹è¼‰PNGé«˜ç•«è³ª</button>
        </div>
    </div>
    <div>
        <button id="selectLogoBtn" style="display: none;">é¸æ“‡ Logo</button>
        <button id="selectAdaLogoBtn" style="display: none;">é¸æ“‡é˜¿é”å°ˆç”¨ Logo</button>
        <input type="file" id="logoInput" accept="image/*" style="display: none;">
        <span id="logoStatus"></span>
        <img id="logoPreview" alt="Logo Preview" style="display: none;">
    </div>

    <div id="screenshotArrange" style="display: none;">
        <input type="file" id="fileInput2" multiple accept="image/*">
        <span id="fileCount"></span>
        <button id="clearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="imageList"></div>
        <button id="processButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            <canvas id="editCanvas"></canvas>
            <button id="downloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="editTools">
            <button id="rectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="arrowTool">ç®­é ­å·¥å…·</button>
            <button id="watermarkTool">æµ®æ°´å°</button>
            <button id="mosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="undoButton">å¾©åŸ</button>
            <button id="clearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <!-- ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’åŠŸèƒ½ -->
    <div id="borderlessScreenshotArrange" style="display: none;">
        <input type="file" id="borderlessFileInput2" multiple accept="image/*">
        <span id="borderlessFileCount"></span>
        <button id="borderlessClearAllButton">æ¸…é™¤æ‰€æœ‰åœ–ç‰‡</button>
        <div id="borderlessImageList"></div>
        <button id="borderlessProcessButton">è™•ç†åœ–ç‰‡</button>
        <br>
        <div id="borderlessCanvasContainer">
            <canvas id="borderlessCanvas"></canvas>
            <canvas id="borderlessEditCanvas"></canvas>
            <button id="borderlessDownloadButton">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
        <div id="borderlessEditTools">
            <button id="borderlessRectangleTool">çŸ©å½¢å·¥å…·</button>
            <button id="borderlessArrowTool">ç®­é ­å·¥å…·</button>
            <button id="borderlessWatermarkTool">æµ®æ°´å°</button>
            <button id="borderlessMosaicTool">é¦¬è³½å…‹å·¥å…·</button>
            <button id="borderlessUndoButton">å¾©åŸ</button>
            <button id="borderlessClearButton">æ¸…é™¤æ‰€æœ‰ç·¨è¼¯</button>
        </div>
    </div>

    <!-- åœ–ç‰‡è£åˆ‡åŠŸèƒ½å€å¡Š -->
    <div id="cropImageArea" style="display: none; text-align: center; margin-top: 20px;">
        <h3>åœ–ç‰‡è£åˆ‡</h3>
        <div id="cropCanvasContainer" style="position: relative; display: inline-block;">
            <canvas id="cropCanvas" style="border: 1px solid #000;"></canvas>
            <canvas id="cropSelectionCanvas" style="position: absolute; top: 0; left: 0; z-index: 10;"></canvas>
        </div>
        <div style="margin-top: 10px;">
            <button id="executeCropButton"
                style="padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer;">åŸ·è¡Œè£åˆ‡</button>
            <button id="cancelCropButton"
                style="padding: 10px 15px; background-color: #dc3545; color: white; border: none; cursor: pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- ç¹ç°¡è½‰æ›åŠŸèƒ½å€å¡Š -->
    <div id="chineseConvArea">
        <div class="conv-header">
            <div class="conv-title">
                ç¹ç°¡è½‰æ› <span class="conv-subtitle">Zen Converter</span>
            </div>
            <button id="dictBtn" class="btn-outline">
                ğŸ“š è‡ªå®šç¾©è©åº« <span id="dictCountBadge"
                    style="background: #3182ce; color: white; border-radius: 10px; padding: 0 5px; font-size: 12px; display: none;">0</span>
            </button>
        </div>

        <div class="conv-main">
            <!-- è¼¸å…¥å€ -->
            <div class="conv-section">
                <div class="conv-section-header">
                    <span class="conv-label">ä¸­æ–‡è¼¸å…¥</span>
                    <span class="conv-tag">INPUT (Auto Detect)</span>
                </div>
                <div class="conv-tools">
                    <button class="icon-btn" id="convClearBtn" title="æ¸…é™¤">ğŸ—‘ï¸</button>
                    <button class="icon-btn" id="convCopyInputBtn" title="è¤‡è£½">ğŸ“‹</button>
                    <input type="file" id="convFileInput" accept=".txt,.srt" style="display:none">
                    <button class="icon-btn" id="convUploadBtn" title="ä¸Šå‚³æª”æ¡ˆ">ğŸ“‚</button>
                </div>
                <textarea id="convInput" class="conv-textarea" placeholder="åœ¨æ­¤è¼¸å…¥ä¸­æ–‡å…§å®¹ï¼ˆç¹é«”æˆ–ç°¡é«”çš†å¯ï¼‰..."></textarea>
            </div>

            <div class="conv-output-container">
                <!-- ç¹é«”è¼¸å‡º -->
                <div class="conv-output-box">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">ç¹é«”ä¸­æ–‡</span>
                            <span class="conv-tag">TRADITIONAL</span>
                        </div>
                        <div class="conv-tools">
                            <button class="icon-btn" id="convDownloadTradBtn" title="ä¸‹è¼‰ç¹é«”çµæœ">â¬‡ï¸</button>
                            <button class="icon-btn" id="convCopyTradBtn" title="è¤‡è£½ç¹é«”çµæœ">ğŸ“‹</button>
                        </div>
                        <div id="convOutputTrad" class="conv-output-area"></div>
                    </div>
                </div>

                <!-- ç°¡é«”è¼¸å‡º -->
                <div class="conv-output-box">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">ç°¡é«”ä¸­æ–‡</span>
                            <span class="conv-tag">SIMPLIFIED</span>
                        </div>
                        <div class="conv-tools">
                            <button class="icon-btn" id="convDownloadSimpBtn" title="ä¸‹è¼‰ç°¡é«”çµæœ">â¬‡ï¸</button>
                            <button class="icon-btn" id="convCopySimpBtn" title="è¤‡è£½ç°¡é«”çµæœ">ğŸ“‹</button>
                        </div>
                        <div id="convOutputSimp" class="conv-output-area"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- å»æµ®æ°´å° (Magic Remover) åŠŸèƒ½å€å¡Š -->
    <div id="magicRemoverArea" style="display: none;">
        <!-- Header -->
        <div class="mr-header">
            <div class="mr-title-group">
                <div class="mr-icon-box">
                    <i data-lucide="droplet" class="text-white"></i>
                </div>
                <h1 class="mr-title">
                    é›»è…¦ç‹é˜¿é” Nano Banana å»æµ®æ°´å°å·¥å…·
                </h1>
            </div>

            <div class="mr-mode-switch">
                <button id="mrModeReconstruct" class="mr-btn mr-btn-active">
                    <i data-lucide="palette" size="14"></i>
                    åŠé€æ˜å»é™¤
                </button>
                <button id="mrModeInpainting" class="mr-btn">
                    <i data-lucide="zap" size="14"></i>
                    ç‰©é«”æ¶ˆé™¤
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="mr-main">
            <!-- Canvas Area -->
            <div id="mrCanvasContainer" class="mr-canvas-container">
                <div id="mrUploadPrompt" class="mr-upload-prompt">
                    <div class="mr-upload-icon-circle">
                        <i data-lucide="image" class="mr-upload-icon"></i>
                    </div>
                    <h3 class="mr-upload-title">ä¸Šå‚³æ‚¨çš„åœ–ç‰‡</h3>
                    <p class="mr-upload-desc">
                        é¸æ“‡æ¨¡å¼ï¼šé‡å° LOGO æµ®æ°´å°è«‹ç”¨ã€ŒåŠé€æ˜å»é™¤ã€ï¼›é‡å°è·¯äººæˆ–å¯¦å¿ƒç‰©é«”è«‹ç”¨ã€Œç‰©é«”æ¶ˆé™¤ã€ã€‚
                    </p>
                    <label class="mr-upload-btn">
                        <i data-lucide="upload" size="18"></i>
                        <span>é¸æ“‡æª”æ¡ˆ</span>
                        <input type="file" id="mrFileInput" accept="image/*" style="display:none">
                    </label>
                </div>

                <div id="mrCanvasWrapper" class="mr-canvas-wrapper" style="display:none;">
                    <canvas id="mrImageCanvas"></canvas>
                    <canvas id="mrMaskCanvas"></canvas>
                    <button id="mrCloseBtn" class="mr-close-btn" title="ç§»é™¤åœ–ç‰‡">
                        <i data-lucide="x" size="20"></i>
                    </button>
                </div>

                <div id="mrLoadingOverlay" class="mr-loading-overlay" style="display:none;">
                    <div class="mr-spinner"></div>
                    <div class="mr-loading-text">æ™ºèƒ½é‹ç®—ä¸­... <span id="mrProgress">0</span>%</div>
                    <div class="mr-loading-subtext">æ­£åœ¨å°‹æ‰¾æœ€ä½³ç´‹ç†å¡«è£œå€åŸŸ</div>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="mr-sidebar">

                <!-- Reconstruct Controls -->
                <div id="mrControlsReconstruct" class="mr-panel">
                    <div class="mr-panel-header text-green-400">
                        <i data-lucide="palette" size="18"></i>
                        <h3>åŠé€æ˜å»é™¤è¨­å®š</h3>
                    </div>

                    <div class="mr-info-box">
                        <div style="display:flex; gap:8px;">
                            <i data-lucide="info" size="16" class="text-blue-400"></i>
                            <p>
                                <strong>æ¨è–¦ç”¨æ–¼ LOGO</strong>
                                é­”æ³•æ£’èˆ‡ç­†åˆ·çš†å·²å•Ÿç”¨è‡ªå‹•æ“´å±•ï¼Œèƒ½æœ‰æ•ˆæ¶ˆé™¤é‚Šç·£ç™½é‚Šé›œé»ã€‚
                            </p>
                        </div>
                    </div>

                    <div class="mr-control-group">
                        <div class="mr-toggle-group">
                            <button id="mrColorWhite" class="mr-toggle-btn active">ç™½è‰²æµ®æ°´å°</button>
                            <button id="mrColorBlack" class="mr-toggle-btn">é»‘è‰²æµ®æ°´å°</button>
                        </div>
                    </div>

                    <div class="mr-control-group">
                        <div class="mr-label-row">
                            <span>1. å»é™¤å¼·åº¦</span>
                            <span id="mrIntensityVal" class="mr-val text-green-400">50%</span>
                        </div>
                        <input type="range" id="mrIntensity" min="0" max="80" value="50" class="mr-slider accent-green">
                    </div>

                    <div class="mr-control-group">
                        <div class="mr-label-row">
                            <span style="display:flex; align-items:center; gap:4px;"><i data-lucide="sliders"
                                    size="14"></i> 2. éæ¿¾èƒŒæ™¯</span>
                            <span id="mrThresholdVal" class="mr-val text-blue-400">50</span>
                        </div>
                        <input type="range" id="mrThreshold" min="0" max="100" value="50" class="mr-slider accent-blue">
                    </div>
                </div>

                <!-- Inpainting Controls -->
                <div id="mrControlsInpainting" class="mr-panel" style="display:none;">
                    <div class="mr-panel-header text-yellow-400">
                        <i data-lucide="sparkles" size="18"></i>
                        <h3>ç‰©é«”æ¶ˆé™¤è¨­å®š</h3>
                    </div>
                    <p class="mr-desc-text">
                        ä½¿ç”¨é¡ä¼¼ LaMa Cleaner çš„ <strong>PatchMatch æ¼”ç®—æ³•</strong>ï¼Œæ™ºèƒ½å¡«è£œä¸é€æ˜çš„ç‰©é«”ã€‚<br>
                        <span style="color:#64748b; font-size:11px;">(æ³¨æ„ï¼šé‹ç®—è¼ƒè€—æ™‚)</span>
                    </p>
                    <button id="mrStartInpaintingBtn" class="mr-action-btn bg-yellow">
                        <i data-lucide="play" size="18"></i>
                        é–‹å§‹æ™ºèƒ½é‹ç®—
                    </button>
                </div>

                <!-- Common Tools -->
                <div class="mr-panel" style="flex:1;">
                    <h3 class="mr-section-title">ç¹ªåœ–å·¥å…·</h3>

                    <div class="mr-tool-select">
                        <button id="mrToolWand" class="mr-tool-btn active">
                            <i data-lucide="wand-2" size="20"></i>
                            <span>é­”æ³•æ£’</span>
                        </button>
                        <button id="mrToolBrush" class="mr-tool-btn">
                            <i data-lucide="brush" size="20"></i>
                            <span>ç­†åˆ·</span>
                        </button>
                    </div>

                    <!-- Wand Settings -->
                    <div id="mrSettingsWand" class="mr-sub-settings">
                        <div class="mr-label-row">
                            <span style="display:flex; align-items:center; gap:4px;"><i data-lucide="zap" size="12"
                                    class="text-purple-400"></i> å®¹è¨±åº¦</span>
                            <span id="mrToleranceVal" class="mr-val text-purple-400">30</span>
                        </div>
                        <input type="range" id="mrTolerance" min="1" max="100" value="30"
                            class="mr-slider accent-purple">
                        <p class="mr-hint">æ•¸å€¼è¶Šé«˜ï¼Œé­”æ³•æ£’é¸å–çš„é¡è‰²ç¯„åœè¶Šå»£ã€‚</p>
                    </div>

                    <!-- Brush Settings -->
                    <div id="mrSettingsBrush" class="mr-sub-settings" style="display:none;">
                        <div class="mr-label-row">
                            <span>ç­†åˆ·å¤§å°</span>
                            <span id="mrBrushSizeVal" class="mr-val">30px</span>
                        </div>
                        <input type="range" id="mrBrushSize" min="5" max="100" value="30" class="mr-slider accent-blue">
                    </div>

                    <div class="mr-action-row">
                        <button id="mrClearBtn" class="mr-small-btn">
                            <i data-lucide="trash-2" size="14"></i> å…¨æ¸…ç©º
                        </button>
                        <button id="mrUndoBtn" class="mr-small-btn">
                            <i data-lucide="rotate-ccw" size="14"></i> ä¸Šä¸€æ­¥
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Result Preview -->
        <div id="mrResultPreview" class="mr-result-box" style="display:none;">
            <div class="mr-result-header">
                <div class="mr-result-title">
                    <i data-lucide="check-circle-2" class="text-green-500"></i>
                    <h3>è™•ç†çµæœé è¦½</h3>
                </div>
                <div style="display:flex; gap:10px;">
                    <a href="https://www.buymeacoffee.com/kocpc" target="_blank" class="mr-coffee-btn">
                        <i data-lucide="coffee"></i>
                        <span>Buy me a coffee</span>
                    </a>
                    <button id="mrDownloadBtn" class="mr-download-btn">
                        <i data-lucide="download" size="18"></i>
                        ä¸‹è¼‰ JPG åœ–ç‰‡
                    </button>
                </div>
            </div>
            <div class="mr-result-img-wrapper">
                <img id="mrResultImage" alt="Result">
            </div>
        </div>
    </div>

    <!-- HTML Cleaner åŠŸèƒ½å€å¡Š -->
    <div id="htmlCleanerArea" style="display: none;">
        <div class="conv-header">
            <div class="conv-title">
                å»é™¤ç„¡ç”¨å­—å…ƒ <span class="conv-subtitle">HTML Cleaner</span>
            </div>
        </div>
        <div class="conv-main">
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <!-- å´é‚Šæ¬„è¨­å®š -->
                <div
                    style="width: 280px; flex-shrink: 0; background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <h3 style="margin-top: 0; font-size: 16px;">åŸºæœ¬è¨­å®š</h3>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerRemovePath" checked> ç§»é™¤ data-path-to-node
                        </label>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerRemoveIndex" checked> ç§»é™¤ data-index-in-node
                        </label>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerAutocorrectPunct" checked> è‡ªå‹•ä¿®æ­£æ¨™é»ç¬¦è™Ÿ (åŠè½‰å…¨)
                        </label>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="cleanerAutocorrectSpace" checked> ä¸­è‹±æ–‡é–“è·å„ªåŒ– (åŠ ç©ºæ ¼)
                        </label>
                    </div>

                    <h3 style="font-size: 16px;">è‡ªè¨‚ç§»é™¤å±¬æ€§</h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 10px;">è¼¸å…¥å±¬æ€§åç¨± (å¦‚ class æˆ– id=123)</p>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <input type="text" id="cleanerNewAttr" placeholder="å¦‚: class"
                            style="flex: 1; padding: 5px; border: 1px solid #cbd5e0; border-radius: 4px; font-size: 12px;">
                        <button id="cleanerAddAttrBtn" class="btn-primary"
                            style="padding: 5px 10px; font-size: 12px;">æ–°å¢</button>
                    </div>
                    <div id="cleanerAttrList" style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <!-- å±¬æ€§æ¨™ç±¤ -->
                    </div>

                    <h3 style="font-size: 16px; margin-top: 20px;">è‡ªè¨‚ç§»é™¤æ¨™ç±¤</h3>
                    <p style="font-size: 11px; color: #666; margin-bottom: 10px;">ä¿ç•™æ¨™ç±¤å…§çš„å…§å®¹ï¼Œåƒ…ç§»é™¤æ¨™ç±¤æœ¬èº«</p>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <input type="text" id="cleanerNewTag" placeholder="å¦‚: div"
                            style="flex: 1; padding: 5px; border: 1px solid #cbd5e0; border-radius: 4px; font-size: 12px;">
                        <button id="cleanerAddTagBtn" class="btn-primary"
                            style="padding: 5px 10px; font-size: 12px;">æ–°å¢</button>
                    </div>
                    <div id="cleanerTagList" style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <!-- æ¨™ç±¤æ¨™ç±¤ -->
                    </div>
                </div>

                <!-- ç·¨è¼¯å€ -->
                <div style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 20px;">
                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">HTML è¼¸å…¥</span>
                            <div class="conv-tools" style="opacity: 1">
                                <button class="icon-btn" id="cleanerClearBtn" title="æ¸…é™¤">ğŸ—‘ï¸</button>
                                <button class="icon-btn" id="cleanerUploadBtn" title="ä¸Šå‚³æª”æ¡ˆ">ğŸ“‚</button>
                                <input type="file" id="cleanerFileInput" accept=".html,.htm,.txt" style="display:none">
                            </div>
                        </div>
                        <textarea id="cleanerInput" class="conv-textarea" style="height: 250px;"
                            placeholder="åœ¨æ­¤è²¼ä¸Š HTML ä»£ç¢¼..."></textarea>
                    </div>

                    <div class="conv-section">
                        <div class="conv-section-header">
                            <span class="conv-label">æ¸…ç†çµæœ</span>
                            <div class="conv-tools" style="opacity: 1">
                                <button class="icon-btn" id="cleanerDownloadBtn" title="ä¸‹è¼‰çµæœ">â¬‡ï¸</button>
                                <button class="icon-btn" id="cleanerCopyBtn" title="è¤‡è£½çµæœ">ğŸ“‹</button>
                            </div>
                        </div>
                        <textarea id="cleanerOutput" class="conv-textarea" style="height: 250px;" readonly
                            placeholder="è™•ç†å¾Œçš„ä»£ç¢¼å°‡é¡¯ç¤ºæ–¼æ­¤..."></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="dictDialog">
        <div class="dict-content">
            <div class="dict-header">
                <h3>ğŸ“š è‡ªå®šç¾©è½‰æ›è¦å‰‡</h3>
                <button id="closeDictBtn" class="icon-btn">âŒ</button>
            </div>

            <div class="dict-input-row">
                <div style="flex:1">
                    <label style="font-size:12px; color:#666;">SIMPLIFIED (ç°¡é«”)</label>
                    <input id="newSimple" class="dict-input" placeholder="ç°¡é«”è©å½™ (å¦‚: é¼ æ ‡)">
                </div>
                <div style="flex:1">
                    <label style="font-size:12px; color:#666;">TRADITIONAL (ç¹é«”)</label>
                    <input id="newTrad" class="dict-input" placeholder="ç¹é«”è©å½™ (å¦‚: æ»‘é¼ )">
                </div>
                <button id="addDictBtn" class="btn-primary" style="margin-top: 18px;">+</button>
            </div>

            <div style="border-top: 1px solid #eee; margin: 10px 0;"></div>

            <div id="dictList" class="dict-list">
                <!-- åˆ—è¡¨é …ç›®å°‡ç”± JS ç”Ÿæˆ -->
                <div style="text-align: center; color: #999; padding: 20px;">å°šç„¡è‡ªå®šç¾©è¦å‰‡</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.0/dist/browser-image-compression.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.min.js"></script>
    <script>
        // Define global constants for max crop dimensions
        const MAX_CROP_WIDTH = 1000; // é™åˆ¶è£åˆ‡é è¦½å¯¬åº¦ç‚º1000px
        const MAX_CROP_HEIGHT = 800; // Example value, adjust as needed
        const MAX_WIDTH = 1000; // Define MAX_WIDTH
        const MAX_HEIGHT = 1000; // Define MAX_HEIGHT
        const MAX_IMAGES = 20; // Define MAX_IMAGES

        // ============ å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾ç®—æ³• (ä¿®å¾©ç·šæ¢å•é¡Œ) ============

        // æ·»åŠ é»‘æ¡†å‡½æ•¸ (Global Scope)
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            borderedCanvas.width = canvas.width + 2; // å·¦å³å„1px
            borderedCanvas.height = canvas.height + 2; // ä¸Šä¸‹å„1px
            const ctx = borderedCanvas.getContext('2d');

            // å¡«æ»¿é»‘è‰²èƒŒæ™¯
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // ç¹ªè£½åŸå§‹åœ–ç‰‡åœ¨ä¸­é–“
            ctx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜ç´šåœ–åƒç¸®æ”¾å‡½æ•¸ - ä¸ä½¿ç”¨æœ‰å•é¡Œçš„éŠ³åŒ–æ¿¾é¡
         */
        function safeAdvancedImageScale(sourceCanvas, targetWidth, targetHeight, quality = 'balanced') {
            const sourceWidth = sourceCanvas.width;
            const sourceHeight = sourceCanvas.height;
            const scaleX = targetWidth / sourceWidth;
            const scaleY = targetHeight / sourceHeight;
            const minScale = Math.min(scaleX, scaleY);

            console.log(`ç¸®æ”¾å“è³ªé¸æ“‡: ${quality}, ç¸®æ”¾æ¯”ä¾‹: ${minScale.toFixed(3)}`);

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡ç¸®æ”¾ç­–ç•¥
            switch (quality) {
                case 'ultra':
                    // è¶…é«˜å“è³ªï¼šç¸½æ˜¯ä½¿ç”¨å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆç¸®å°æ™‚ï¼‰æˆ–é«˜å“è³ªç¸®æ”¾ï¼ˆæ”¾å¤§æ™‚ï¼‰
                    if (minScale < 1.0) {
                        return safeMultiStepScale(sourceCanvas, targetWidth, targetHeight);
                    } else {
                        return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);
                    }

                case 'high':
                    return safeHighQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'balanced':
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);

                case 'fast':
                    return simpleFastScale(sourceCanvas, targetWidth, targetHeight);

                default:
                    return balancedQualityScale(sourceCanvas, targetWidth, targetHeight);
            }
        }

        /**
         * å®‰å…¨çš„å¤šæ­¥é©Ÿç¸®æ”¾ï¼ˆä¸ä½¿ç”¨éŠ³åŒ–ï¼‰
         */
        function safeMultiStepScale(sourceCanvas, targetWidth, targetHeight) {
            let currentCanvas = sourceCanvas;
            const scaleX = targetWidth / sourceCanvas.width;
            const scaleY = targetHeight / sourceCanvas.height;
            const minScale = Math.min(scaleX, scaleY);

            // è¨ˆç®—æ­¥é©Ÿæ•¸ - æ¯æ­¥æœ€å¤šç¸®å°åˆ°50%
            const steps = Math.max(1, Math.ceil(Math.log(minScale) / Math.log(0.5)));

            console.log(`Ultraè³ªé‡æ¨¡å¼ï¼šåŸå§‹å°ºå¯¸ ${sourceCanvas.width}x${sourceCanvas.height} -> ç›®æ¨™ ${targetWidth}x${targetHeight}ï¼Œç¸®æ”¾æ¯”ä¾‹ ${minScale.toFixed(3)}ï¼Œä½¿ç”¨ ${steps} æ­¥ç¸®æ”¾`);

            for (let i = 0; i < steps; i++) {
                const isLastStep = (i === steps - 1);

                let stepTargetWidth, stepTargetHeight;
                if (isLastStep) {
                    stepTargetWidth = targetWidth;
                    stepTargetHeight = targetHeight;
                } else {
                    // æ¯æ­¥ç¸®å°åˆ°50%
                    stepTargetWidth = Math.max(targetWidth, Math.round(currentCanvas.width * 0.5));
                    stepTargetHeight = Math.max(targetHeight, Math.round(currentCanvas.height * 0.5));
                }

                const stepCanvas = document.createElement('canvas');
                stepCanvas.width = stepTargetWidth;
                stepCanvas.height = stepTargetHeight;
                const stepCtx = stepCanvas.getContext('2d');

                setupUltraQualityCanvas(stepCtx);
                stepCtx.drawImage(currentCanvas, 0, 0, stepTargetWidth, stepTargetHeight);

                console.log(`æ­¥é©Ÿ ${i + 1}/${steps}: ${currentCanvas.width}x${currentCanvas.height} -> ${stepTargetWidth}x${stepTargetHeight}`);
                currentCanvas = stepCanvas;
            }

            return currentCanvas;
        }

        /**
         * å®‰å…¨çš„é«˜å“è³ªç¸®æ”¾
         */
        function safeHighQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`é«˜å“è³ªæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupHighQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * å¹³è¡¡å“è³ªç¸®æ”¾
         */
        function balancedQualityScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¹³è¡¡æ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupBalancedQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        /**
         * ç°¡å–®å¿«é€Ÿç¸®æ”¾
         */
        function simpleFastScale(sourceCanvas, targetWidth, targetHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            console.log(`å¿«é€Ÿæ¨¡å¼ï¼š${sourceCanvas.width}x${sourceCanvas.height} -> ${targetWidth}x${targetHeight}`);
            setupFastQualityCanvas(ctx);
            ctx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);

            return canvas;
        }

        // ============ å“è³ªé¸é …äº¤äº’é‚è¼¯ ============

        function updateQualityDescription() {
            const quality = document.getElementById('scalingQuality').value;
            const description = document.getElementById('qualityDescription');

            const descriptions = {
                ultra: '<span class="badge-ultra quality-badge">è¶…é«˜å“è³ª</span>å¤šæ­¥é©Ÿç¸®æ”¾ + æœ€é«˜JPEGå“è³ª(99%) - æª”æ¡ˆè¼ƒå¤§ä½†å“è³ªæœ€ä½³',
                high: '<span class="badge-high quality-badge">é«˜å“è³ª</span>é«˜å“è³ªç¸®æ”¾ + JPEGå“è³ª(95%) - å¹³è¡¡å“è³ªèˆ‡æª”æ¡ˆå¤§å°',
                balanced: '<span class="badge-balanced quality-badge">å¹³è¡¡æ¨¡å¼</span>ä¸­ç­‰å“è³ªç¸®æ”¾ + JPEGå“è³ª(90%) - æ¨™æº–å“è³ªèˆ‡åˆç†æª”æ¡ˆå¤§å°',
                fast: '<span class="badge-fast quality-badge">å¿«é€Ÿæ¨¡å¼</span>å¿«é€Ÿç¸®æ”¾ + JPEGå“è³ª(80%) - è™•ç†é€Ÿåº¦å¿«ã€æª”æ¡ˆè¼ƒå°'
            };

            description.innerHTML = descriptions[quality];
        }

        // ============ åŸæœ‰åŠŸèƒ½ä»£ç¢¼ ============

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const resize320ModeBtn = document.getElementById('resize320Mode');
        const resize1080ModeBtn = document.getElementById('resize1080Mode');
        const addWatermarkModeBtn = document.getElementById('addWatermarkMode');
        const adaSpecialModeBtn = document.getElementById('adaSpecialMode');
        const screenshotArrangeModeBtn = document.getElementById('screenshotArrangeMode');
        const borderlessScreenshotArrangeModeBtn = document.getElementById('borderlessScreenshotArrangeMode');

        const cropImageModeBtn = document.getElementById('cropImageMode');
        const chineseConvModeBtn = document.getElementById('chineseConvMode');
        const magicRemoverModeBtn = document.getElementById('magicRemoverMode');
        const logoInput = document.getElementById('logoInput');
        const logoStatus = document.getElementById('logoStatus');
        const logoPreview = document.getElementById('logoPreview');
        const pageTitle = document.getElementById('pageTitle');
        const selectLogoBtn = document.getElementById('selectLogoBtn');
        const selectAdaLogoBtn = document.getElementById('selectAdaLogoBtn');
        const screenshotArrangeDiv = document.getElementById('screenshotArrange');
        const borderlessScreenshotArrangeDiv = document.getElementById('borderlessScreenshotArrange');
        const cropImageArea = document.getElementById('cropImageArea');
        const chineseConvArea = document.getElementById('chineseConvArea');
        const magicRemoverArea = document.getElementById('magicRemoverArea');
        // const cropFileInput = document.getElementById('cropFileInput'); // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
        const cropCanvas = document.getElementById('cropCanvas');
        const cropCtx = cropCanvas.getContext('2d');
        const cropSelectionCanvas = document.getElementById('cropSelectionCanvas');
        const cropSelectionCtx = cropSelectionCanvas.getContext('2d');
        const executeCropButton = document.getElementById('executeCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // å“è³ªé¸é …å…ƒç´ 
        const scalingQuality = document.getElementById('scalingQuality');

        // é è¦½ç›¸é—œå…ƒç´ 
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const previewEditCanvas = document.getElementById('previewEditCanvas');
        const previewEditCtx = previewEditCanvas.getContext('2d');
        const previewDownloadButton = document.getElementById('previewDownloadButton');
        const processMoreButton = document.getElementById('processMoreButton');
        const clearPreviewButton = document.getElementById('clearPreviewButton');
        const downloadPNGButton = document.getElementById('downloadPNGButton');

        // é è¦½ç·¨è¼¯å·¥å…·
        const previewRectangleTool = document.getElementById('previewRectangleTool');
        const previewArrowTool = document.getElementById('previewArrowTool');
        const previewMosaicTool = document.getElementById('previewMosaicTool');
        const previewUndoButton = document.getElementById('previewUndoButton');
        const previewClearButton = document.getElementById('previewClearButton');

        // é è¦½ç·¨è¼¯ç‹€æ…‹è®Šé‡
        let previewIsDrawing = false;
        let previewStartX, previewStartY;
        let previewCurrentTool = null;
        let previewEditHistory = [];
        let previewBaseEditState = null;

        let currentMode = 'resize320';
        let logoImage = null;
        let logoFileName = '';
        let adaSpecialLogo = null;
        let adaSpecialLogoFileName = '';

        // è£åˆ‡åŠŸèƒ½ç›¸é—œè®Šæ•¸
        let originalCropImage = null;
        let cropStartX, cropStartY, cropEndX, cropEndY;
        let isCropping = false;
        let cropSelection = { x: 0, y: 0, width: 0, height: 0 };

        // å¾ localStorage è®€å–ä¸Šæ¬¡ä½¿ç”¨çš„ Logo
        const lastUsedLogo = localStorage.getItem('lastUsedLogo');
        const lastUsedLogoName = localStorage.getItem('lastUsedLogoName');
        const lastUsedAdaLogo = localStorage.getItem('lastUsedAdaLogo');
        const lastUsedAdaLogoName = localStorage.getItem('lastUsedAdaLogoName');

        if (lastUsedLogo && lastUsedLogoName) {
            logoImage = new Image();
            logoImage.src = lastUsedLogo;
            logoFileName = lastUsedLogoName;
            updateLogoPreview(lastUsedLogo, lastUsedLogoName, 'ä¸€èˆ¬');
        }

        if (lastUsedAdaLogo && lastUsedAdaLogoName) {
            adaSpecialLogo = new Image();
            adaSpecialLogo.src = lastUsedAdaLogo;
            adaSpecialLogoFileName = lastUsedAdaLogoName;
        }

        // å“è³ªé¸é …äº‹ä»¶ç›£è½å™¨
        scalingQuality.addEventListener('change', updateQualityDescription);

        dropZone.addEventListener('click', () => {
            console.log('dropZone clicked');
            fileInput.click();
        });
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', handleFiles);
        fileInput.addEventListener('change', handleFiles);
        resize320ModeBtn.addEventListener('click', () => setMode('resize320'));
        resize1080ModeBtn.addEventListener('click', () => setMode('resize1080'));
        addWatermarkModeBtn.addEventListener('click', () => setMode('addWatermark'));
        adaSpecialModeBtn.addEventListener('click', () => setMode('adaSpecial'));
        screenshotArrangeModeBtn.addEventListener('click', () => setMode('screenshotArrange'));
        cropImageModeBtn.addEventListener('click', () => setMode('cropImage')); // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼æŒ‰éˆ•äº‹ä»¶
        chineseConvModeBtn.addEventListener('click', () => setMode('chineseConv'));
        const htmlCleanerModeBtn = document.getElementById('htmlCleanerMode');
        const htmlCleanerArea = document.getElementById('htmlCleanerArea');
        htmlCleanerModeBtn.addEventListener('click', () => setMode('htmlCleaner'));
        // magicRemoverModeBtn.addEventListener('click', () => setMode('magicRemover'));
        selectLogoBtn.addEventListener('click', () => logoInput.click());
        selectAdaLogoBtn.addEventListener('click', () => logoInput.click());

        // é è¦½åŠŸèƒ½äº‹ä»¶ç›£è½å™¨
        previewDownloadButton.addEventListener('click', downloadPreviewImage);
        processMoreButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
            fileInput.value = '';
        });
        clearPreviewButton.addEventListener('click', () => {
            previewArea.style.display = 'none';
            status.innerHTML = '';
        });

        downloadPNGButton.addEventListener('click', downloadPreviewImageAsPNG);

        // é è¦½ç·¨è¼¯å·¥å…·äº‹ä»¶ç›£è½å™¨
        previewRectangleTool.addEventListener('click', () => {
            previewCurrentTool = 'rectangle';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewArrowTool.addEventListener('click', () => {
            previewCurrentTool = 'arrow';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewMosaicTool.addEventListener('click', () => {
            previewCurrentTool = 'mosaic';
            previewEditCanvas.style.cursor = 'crosshair';
        });
        previewUndoButton.addEventListener('click', previewUndo);
        previewClearButton.addEventListener('click', previewClearEdits);

        // é è¦½ç·¨è¼¯canvasäº‹ä»¶ç›£è½å™¨
        previewEditCanvas.addEventListener('mousedown', previewStartDrawing);
        previewEditCanvas.addEventListener('mousemove', previewDraw);
        previewEditCanvas.addEventListener('mouseup', previewStopDrawing);
        previewEditCanvas.addEventListener('mouseout', previewStopDrawing);

        // è£åˆ‡åŠŸèƒ½äº‹ä»¶ç›£è½å™¨

        cropSelectionCanvas.addEventListener('mousedown', startCropDrawing);
        cropSelectionCanvas.addEventListener('mousemove', drawCropSelection);
        cropSelectionCanvas.addEventListener('mouseup', stopCropDrawing);
        cropSelectionCanvas.addEventListener('mouseout', stopCropDrawing);
        executeCropButton.addEventListener('click', executeCrop);
        cancelCropButton.addEventListener('click', cancelCrop);

        // ğŸ”¥ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const borderlessFileInput2 = document.getElementById('borderlessFileInput2');
        const borderlessFileCount = document.getElementById('borderlessFileCount');
        const borderlessProcessButton = document.getElementById('borderlessProcessButton');
        const borderlessDownloadButton = document.getElementById('borderlessDownloadButton');
        const borderlessCanvas = document.getElementById('borderlessCanvas');
        const borderlessCtx = borderlessCanvas.getContext('2d');
        const borderlessImageList = document.getElementById('borderlessImageList');
        const borderlessEditCanvas = document.getElementById('borderlessEditCanvas');
        const borderlessEditCtx = borderlessEditCanvas.getContext('2d');
        const borderlessRectangleTool = document.getElementById('borderlessRectangleTool');
        const borderlessArrowTool = document.getElementById('borderlessArrowTool');
        const borderlessWatermarkTool = document.getElementById('borderlessWatermarkTool');
        const borderlessMosaicTool = document.getElementById('borderlessMosaicTool');
        const borderlessUndoButton = document.getElementById('borderlessUndoButton');
        const borderlessClearButton = document.getElementById('borderlessClearButton');
        const borderlessClearAllButton = document.getElementById('borderlessClearAllButton');

        let borderlessUploadedImages = [];
        let borderlessIsDrawing = false;
        let borderlessStartX, borderlessStartY;
        let borderlessCurrentTool = null;
        let borderlessEditHistory = [];
        let borderlessBaseEditState = null;

        borderlessScreenshotArrangeModeBtn.addEventListener('click', () => setMode('borderlessScreenshotArrange'));
        borderlessFileInput2.addEventListener('change', borderlessHandleFileSelect);
        borderlessProcessButton.addEventListener('click', borderlessProcessImages);
        borderlessDownloadButton.addEventListener('click', borderlessDownloadProcessedImage);
        borderlessClearAllButton.addEventListener('click', borderlessClearAllImages);

        logoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (currentMode === 'adaSpecial') {
                        adaSpecialLogo = new Image();
                        adaSpecialLogo.src = e.target.result;
                        adaSpecialLogoFileName = file.name;
                        localStorage.setItem('lastUsedAdaLogo', e.target.result);
                        localStorage.setItem('lastUsedAdaLogoName', file.name);
                        updateLogoPreview(e.target.result, file.name, 'é˜¿é”å°ˆç”¨');
                    } else if (currentMode === 'addWatermark') {
                        logoImage = new Image();
                        logoImage.src = e.target.result;
                        logoFileName = file.name;
                        localStorage.setItem('lastUsedLogo', e.target.result);
                        localStorage.setItem('lastUsedLogoName', file.name);
                        updateLogoPreview(e.target.result, file.name, 'ä¸€èˆ¬');
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        function updateLogoPreview(src, name, type) {
            logoPreview.src = src;
            logoPreview.style.display = 'block';
            logoStatus.textContent = `å·²è¼‰å…¥${type} Logo: ${name}`;
        }

        function setMode(mode) {
            // å¦‚æœä½¿ç”¨è€…å†æ¬¡é»æ“Šç•¶å‰æ¨¡å¼çš„æŒ‰éˆ•ï¼Œå‰‡é‡ç½®è©²æ¨¡å¼çš„ä»‹é¢
            if (mode === currentMode) {
                if (mode === 'screenshotArrange') {
                    clearAllImages();
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    downloadButton.style.display = 'none';
                    document.getElementById('editTools').style.display = 'none';
                    updateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (mode === 'borderlessScreenshotArrange') {
                    borderlessClearAllImages();
                    borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
                    borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height); // æ¸…é™¤ç·¨è¼¯ç•«å¸ƒ
                    borderlessDownloadButton.style.display = 'none';
                    document.getElementById('borderlessEditTools').style.display = 'none';
                    borderlessUpdateFileInputAndCount();
                    return; // é‡ç½®å¾Œåœç•™åœ¨è©²ä»‹é¢
                }
                if (['resize320', 'resize1080', 'addWatermark', 'adaSpecial'].includes(mode)) {
                    previewArea.style.display = 'none';
                    status.innerHTML = '';
                    fileInput.value = '';
                    dropZone.style.display = 'flex';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
                if (mode === 'cropImage') {
                    cancelCrop();
                    cropImageArea.style.display = 'none';
                    dropZone.style.display = 'flex';
                    status.innerHTML = '';
                    fileInput.value = '';
                    return; // é‡ç½®å¾Œè¿”å›åˆå§‹ä»‹é¢
                }
            }

            currentMode = mode;
            [resize320ModeBtn, resize1080ModeBtn, addWatermarkModeBtn, adaSpecialModeBtn, screenshotArrangeModeBtn, cropImageModeBtn, borderlessScreenshotArrangeModeBtn, chineseConvModeBtn, htmlCleanerModeBtn, magicRemoverModeBtn].forEach(btn => btn.classList.remove('active'));

            selectLogoBtn.style.display = 'none';
            selectAdaLogoBtn.style.display = 'none';
            logoPreview.style.display = 'none';
            logoStatus.textContent = '';
            screenshotArrangeDiv.style.display = 'none';
            borderlessScreenshotArrangeDiv.style.display = 'none';
            cropImageArea.style.display = 'none';
            chineseConvArea.style.display = 'none';
            htmlCleanerArea.style.display = 'none';
            magicRemoverArea.style.display = 'none';

            // æ¸…é™¤ä¹‹å‰çš„è™•ç†æª”æ¡ˆè³‡è¨Š
            status.innerHTML = '';

            // ç„¡è«–ä¹‹å‰çš„ç‹€æ…‹å¦‚ä½•ï¼Œåˆ‡æ›æ¨¡å¼æ™‚ä¸€å¾‹é‡ç½®ç‚ºåˆå§‹ç‹€æ…‹
            dropZone.style.display = 'flex';
            fileInput.style.display = 'none';
            previewArea.style.display = 'none';

            // æ¸…é™¤é è¦½ Canvas
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewCanvas.width = 0;
            previewCanvas.height = 0;
            previewEditCanvas.width = 0;
            previewEditCanvas.height = 0;

            if (mode === 'resize320') {
                resize320ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡çŸ­é‚Šï¼ˆ320pxï¼‰';
            } else if (mode === 'resize1080') {
                resize1080ModeBtn.classList.add('active');
                pageTitle.textContent = 'ä¿®æ”¹åœ–ç‰‡é•·é‚Šï¼ˆ1000pxï¼‰';
            } else if (mode === 'addWatermark') {
                addWatermarkModeBtn.classList.add('active');
                pageTitle.textContent = 'æ·»åŠ æµ®æ°´å°';
                selectLogoBtn.style.display = 'inline-block';
                if (logoImage) {
                    updateLogoPreview(logoImage.src, logoFileName, 'ä¸€èˆ¬');
                }
            } else if (mode === 'adaSpecial') {
                adaSpecialModeBtn.classList.add('active');
                pageTitle.textContent = 'é›»è…¦ç‹é˜¿é”å°ˆç”¨';
                selectAdaLogoBtn.style.display = 'inline-block';
                if (adaSpecialLogo) {
                    updateLogoPreview(adaSpecialLogo.src, adaSpecialLogoFileName, 'é˜¿é”å°ˆç”¨');
                }
            } else if (mode === 'screenshotArrange') {
                screenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'æˆªåœ–ä¸¦æ’';
                screenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'borderlessScreenshotArrange') {
                borderlessScreenshotArrangeModeBtn.classList.add('active');
                pageTitle.textContent = 'ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’';
                borderlessScreenshotArrangeDiv.style.display = 'block';
                dropZone.style.display = 'none';
                previewArea.style.display = 'none';
                borderlessUpdateFileInputAndCount(); // ğŸ”§ Initialize file count display
            } else if (mode === 'cropImage') {
                cropImageModeBtn.classList.add('active');
                pageTitle.textContent = 'åœ–ç‰‡è£åˆ‡';
                cropImageArea.style.display = 'block';
                dropZone.style.display = 'flex';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'chineseConv') {
                chineseConvModeBtn.classList.add('active');
                pageTitle.textContent = 'ç¹ç°¡è½‰æ›';
                chineseConvArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
                magicRemoverArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            } else if (mode === 'htmlCleaner') {
                htmlCleanerModeBtn.classList.add('active');
                pageTitle.textContent = 'å»é™¤ç„¡ç”¨å­—å…ƒ';
                htmlCleanerArea.style.display = 'block';
                dropZone.style.display = 'none';
                fileInput.style.display = 'none';
                previewArea.style.display = 'none';
            }

            // æ¸…é™¤æª”æ¡ˆè¼¸å…¥
            fileInput.value = '';
        }

        function handleFiles(e) {
            console.log('handleFiles triggered');
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
            processFiles(files);
        }

        async function processFiles(files) {
            console.log('processFiles triggered', files);
            status.innerHTML = 'é–‹å§‹è™•ç†æª”æ¡ˆ...';

            // åªè™•ç†ç¬¬ä¸€å¼µåœ–ç‰‡é€²è¡Œé è¦½
            const file = files[0];
            if (file && file.type.startsWith('image/')) {
                try {
                    let result = null;
                    if (currentMode === 'resize320') {
                        result = await processImageForPreview(file, 'resize320');
                    } else if (currentMode === 'resize1080') {
                        result = await processImageForPreview(file, 'resize1080');
                    } else if (currentMode === 'addWatermark') {
                        if (logoImage) {
                            result = await processImageForPreview(file, 'addWatermark');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'adaSpecial') {
                        if (adaSpecialLogo) {
                            result = await processImageForPreview(file, 'adaSpecial');
                        } else {
                            status.innerHTML += '<br>è«‹å…ˆé¸æ“‡é˜¿é”å°ˆç”¨ Logo å¾Œå†ä¸Šå‚³åœ–ç‰‡ã€‚';
                            return;
                        }
                    } else if (currentMode === 'cropImage') { // æ–°å¢ï¼šè£åˆ‡æ¨¡å¼è™•ç†
                        handleCropFileSelect({ target: { files: [file] } }); // æ¨¡æ“¬äº‹ä»¶å°è±¡
                        status.innerHTML += '<br>åœ–ç‰‡å·²è¼‰å…¥è£åˆ‡å€ï¼Œè«‹ç¹ªè£½è£åˆ‡ç¯„åœã€‚';
                        return; // è£åˆ‡æ¨¡å¼ä¸‹ä¸é€²å…¥é è¦½å€ï¼Œç›´æ¥é¡¯ç¤ºè£åˆ‡ä»‹é¢
                    }

                    if (result && result.canvas) {
                        const filename = file.name.replace(/\.[^/.]+$/, ".jpg");
                        showPreview(result.canvas, filename);
                        status.innerHTML += '<br>è™•ç†å®Œæˆï¼è«‹æŸ¥çœ‹é è¦½çµæœã€‚';
                    }
                } catch (error) {
                    console.error('è™•ç†éŒ¯èª¤:', error);
                    status.innerHTML += '<br>è™•ç†å¤±æ•—: ' + error.message;
                }
            }
        }

        async function resizeImage(file, targetSize, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let newWidth, newHeight;

                        const longSide = Math.max(img.width, img.height);

                        if (longSide <= targetSize) {
                            newWidth = img.width;
                            newHeight = img.height;
                        } else if (img.width > img.height) {
                            newWidth = targetSize;
                            newHeight = (img.height / img.width) * targetSize;
                        } else {
                            newHeight = targetSize;
                            newWidth = (img.width / img.height) * targetSize;
                        }

                        // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾æŠ€è¡“
                        const sourceCanvas = document.createElement('canvas');
                        sourceCanvas.width = img.width;
                        sourceCanvas.height = img.height;
                        const sourceCtx = sourceCanvas.getContext('2d');
                        setupHighQualityCanvas(sourceCtx);
                        sourceCtx.drawImage(img, 0, 0);

                        const quality = scalingQuality.value;
                        const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                        canvas.width = scaledCanvas.width;
                        canvas.height = scaledCanvas.height;
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(scaledCanvas, 0, 0);

                        // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
                        let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
                        switch (quality) {
                            case 'ultra':
                                jpegQuality = 0.99; // æœ€é«˜å“è³ª
                                break;
                            case 'high':
                                jpegQuality = 0.95; // é«˜å“è³ª
                                break;
                            case 'balanced':
                                jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                                break;
                            case 'fast':
                                jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                                break;
                        }

                        console.log(`ä½¿ç”¨JPEGå“è³ª: ${jpegQuality}`);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const resizedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                console.log(`è¼¸å‡ºæª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                                if (returnBlob) {
                                    resolve(resizedFile);
                                } else {
                                    saveAs(resizedFile);
                                    status.innerHTML += ` - èª¿æ•´å¤§å°æˆåŠŸï¼(å“è³ª: ${quality}, æª”æ¡ˆå¤§å°: ${(blob.size / 1024 / 1024).toFixed(2)} MB)`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºèª¿æ•´å¤§å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', jpegQuality);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function addWatermark(file, logo, returnBlob = false) {
            return new Promise((resolve, reject) => {
                try {
                    status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        canvas.width = img.width;
                        canvas.height = img.height;

                        // è¨­ç½®é«˜å“è³ªç¸®æ”¾
                        setupHighQualityCanvas(ctx);
                        ctx.drawImage(img, 0, 0, img.width, img.height);

                        // Logo å°ºå¯¸ç¸®å°30%
                        const logoWidth = logo.width * 0.7;
                        const logoHeight = logo.height * 0.7;

                        // è¨ˆç®— Logo ä½ç½®ï¼ˆå³ä¸‹è§’ï¼Œè·é›¢é‚Šç·£ 15 åƒç´ ï¼‰
                        const logoX = img.width - logoWidth - 15;
                        const logoY = img.height - logoHeight - 15;

                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(logo, logoX, logoY, logoWidth, logoHeight);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                const watermarkedFile = new File([blob], file.name.replace(/\.[^/.]+$/, ".jpg"), { type: "image/jpeg" });
                                if (returnBlob) {
                                    resolve(watermarkedFile);
                                } else {
                                    saveAs(watermarkedFile);
                                    status.innerHTML += ` - æ·»åŠ æµ®æ°´å°æˆåŠŸï¼`;
                                    resolve();
                                }
                            } else {
                                reject(new Error('ç„¡æ³•å‰µå»ºæ·»åŠ æµ®æ°´å°å¾Œçš„ blob'));
                            }
                        }, 'image/jpeg', 0.98);
                    };
                    img.src = URL.createObjectURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function adaSpecialProcess(file) {
            try {
                console.log('é–‹å§‹é˜¿é”å°ˆç”¨è™•ç†');
                status.innerHTML += `<br>æ­£åœ¨è™•ç†: ${file.name}`;

                console.log('æ­¥é©Ÿ 1: èª¿æ•´åœ–ç‰‡å¤§å°');
                status.innerHTML += `<br>- èª¿æ•´åœ–ç‰‡å¤§å°ä¸­...`;
                let processedImage = await resizeImage(file, 1000, true);

                console.log('æ­¥é©Ÿ 2: æ·»åŠ æµ®æ°´å°');
                status.innerHTML += `<br>- æ·»åŠ æµ®æ°´å°ä¸­...`;
                if (!adaSpecialLogo) {
                    throw new Error('é˜¿é”å°ˆç”¨ Logo æœªè¨­ç½®');
                }
                processedImage = await addWatermark(processedImage, adaSpecialLogo, true);

                console.log('å„²å­˜æœ€çµ‚åœ–ç‰‡');
                saveAs(processedImage);
                status.innerHTML += `<br>é›»è…¦ç‹é˜¿é”å°ˆç”¨è™•ç†å®Œæˆï¼`;
            } catch (error) {
                console.error('é˜¿é”å°ˆç”¨è™•ç†éŒ¯èª¤:', error);
                status.innerHTML += `<br>è™•ç†å¤±æ•—: ${error.message}`;
            }
        }

        // é«˜å“è³ªCanvasè¨­ç½®å‡½æ•¸
        function setupHighQualityCanvas(ctx) {
            // è¨­ç½®é«˜å“è³ªåœ–åƒç¸®æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            // é‡å°æ–‡å­—å„ªåŒ–çš„è¨­ç½®
            ctx.textRenderingOptimization = 'optimizeQuality';
        }

        // ============ ä¸åŒå“è³ªçš„Canvasè¨­ç½® ============

        function setupUltraQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            // è¶…é«˜å“è³ªè¨­ç½®
            ctx.globalCompositeOperation = 'source-over';
        }

        function setupBalancedQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        function setupFastQualityCanvas(ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'low';
            ctx.textRenderingOptimization = 'optimizeSpeed';
        }

        // æ·»åŠ é»‘æ¡†å‡½æ•¸
        function addBlackBorder(canvas) {
            const borderedCanvas = document.createElement('canvas');
            const borderedCtx = borderedCanvas.getContext('2d');

            // æ–°canvaså°ºå¯¸ç‚ºåŸå°ºå¯¸+2pxï¼ˆä¸Šä¸‹å„1pxï¼Œå·¦å³å„1pxï¼‰
            borderedCanvas.width = canvas.width + 2;
            borderedCanvas.height = canvas.height + 2;

            // å¡«å……é»‘è‰²èƒŒæ™¯
            borderedCtx.fillStyle = 'black';
            borderedCtx.fillRect(0, 0, borderedCanvas.width, borderedCanvas.height);

            // åœ¨ä¸­å¤®ç¹ªè£½åŸå§‹åœ–ç‰‡
            borderedCtx.drawImage(canvas, 1, 1);

            return borderedCanvas;
        }

        // è™•ç†åœ–ç‰‡ä¸¦è¿”å›canvasï¼ˆé è¦½æ¨¡å¼ï¼‰
        async function processImageForPreview(file, mode) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
                        const quality = scalingQuality.value;
                        console.log(`ğŸ¯ è™•ç†æ¨¡å¼: ${mode}, å“è³ªè¨­å®š: ${quality}`);

                        if (mode === 'resize320') {
                            // çŸ­é‚Šç¸®æ”¾åˆ°320px
                            const shortSide = Math.min(img.width, img.height);
                            let newWidth, newHeight;

                            if (shortSide <= 320) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width < img.height) {
                                // ç›´ç‰ˆåœ–ç‰‡ï¼Œå¯¬åº¦æ˜¯çŸ­é‚Š
                                newWidth = 320;
                                newHeight = (img.height / img.width) * 320;
                            } else {
                                // æ©«ç‰ˆåœ–ç‰‡ï¼Œé«˜åº¦æ˜¯çŸ­é‚Š
                                newHeight = 320;
                                newWidth = (img.width / img.height) * 320;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'resize1080') {
                            // é•·é‚Šç¸®æ”¾åˆ°1000px
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(scaledCanvas);
                            resolve({ canvas: borderedCanvas });

                        } else if (mode === 'addWatermark') {
                            // æ·»åŠ æµ®æ°´å° - ğŸ”¥ ä½¿ç”¨å“è³ªè¨­å®š
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');

                            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
                            switch (quality) {
                                case 'ultra':
                                    setupUltraQualityCanvas(ctx);
                                    break;
                                case 'high':
                                    setupHighQualityCanvas(ctx);
                                    break;
                                case 'balanced':
                                    setupBalancedQualityCanvas(ctx);
                                    break;
                                case 'fast':
                                    setupFastQualityCanvas(ctx);
                                    break;
                                default:
                                    setupBalancedQualityCanvas(ctx);
                            }

                            ctx.drawImage(img, 0, 0);

                            // æ·»åŠ æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = logoImage.width * 0.7;
                            const logoHeight = logoImage.height * 0.7;
                            const logoX = img.width - logoWidth - 15;
                            const logoY = img.height - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);

                            resolve({ canvas: canvas });

                        } else if (mode === 'adaSpecial') {
                            // é˜¿é”å°ˆç”¨ï¼šç¸®æ”¾ + æµ®æ°´å° + é»‘æ¡†
                            const longSide = Math.max(img.width, img.height);
                            let newWidth, newHeight;

                            if (longSide <= 1000) {
                                newWidth = img.width;
                                newHeight = img.height;
                            } else if (img.width > img.height) {
                                newWidth = 1000;
                                newHeight = (img.height / img.width) * 1000;
                            } else {
                                newHeight = 1000;
                                newWidth = (img.width / img.height) * 1000;
                            }

                            // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                            const sourceCanvas = document.createElement('canvas');
                            sourceCanvas.width = img.width;
                            sourceCanvas.height = img.height;
                            const sourceCtx = sourceCanvas.getContext('2d');
                            setupHighQualityCanvas(sourceCtx);
                            sourceCtx.drawImage(img, 0, 0);

                            const scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                            const canvas = document.createElement('canvas');
                            canvas.width = scaledCanvas.width;
                            canvas.height = scaledCanvas.height;
                            const ctx = canvas.getContext('2d');
                            setupHighQualityCanvas(ctx);
                            ctx.drawImage(scaledCanvas, 0, 0);

                            // æ·»åŠ é˜¿é”å°ˆç”¨æµ®æ°´å°ï¼ˆç¸®å°30%ï¼‰
                            const logoWidth = adaSpecialLogo.width * 0.7;
                            const logoHeight = adaSpecialLogo.height * 0.7;
                            const logoX = newWidth - logoWidth - 15;
                            const logoY = newHeight - logoHeight - 15;

                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(adaSpecialLogo, logoX, logoY, logoWidth, logoHeight);

                            // æ·»åŠ é»‘æ¡†
                            const borderedCanvas = addBlackBorder(canvas);
                            resolve({ canvas: borderedCanvas });
                        }

                    } catch (error) {
                        reject(error);
                    }
                };
                img.onerror = () => reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
                img.src = URL.createObjectURL(file);
            });
        }

        // é¡¯ç¤ºé è¦½çµæœ
        function showPreview(canvas, filename) {
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCtx.drawImage(canvas, 0, 0);

            // è¨­ç½®ç·¨è¼¯canvas
            previewEditCanvas.width = canvas.width;
            previewEditCanvas.height = canvas.height;
            previewEditCanvas.style.display = 'block';

            // å„²å­˜ä¸‹è¼‰ä¿¡æ¯
            previewCanvas.downloadFilename = filename;

            // åˆå§‹åŒ–ç·¨è¼¯æ­·å²
            previewClearEdits();
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];

            // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•å’Œé è¦½å€åŸŸ
            previewDownloadButton.style.display = 'block';
            downloadPNGButton.style.display = 'inline-block';
            previewArea.style.display = 'block';
            dropZone.style.display = 'none';
        }

        // é è¦½ç·¨è¼¯å·¥å…·å‡½æ•¸
        function previewStartDrawing(e) {
            if (!previewCurrentTool) return;
            previewIsDrawing = true;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            previewStartX = (e.clientX - rect.left) * scaleX;
            previewStartY = (e.clientY - rect.top) * scaleY;

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewStopDrawing() {
            if (!previewIsDrawing) return;
            previewIsDrawing = false;
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));
        }

        function previewDraw(e) {
            if (!previewIsDrawing || !previewCurrentTool) return;

            // ğŸ”¥ ä¿®æ­£ï¼šåº§æ¨™æ˜ å°„ (è™•ç† CSS ç¸®æ”¾)
            const rect = previewEditCanvas.getBoundingClientRect();
            const scaleX = previewEditCanvas.width / rect.width;
            const scaleY = previewEditCanvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            if (previewEditHistory.length > 0) {
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
            }

            previewEditCtx.beginPath();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.lineWidth = 3;

            if (previewCurrentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX + 3, previewStartY + 3, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                previewEditCtx.save();
                previewEditCtx.strokeStyle = 'red';
                previewEditCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                previewEditCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                previewEditCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                previewEditCtx.beginPath();
                previewEditCtx.rect(previewStartX, previewStartY, endX - previewStartX, endY - previewStartY);
                previewEditCtx.stroke();

                previewEditCtx.restore();
            } else if (previewCurrentTool === 'arrow') {
                previewDrawArrow(previewStartX, previewStartY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (previewCurrentTool === 'mosaic') {
                // ğŸ”¥ ä¿®æ­£ï¼šé¦¬è³½å…‹å·¥å…·éœ€è¦æ•´æ•¸åº§æ¨™
                const x = Math.round(Math.min(previewStartX, endX));
                const y = Math.round(Math.min(previewStartY, endY));
                const width = Math.round(Math.abs(endX - previewStartX));
                const height = Math.round(Math.abs(endY - previewStartY));

                if (width > 0 && height > 0) {
                    previewDrawMosaic(x, y, width, height);
                }
            }

            previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
        }

        function previewDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX + 2, fromY + 2);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX + 2, toY + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            previewEditCtx.save();
            previewEditCtx.strokeStyle = 'red';
            previewEditCtx.fillStyle = 'red';
            previewEditCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            previewEditCtx.lineCap = 'round';
            previewEditCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(fromX, fromY);
            previewEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            previewEditCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            previewEditCtx.beginPath();
            previewEditCtx.moveTo(toX, toY);
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            previewEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            previewEditCtx.closePath();
            previewEditCtx.fill();

            previewEditCtx.restore();
        }

        function previewDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = previewCtx.getImageData(x, y, width, height);
            const stride = imageData.width; // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨å¯¦éš›çš„ imageData å¯¬åº¦ä½œç‚º stride

            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = previewGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height, stride);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                            const index = ((j + my) * stride + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            previewEditCtx.putImageData(imageData, x, y);
        }

        function previewGetAverageColor(imageData, startX, startY, size, width, height, stride) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ stride è¨ˆç®—ç´¢å¼•
                    const index = ((startY + j) * stride + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        function previewUndo() {
            if (previewEditHistory.length > 1) {
                previewEditHistory.pop();
                previewEditCtx.putImageData(previewEditHistory[previewEditHistory.length - 1], 0, 0);
                previewBaseEditState = previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            } else {
                previewClearEdits();
            }
        }

        function previewClearEdits() {
            previewEditCtx.clearRect(0, 0, previewEditCanvas.width, previewEditCanvas.height);
            previewEditHistory = [previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height)];
            previewBaseEditState = null;
        }

        // ä¸‹è¼‰é è¦½åœ–ç‰‡
        function downloadPreviewImage() {
            const filename = previewCanvas.downloadFilename || 'processed_image.jpg';

            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰JPG: å“è³ªè¨­å®š ${quality}`);

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            // ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦ç¸®æ”¾è‡³ 1000px (é‡å°è£åˆ‡æ¨¡å¼çš„é«˜è§£æåº¦åœ–ç‰‡)
            // æ³¨æ„ï¼šå¦‚æœå·²ç¶“æ˜¯è£åˆ‡æ¨¡å¼ä¸”å·²ç¶“åœ¨ executeCrop ä¸­ç¸®æ”¾éå¯¬åº¦ï¼Œé€™è£¡å°±ä¸æ‡‰è©²å†å¼·åˆ¶ç¸®æ”¾é•·é‚Š
            // é™¤éä½¿ç”¨è€…æ²’æœ‰ç¶“éè£åˆ‡æµç¨‹ (ä¸å¤ªå¯èƒ½ï¼Œå› ç‚º cropImage æ¨¡å¼ä¸‹å¿…é ˆå…ˆè£åˆ‡)
            // ä½†ç‚ºäº†ä¿éšªèµ·è¦‹ï¼Œæˆ‘å€‘å¯ä»¥æª¢æŸ¥ currentMode

            let outputCanvas = finalCanvas;
            const longSide = Math.max(finalCanvas.width, finalCanvas.height);

            // åªæœ‰åœ¨éè£åˆ‡æ¨¡å¼ä¸‹ï¼Œæˆ–è€…è£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦ç•°å¸¸å¤§æ™‚æ‰åŸ·è¡Œæ­¤è™•çš„ç¸®æ”¾
            // ä½†æ ¹æ“šæ–°éœ€æ±‚ï¼Œè£åˆ‡æ¨¡å¼ä¸‹å¯¬åº¦å·²ç¶“æ˜¯ 1000pxï¼Œæ‰€ä»¥é€™è£¡æ‡‰è©²è·³é
            if (currentMode !== 'cropImage' && longSide > 1000) {
                console.log(`ğŸ”½ ä¸‹è¼‰å‰ç¸®æ”¾: åŸå§‹å°ºå¯¸ ${finalCanvas.width}x${finalCanvas.height} -> é•·é‚Šé™åˆ¶ 1000px`);
                let newWidth, newHeight;
                if (finalCanvas.width > finalCanvas.height) {
                    newWidth = 1000;
                    newHeight = (finalCanvas.height / finalCanvas.width) * 1000;
                } else {
                    newHeight = 1000;
                    newWidth = (finalCanvas.width / finalCanvas.height) * 1000;
                }

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾
                outputCanvas = safeAdvancedImageScale(finalCanvas, newWidth, newHeight, quality);
            }

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰JPG: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            outputCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename, { type: "image/jpeg" });
                    console.log(`ğŸ”½ ä¸‹è¼‰JPG: æª”æ¡ˆå¤§å° ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                    saveAs(file);
                }
            }, 'image/jpeg', jpegQuality);
        }

        // ä¸‹è¼‰PNGæ ¼å¼é è¦½åœ–ç‰‡ï¼ˆæœ€é«˜ç•«è³ªï¼‰
        function downloadPreviewImageAsPNG() {
            const filename = previewCanvas.downloadFilename || 'processed_image.png';

            // å‰µå»ºåˆæˆcanvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = previewCanvas.width;
            finalCanvas.height = previewCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // è¨­ç½®é«˜å“è³ªç¸®æ”¾
            setupHighQualityCanvas(finalCtx);

            // ç¹ªè£½åŸå§‹è™•ç†å¾Œçš„åœ–ç‰‡
            finalCtx.drawImage(previewCanvas, 0, 0);
            // ç¹ªè£½ç·¨è¼¯å…§å®¹
            finalCtx.drawImage(previewEditCanvas, 0, 0);

            finalCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], filename.replace(/\.[^/.]+$/, ".png"), { type: "image/png" });
                    saveAs(file);
                }
            }, 'image/png');
        }

        function saveAs(blob) {
            const a = document.createElement("a");
            document.body.appendChild(a);
            a.style.display = "none";
            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = blob.name;

            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Crop Watermark Variables
        let cropLogoImage = null;
        // const cropLogoInput = document.getElementById('cropLogoInput'); // Removed
        // const cropLogoStatus = document.getElementById('cropLogoStatus'); // Removed

        // Preview Watermark Tool Variables
        const previewWatermarkTool = document.getElementById('previewWatermarkTool');
        const previewWatermarkInput = document.getElementById('previewWatermarkInput');

        // Load saved watermark from localStorage
        const savedWatermarkData = localStorage.getItem('cropWatermarkData');
        if (savedWatermarkData) {
            cropLogoImage = new Image();
            cropLogoImage.src = savedWatermarkData;
        }

        if (previewWatermarkTool) {
            previewWatermarkTool.addEventListener('click', () => {
                if (cropLogoImage) {
                    applyWatermarkToPreview();
                } else {
                    previewWatermarkInput.click();
                }
            });
        }

        if (previewWatermarkInput) {
            previewWatermarkInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        cropLogoImage = new Image();
                        cropLogoImage.onload = function () {
                            // Save to localStorage
                            localStorage.setItem('cropWatermarkData', event.target.result);

                            // Determine which mode is active and apply watermark accordingly
                            if (document.getElementById('previewArea').style.display !== 'none') {
                                applyWatermarkToPreview();
                            } else if (document.getElementById('screenshotArrange').style.display !== 'none') {
                                applyWatermarkToArrange(cropLogoImage);
                            } else if (document.getElementById('borderlessScreenshotArrange').style.display !== 'none') {
                                applyWatermarkToBorderlessArrange(cropLogoImage);
                            }
                        };
                        cropLogoImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function applyWatermarkToPreview() {
            if (!cropLogoImage) return;

            // Save current state for undo
            previewEditHistory.push(previewEditCtx.getImageData(0, 0, previewEditCanvas.width, previewEditCanvas.height));

            const ctx = previewEditCtx;

            // Watermark scaling (shrink 30%)
            const logoWidth = cropLogoImage.width * 0.7;
            const logoHeight = cropLogoImage.height * 0.7;

            // Position: Bottom-right, 15px margin
            // Note: previewEditCanvas size matches the preview image size
            const logoX = previewEditCanvas.width - logoWidth - 15;
            const logoY = previewEditCanvas.height - logoHeight - 15;

            ctx.save();
            ctx.globalAlpha = 0.5; // 50% opacity
            ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            ctx.restore();

            console.log('Watermark applied to preview edit canvas');
        }

        function handleCropFileSelect(event) {
            console.log('handleCropFileSelect triggered', event);
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                console.log('File is an image:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    console.log('FileReader onload triggered');
                    originalCropImage = new Image();
                    originalCropImage.onload = () => {
                        console.log('originalCropImage onload triggered', originalCropImage.width, originalCropImage.height);
                        let displayWidth = originalCropImage.width;
                        let displayHeight = originalCropImage.height;
                        let scaleFactor = 1; // æ–°å¢ï¼šç¸®æ”¾å› å­

                        // å¦‚æœåœ–ç‰‡å¯¬åº¦æˆ–é«˜åº¦è¶…éæœ€å¤§é™åˆ¶ï¼Œå‰‡æŒ‰æ¯”ä¾‹ç¸®æ”¾
                        if (displayWidth > MAX_CROP_WIDTH || displayHeight > MAX_CROP_HEIGHT) {
                            const aspectRatio = displayWidth / displayHeight;
                            if (displayWidth / MAX_CROP_WIDTH > displayHeight / MAX_CROP_HEIGHT) {
                                scaleFactor = MAX_CROP_WIDTH / displayWidth;
                                displayWidth = MAX_CROP_WIDTH;
                                displayHeight = displayWidth / aspectRatio;
                            } else {
                                scaleFactor = MAX_CROP_HEIGHT / displayHeight;
                                displayHeight = MAX_CROP_HEIGHT;
                                displayWidth = displayHeight * aspectRatio;
                            }
                        }

                        cropCanvas.width = displayWidth;
                        cropCanvas.height = displayHeight;
                        cropCtx.drawImage(originalCropImage, 0, 0, displayWidth, displayHeight);

                        cropSelectionCanvas.width = displayWidth;
                        cropSelectionCanvas.height = displayHeight;
                        cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

                        // é‡ç½®è£åˆ‡é¸å€
                        cropSelection = { x: 0, y: 0, width: 0, height: 0, scaleFactor: scaleFactor }; // æ–°å¢ï¼šå„²å­˜ç¸®æ”¾å› å­
                        isCropping = false;
                        cropImageArea.style.display = 'block'; // ç¢ºä¿è£åˆ‡å€åŸŸé¡¯ç¤º
                    };
                    originalCropImage.onerror = () => {
                        console.error('Error loading originalCropImage');
                        status.innerHTML += '<br>åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥åœ–ç‰‡æª”æ¡ˆã€‚';
                    };
                    originalCropImage.src = e.target.result;
                    console.log('originalCropImage.src set');
                };
                reader.readAsDataURL(file);
            }
        }

        function startCropDrawing(e) {
            console.log('startCropDrawing triggered');
            isCropping = true;
            [cropStartX, cropStartY] = [e.offsetX, e.offsetY];
            cropEndX = cropStartX;
            cropEndY = cropStartY;
        }

        function drawCropSelection(e) {
            if (!isCropping) return;
            cropEndX = e.offsetX;
            cropEndY = e.offsetY;

            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);

            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);

            // ç¹ªè£½åŠé€æ˜é®ç½© (å››å€‹çŸ©å½¢è¦†è“‹é¸å€å¤–)
            cropSelectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            // Top rectangle
            cropSelectionCtx.fillRect(0, 0, cropSelectionCanvas.width, y);
            // Bottom rectangle
            cropSelectionCtx.fillRect(0, y + height, cropSelectionCanvas.width, cropSelectionCanvas.height - (y + height));
            // Left rectangle
            cropSelectionCtx.fillRect(0, y, x, height);
            // Right rectangle
            cropSelectionCtx.fillRect(x + width, y, cropSelectionCanvas.width - (x + width), height);

            // ç¹ªè£½é¸å€é‚Šæ¡†
            cropSelectionCtx.strokeStyle = 'red';
            cropSelectionCtx.lineWidth = 2;
            cropSelectionCtx.strokeRect(x, y, width, height);

            cropSelection = { x, y, width, height, scaleFactor: cropSelection.scaleFactor };
        }

        function stopCropDrawing() {
            isCropping = false;
        }

        function executeCrop() {
            if (!originalCropImage || cropSelection.width === 0 || cropSelection.height === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ä¸¦ç¹ªè£½è£åˆ‡ç¯„åœã€‚');
                return;
            }

            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨åŸå§‹åœ–ç‰‡çš„çœŸå¯¦å°ºå¯¸é€²è¡Œè£åˆ‡ï¼Œè€Œä¸æ˜¯é è¦½å°ºå¯¸
            // cropSelection ç´€éŒ„çš„æ˜¯åœ¨ canvas (é è¦½åœ–) ä¸Šçš„åº§æ¨™
            // æˆ‘å€‘éœ€è¦å°‡å…¶è½‰æ›å›åŸå§‹åœ–ç‰‡çš„åº§æ¨™

            // 1. è¨ˆç®—é è¦½åœ–èˆ‡åŸå§‹åœ–çš„æ¯”ä¾‹
            // cropCanvas.width æ˜¯é è¦½ canvas çš„å¯¬åº¦
            // originalCropImage.width æ˜¯åŸå§‹åœ–ç‰‡çš„å¯¬åº¦
            // ä½†æ³¨æ„ï¼šåœ¨ handleCropFileSelect ä¸­ï¼Œæˆ‘å€‘å¯èƒ½å·²ç¶“å°é¡¯ç¤ºé€²è¡Œäº†ç¸®æ”¾ (scaleFactor)
            // å¯¦éš›ä¸Šï¼ŒcropSelection.scaleFactor å·²ç¶“ç´€éŒ„äº† (é è¦½å¯¬åº¦ / åŸå§‹å¯¬åº¦) çš„æ¯”ä¾‹å—ï¼Ÿ
            // è®“æˆ‘å€‘é‡æ–°æª¢æŸ¥ handleCropFileSelect çš„é‚è¼¯

            // åœ¨ handleCropFileSelect ä¸­:
            // scaleFactor = MAX_CROP_WIDTH / displayWidth; (å¦‚æœéœ€è¦ç¸®å°é¡¯ç¤º)
            // cropCanvas.width = displayWidth (é€™æ˜¯ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦)
            // cropCtx.drawImage(originalCropImage, ..., displayWidth, displayHeight)

            // æ‰€ä»¥ï¼ŒcropSelection ä¸Šçš„åº§æ¨™æ˜¯åŸºæ–¼ "ç¸®å°å¾Œçš„é¡¯ç¤ºå¯¬åº¦"
            // è¦æ‹¿åˆ°åŸå§‹åœ–ç‰‡çš„åº§æ¨™ï¼Œæˆ‘å€‘éœ€è¦é™¤ä»¥ scaleFactor (å¦‚æœ scaleFactor æ˜¯ é¡¯ç¤º/åŸå§‹)
            // ç­‰ç­‰ï¼ŒhandleCropFileSelect ä¸­çš„ scaleFactor å®šç¾©æ˜¯ï¼š
            // if (displayWidth > MAX_CROP_WIDTH ...) { scaleFactor = MAX_CROP_WIDTH / original_width }
            // æ‰€ä»¥ cropSelection.x / scaleFactor æ‡‰è©²å°±æ˜¯åŸå§‹åº§æ¨™

            // è®“æˆ‘å€‘ç¢ºèªä¸€ä¸‹ cropSelection.scaleFactor çš„å€¼
            const scale = cropSelection.scaleFactor || 1;

            const sourceX = cropSelection.x / scale;
            const sourceY = cropSelection.y / scale;
            const sourceWidth = cropSelection.width / scale;
            const sourceHeight = cropSelection.height / scale;

            console.log(`è£åˆ‡è³‡è¨Š:
            é è¦½é¸å€: ${cropSelection.x}, ${cropSelection.y}, ${cropSelection.width}x${cropSelection.height}
            ç¸®æ”¾å› å­: ${scale}
            åŸå§‹åº§æ¨™: ${sourceX}, ${sourceY}, ${sourceWidth}x${sourceHeight}
            åŸå§‹åœ–ç‰‡: ${originalCropImage.width}x${originalCropImage.height}
            `);

            const croppedCanvas = document.createElement('canvas');
            // è¨­å®š canvas ç‚ºåŸå§‹è§£æåº¦çš„å¤§å°
            croppedCanvas.width = sourceWidth;
            croppedCanvas.height = sourceHeight;
            const croppedCtx = croppedCanvas.getContext('2d');

            // ä½¿ç”¨é«˜å“è³ªè¨­å®š
            setupHighQualityCanvas(croppedCtx);

            croppedCtx.drawImage(
                originalCropImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // ä¾†æºåº§æ¨™ (åŸå§‹è§£æåº¦)
                0, 0, sourceWidth, sourceHeight              // ç›®æ¨™åº§æ¨™ (åŸå§‹è§£æåº¦)
            );

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡å¯¬åº¦ç¸®è‡³ 1000px
            let finalCanvas = croppedCanvas;
            if (croppedCanvas.width > 1000) {
                console.log(`è£åˆ‡å¾Œè‡ªå‹•ç¸®æ”¾: åŸå§‹å¯¬åº¦ ${croppedCanvas.width} -> ç›®æ¨™å¯¬åº¦ 1000px`);
                const newWidth = 1000;
                const newHeight = (croppedCanvas.height / croppedCanvas.width) * 1000;

                // ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ (é è¨­ä½¿ç”¨ balanced å“è³ª)
                finalCanvas = safeAdvancedImageScale(croppedCanvas, newWidth, newHeight, 'balanced');
            }

            // ğŸ”¥ Removed auto-apply watermark logic
            // if (cropLogoImage) {
            //     const ctx = finalCanvas.getContext('2d');

            //     // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            //     const logoWidth = cropLogoImage.width * 0.7;
            //     const logoHeight = cropLogoImage.height * 0.7;

            //     // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            //     // æ³¨æ„ï¼šå¦‚æœåœ–ç‰‡è¢«ç¸®æ”¾åˆ° 1000pxï¼Œé‚Šè·ä¹Ÿæ‡‰è©²ç›¸å°èª¿æ•´ï¼Œä½†é€™è£¡å›ºå®š 15px æ‡‰è©²é‚„å¥½
            //     const logoX = finalCanvas.width - logoWidth - 15;
            //     const logoY = finalCanvas.height - logoHeight - 15;

            //     ctx.save();
            //     ctx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            //     ctx.drawImage(cropLogoImage, logoX, logoY, logoWidth, logoHeight);
            //     ctx.restore();

            //     console.log('å·²æ·»åŠ æµ®æ°´å°åˆ°è£åˆ‡åœ–ç‰‡');
            // }

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•åœ¨åœ–ç‰‡æœ€å¤–åœåŠ ä¸Š 1px é»‘é‚Š
            finalCanvas = addBlackBorder(finalCanvas);

            // å°‡è£åˆ‡å¾Œçš„åœ–ç‰‡é¡¯ç¤ºåœ¨é è¦½å€
            showPreview(finalCanvas, 'cropped_image.jpg');
            status.innerHTML = 'åœ–ç‰‡è£åˆ‡å®Œæˆï¼å·²è‡ªå‹•èª¿æ•´å¯¬åº¦ç‚º 1000pxã€‚';

            // è£åˆ‡å®Œæˆå¾Œï¼Œéš±è—è£åˆ‡å€åŸŸä¸¦é‡ç½®ç‹€æ…‹
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            cropImageArea.style.display = 'none';

            // å°‡æ¨¡å¼åˆ‡æ›å›é è¨­çš„ resize320ï¼Œä¸¦æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥
            dropZone.style.display = 'none'; // ç¢ºä¿æ‹–æ›³å€éš±è—ï¼Œå› ç‚ºé è¦½å€æœƒé¡¯ç¤º
        }

        function cancelCrop() {
            originalCropImage = null;
            // cropFileInput.value = ''; // ç§»é™¤ï¼Œå› ç‚ºå·²çµ±ä¸€ä½¿ç”¨ fileInput
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropSelectionCtx.clearRect(0, 0, cropSelectionCanvas.width, cropSelectionCanvas.height);
            cropSelection = { x: 0, y: 0, width: 0, height: 0 };
            isCropping = false;
            // setMode('resize320'); // ç§»é™¤è‡ªå‹•åˆ‡æ›æ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è‡ªè¡Œé¸æ“‡ä¸‹ä¸€æ­¥ // å–æ¶ˆå¾Œï¼Œåˆ‡æ›å›é è¨­æ¨¡å¼
        }

        // æ–°å¢çš„æˆªåœ–ä¸¦æ’åŠŸèƒ½è…³æœ¬
        const fileInput2 = document.getElementById('fileInput2');
        const fileCount = document.getElementById('fileCount');
        const processButton = document.getElementById('processButton');
        const downloadButton = document.getElementById('downloadButton');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageList = document.getElementById('imageList');
        const editCanvas = document.getElementById('editCanvas');
        const editCtx = editCanvas.getContext('2d');
        const rectangleTool = document.getElementById('rectangleTool');
        const arrowTool = document.getElementById('arrowTool');
        const watermarkTool = document.getElementById('watermarkTool');
        const undoButton = document.getElementById('undoButton');
        const clearButton = document.getElementById('clearButton');
        const clearAllButton = document.getElementById('clearAllButton');

        const ARRANGE_MAX_WIDTH = 996;
        const ARRANGE_MAX_HEIGHT = 996;
        const SPACING = 2;
        const ARRANGE_MAX_IMAGES = 4;
        const BORDER_WIDTH = 2;

        let uploadedImages = [];
        let isDrawing = false;
        let startX, startY;
        let currentTool = null;
        let editHistory = [];
        let baseEditState = null;

        fileInput2.addEventListener('change', handleFileSelect);
        processButton.addEventListener('click', processImages);
        downloadButton.addEventListener('click', downloadProcessedImage);
        rectangleTool.addEventListener('click', () => {
            currentTool = 'rectangle';
            editCanvas.style.cursor = 'crosshair';
        });
        arrowTool.addEventListener('click', () => {
            currentTool = 'arrow';
            editCanvas.style.cursor = 'crosshair';
        });
        watermarkTool.addEventListener('click', () => {
            // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
            const savedWatermark = localStorage.getItem('cropWatermarkData');
            if (savedWatermark) {
                const img = new Image();
                img.onload = () => {
                    applyWatermarkToArrange(img);
                };
                img.src = savedWatermark;
            } else {
                // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                previewWatermarkInput.click();
            }
        });
        // ç›£è½ previewWatermarkInput çš„è®ŠåŒ–ï¼Œä»¥ä¾¿åœ¨é¸æ“‡å¾Œæ‡‰ç”¨æ–¼ä¸¦æ’æ¨¡å¼
        // æ³¨æ„ï¼šé€™è£¡éœ€è¦ä¸€å€‹æ©Ÿåˆ¶ä¾†å€åˆ†æ˜¯é è¦½æ¨¡å¼é‚„æ˜¯ä¸¦æ’æ¨¡å¼è§¸ç™¼çš„
        // ç°¡å–®è§£æ³•ï¼šåœ¨ previewWatermarkInput çš„ change äº‹ä»¶ä¸­ï¼Œæª¢æŸ¥ç•¶å‰æ¨¡å¼
        // ä½†å› ç‚º previewWatermarkInput å·²ç¶“ç¶å®šäº† applyWatermarkToPreviewï¼Œ
        // æˆ‘å€‘å¯èƒ½éœ€è¦ä¸€å€‹æ–°çš„ input æˆ–è€…ä¿®æ”¹ç¾æœ‰çš„é‚è¼¯ã€‚
        // ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘é‡ç”¨ previewWatermarkInputï¼Œä½†åœ¨å…¶ change handler ä¸­åˆ¤æ–·
        // æˆ–è€…ï¼Œæˆ‘å€‘ç›´æ¥åœ¨é€™è£¡æ·»åŠ ä¸€å€‹å°ˆç”¨çš„ handlerï¼Œä½†é€™æœƒå°è‡´é‡è¤‡ç¶å®š
        // æ›´å¥½çš„æ–¹æ³•ï¼šå‰µå»ºä¸€å€‹é€šç”¨çš„è™•ç†å‡½æ•¸

        undoButton.addEventListener('click', undo);
        clearButton.addEventListener('click', clearEdits);
        clearAllButton.addEventListener('click', clearAllImages);

        editCanvas.addEventListener('mousedown', startDrawing);
        editCanvas.addEventListener('mousemove', draw);
        editCanvas.addEventListener('mouseup', stopDrawing);
        editCanvas.addEventListener('mouseout', stopDrawing);

        function updateFileInputAndCount() {
            const remainingSlots = ARRANGE_MAX_IMAGES - uploadedImages.length;
            fileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            fileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            clearAllButton.style.display = uploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, ARRANGE_MAX_IMAGES - uploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        uploadedImages.push(img);
                        updateImageList();
                        updateFileInputAndCount();
                    }
                }
                reader.readAsDataURL(file);
            });
        }

        function createImageItem(img, index) {
            const div = document.createElement('div');
            div.className = 'image-item';
            div.draggable = true;
            div.dataset.uid = img._uid; // Store unique ID in DOM
            div.innerHTML = `
                <img src="${img.src}" alt="Image ${index + 1}">
                <button class="delete-button">åˆªé™¤</button>
            `;

            div.addEventListener('dragstart', dragStart);
            div.addEventListener('dragend', dragEnd);
            div.addEventListener('dragenter', dragEnter);
            div.addEventListener('dragleave', dragLeave);
            div.addEventListener('dragover', dragOver);
            div.addEventListener('drop', drop);
            div.querySelector('.delete-button').addEventListener('click', () => deleteImage(index));

            return div;
        }

        function dragStart(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.index);
        }

        function dragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function dragEnter(e) {
            e.preventDefault();
            if (!this.classList.contains('dragging')) {
                this.classList.add('drag-over');
            }
        }

        function dragLeave(e) {
            this.classList.remove('drag-over');
        }

        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function drop(e) {
            e.preventDefault();
            const draggable = document.querySelector('.dragging');
            if (this !== draggable) {
                const allItems = [...imageList.querySelectorAll('.image-item')];
                const draggedIndex = allItems.indexOf(draggable);
                const targetIndex = allItems.indexOf(this);
                if (draggedIndex < targetIndex) {
                    this.parentNode.insertBefore(draggable, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggable, this);
                }
                updateImageOrder();
            }
            this.classList.remove('drag-over');
        }

        function updateImageOrder() {
            const newOrderIds = Array.from(imageList.children).map(item => item.dataset.uid);
            uploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));
        }

        function deleteImage(index) {
            uploadedImages.splice(index, 1);
            updateImageList();
            updateFileInputAndCount();
        }

        function updateImageList() {
            imageList.innerHTML = '';
            uploadedImages.forEach((img, index) => {
                const imageItem = createImageItem(img, index);
                imageItem.dataset.index = index;
                imageList.appendChild(imageItem);
            });
        }

        function clearAllImages() {
            uploadedImages = [];
            updateImageList();
            updateFileInputAndCount();
            fileInput2.value = '';
        }

        function processImages() {
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            const newOrder = Array.from(imageList.children).map(item => item.querySelector('img').src);
            if (uploadedImages.length === 0) {
                alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
                return;
            }
            // Ensure order is correct before processing
            updateImageOrder();

            arrangeImages(uploadedImages);
            downloadButton.style.display = 'block';

            clearEdits();
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
        }

        function arrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šç‚ºæ¯å¼µåœ–ç‰‡æ·»åŠ é»‘æ¡†ä¸¦è¨ˆç®—å°ºå¯¸
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // å‰µå»ºæ–°çš„Imageå°è±¡ç”¨æ–¼å¾ŒçºŒè™•ç†
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ä½¿ç”¨è™•ç†å¾Œçš„åœ–ç‰‡é€²è¡Œå¾ŒçºŒç¸®æ”¾è¨ˆç®—
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(ARRANGE_MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > ARRANGE_MAX_HEIGHT) {
                    newHeight = ARRANGE_MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // ç‚ºç¸®æ”¾å¾Œçš„åœ–ç‰‡æ·»åŠ é»‘æ¡†
                const borderedCanvas = addBlackBorder(scaledCanvas);

                totalWidth += borderedCanvas.width;
                maxHeight = Math.max(maxHeight, borderedCanvas.height);

                return { canvas: borderedCanvas, width: borderedCanvas.width, height: borderedCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            canvas.width = Math.min(ARRANGE_MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            canvas.height = Math.min(ARRANGE_MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡å¸¶é»‘æ¡†çš„åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (canvas.height - height) / 2;
                ctx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            resizeEditCanvas();

            document.getElementById('editTools').style.display = 'block';
        }

        function resizeEditCanvas() {
            editCanvas.width = canvas.width;
            editCanvas.height = canvas.height;
            editCanvas.style.display = 'block';
        }

        function startDrawing(e) {
            if (!currentTool) return;
            isDrawing = true;
            [startX, startY] = [e.offsetX, e.offsetY];
            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function draw(e) {
            if (!isDrawing || !currentTool) return;
            const [endX, endY] = [e.offsetX, e.offsetY];

            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            if (editHistory.length > 0) {
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
            }

            editCtx.beginPath();
            editCtx.strokeStyle = 'red';
            editCtx.lineWidth = 3;

            if (currentTool === 'rectangle') {
                // ğŸŒŸ æ·»åŠ çŸ©å½¢é™°å½±æ•ˆæœ - ä¿®å¾©ç¼ºè§’å•é¡Œ
                editCtx.save();
                editCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                // ç¹ªè£½é™°å½±çŸ©å½¢
                editCtx.beginPath();
                editCtx.rect(startX + 3, startY + 3, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢ - ç¢ºä¿ç´…è‰²ä¸”ç„¡ç¼ºè§’
                editCtx.save();
                editCtx.strokeStyle = 'red';
                editCtx.lineWidth = 2; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º2px)
                editCtx.lineCap = 'butt'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨butté¿å…åœ“è§’å°è‡´çš„ç¼ºè§’
                editCtx.lineJoin = 'miter'; // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨miterç¢ºä¿å°–è§’

                editCtx.beginPath();
                editCtx.rect(startX, startY, endX - startX, endY - startY);
                editCtx.stroke();

                editCtx.restore();
            } else if (currentTool === 'arrow') {
                drawArrow(startX, startY, endX, endY);
                // ä¸éœ€è¦é¡å¤–çš„strokeï¼Œå› ç‚ºç®­é ­å‡½æ•¸å·²ç¶“è™•ç†äº†æ‰€æœ‰ç¹ªè£½
            } else if (currentTool === 'mosaic') {
                const x = Math.min(startX, endX);
                const y = Math.min(startY, endY);
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);
                drawMosaic(x, y, width, height);
            }

            baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ğŸ’ ç«‹é«”é™°å½±é¢¨æ ¼ + å¡«å……å¼ä¸‰è§’ç®­é ­ + ç´…è‰²ä¸»é¡Œ (ä¿®å¾©æ‰€æœ‰å•é¡Œ)

            // ç¹ªè£½é™°å½±æ•ˆæœ
            editCtx.save();
            editCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            editCtx.fillStyle = 'rgba(0,0,0,0.3)';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šèª¿æ•´ç·šå¯¬é¿å…é™°å½±é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';

            // é™°å½±ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX + 2, fromY + 2);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // é™°å½±ç®­é ­é ­éƒ¨ (å¡«å……ä¸‰è§’å½¢)
            editCtx.beginPath();
            editCtx.moveTo(toX + 2, toY + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            editCtx.save();
            editCtx.strokeStyle = 'red';
            editCtx.fillStyle = 'red';
            editCtx.lineWidth = 3; // ğŸ”§ ä¿®å¾©ï¼šå¢åŠ ç·šå¯¬å®Œå…¨æ¶ˆé™¤é–“éš™ (æ”¹ç‚º3px)
            editCtx.lineCap = 'round';
            editCtx.lineJoin = 'round';

            // ä¸»ç·š - ä¿®å¾©ï¼šåœåœ¨ä¸‰è§’å½¢åŸºéƒ¨è€Œéå°–ç«¯
            editCtx.beginPath();
            editCtx.moveTo(fromX, fromY);
            editCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle)); // ğŸ”§ ä¿®å¾©ï¼šç·šæ¢åœåœ¨ä¸‰è§’å½¢åŸºéƒ¨
            editCtx.stroke();

            // å¡«å……å¼ä¸‰è§’ç®­é ­é ­éƒ¨
            editCtx.beginPath();
            editCtx.moveTo(toX, toY);
            editCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            editCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            editCtx.closePath();
            editCtx.fill();

            editCtx.restore();
        }

        function undo() {
            if (editHistory.length > 1) {
                editHistory.pop();
                editCtx.putImageData(editHistory[editHistory.length - 1], 0, 0);
                baseEditState = editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height);
            } else {
                clearEdits();
            }
        }

        function clearEdits() {
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            editHistory = [editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height)];
            baseEditState = null;
        }

        function applyWatermarkToArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = editCanvas.width - logoWidth - 15;
            const logoY = editCanvas.height - logoHeight - 15;

            editCtx.save();
            editCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            editCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            editCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            editHistory.push(editCtx.getImageData(0, 0, editCanvas.width, editCanvas.height));
        }

        function downloadProcessedImage() {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality} `);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ğŸ”¥ æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(canvas, 0, 0);
            finalCtx.drawImage(editCanvas, 0, 0);

            // ğŸ”¥ æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98; // é è¨­é«˜å“è³ª
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99; // æœ€é«˜å“è³ª
                    break;
                case 'high':
                    jpegQuality = 0.95; // é«˜å“è³ª
                    break;
                case 'balanced':
                    jpegQuality = 0.90; // å¹³è¡¡å“è³ª
                    break;
                case 'fast':
                    jpegQuality = 0.80; // å¿«é€Ÿæ¨¡å¼è¼ƒä½å“è³ª
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }

        window.addEventListener('load', function () {
            setMode('cropImage');
            updateFileInputAndCount();
            document.getElementById('editTools').style.display = 'none';
            updateQualityDescription(); // åˆå§‹åŒ–å“è³ªæè¿°
        });

        const mosaicTool = document.getElementById('mosaicTool');
        let isMosaicMode = false;
        const MOSAIC_SIZE = 10;

        mosaicTool.addEventListener('click', () => {
            currentTool = 'mosaic';
            isMosaicMode = true;
            editCanvas.style.cursor = 'crosshair';
        });

        function drawMosaic(x, y, width, height) {
            const imageData = ctx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = getAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            editCtx.putImageData(imageData, x, y);
        }

        function getAverageColor(imageData, startX, startY, size, width, height) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < size && startX + i < width; i++) {
                for (let j = 0; j < size && startY + j < height; j++) {
                    const index = ((startY + j) * width + (startX + i)) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
        }

        let lastX, lastY;
        editCanvas.addEventListener('mousemove', (e) => {
            lastX = e.offsetX;
            lastY = e.offsetY;
        });

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶é¸æ“‡è™•ç†
        function borderlessHandleFileSelect(event) {
            const files = Array.from(event.target.files).slice(0, MAX_IMAGES - borderlessUploadedImages.length);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function () {
                        img._uid = Date.now() + '-' + Math.random().toString(36).substr(2, 9); // Assign unique ID
                        borderlessUploadedImages.push(img);
                        borderlessUpdateImageList();
                        borderlessUpdateFileInputAndCount();
                    }
                    img.onerror = function () {
                        console.error('åœ–ç‰‡è¼‰å…¥å¤±æ•—:', file.name);
                    };
                }
                reader.readAsDataURL(file);
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ–‡ä»¶è¼¸å…¥æ›´æ–°
        function borderlessUpdateFileInputAndCount() {
            const remainingSlots = MAX_IMAGES - borderlessUploadedImages.length;
            borderlessFileInput2.accept = remainingSlots > 0 ? "image/*" : "";
            borderlessFileCount.textContent = `å¯å†é¸æ“‡ ${remainingSlots} å¼µåœ–ç‰‡`;
            borderlessClearAllButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆ—è¡¨æ›´æ–°
        function borderlessUpdateImageList() {
            borderlessImageList.innerHTML = '';
            borderlessUploadedImages.forEach((img, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.draggable = true;
                div.dataset.index = index;
                div.dataset.uid = img._uid; // Store unique ID in DOM

                const imgElement = document.createElement('img');
                imgElement.src = img.src;
                imgElement.alt = `åœ–ç‰‡ ${index + 1}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-button';
                deleteBtn.textContent = 'åˆªé™¤';
                deleteBtn.addEventListener('click', () => borderlessRemoveImage(index));

                div.appendChild(imgElement);
                div.appendChild(deleteBtn);
                borderlessImageList.appendChild(div);

                // æ‹–æ‹½åŠŸèƒ½
                div.addEventListener('dragstart', borderlessHandleDragStart);
                div.addEventListener('dragover', borderlessHandleDragOver);
                div.addEventListener('drop', borderlessHandleDrop);
                div.addEventListener('dragend', borderlessHandleDragEnd);
            });

            borderlessProcessButton.style.display = borderlessUploadedImages.length > 0 ? 'inline-block' : 'none';
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡åˆªé™¤
        function borderlessRemoveImage(index) {
            borderlessUploadedImages.splice(index, 1);
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ‹–æ‹½è™•ç†å‡½æ•¸
        function borderlessHandleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.index);
        }

        function borderlessHandleDragOver(e) {
            e.preventDefault();
            e.target.closest('.image-item').classList.add('drag-over');
        }

        function borderlessHandleDrop(e) {
            e.preventDefault();
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = parseInt(e.target.closest('.image-item').dataset.index);

            if (draggedIndex !== targetIndex) {
                const draggedItem = borderlessUploadedImages[draggedIndex];
                borderlessUploadedImages.splice(draggedIndex, 1);
                borderlessUploadedImages.splice(targetIndex, 0, draggedItem);
                borderlessUpdateImageList();
            }

            e.target.closest('.image-item').classList.remove('drag-over');
        }

        function borderlessHandleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('#borderlessImageList .image-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡è™•ç†
        function borderlessProcessImages() {
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            if (borderlessUploadedImages.length === 0) {
                alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡');
                return;
            }
            // Re-sort based on DOM order to ensure consistency
            const newOrderIds = Array.from(borderlessImageList.children).map(item => item.dataset.uid);
            borderlessUploadedImages.sort((a, b) => newOrderIds.indexOf(a._uid) - newOrderIds.indexOf(b._uid));

            borderlessArrangeImages(borderlessUploadedImages);
            borderlessDownloadButton.style.display = 'block';

            borderlessClearEdits();
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
        }

        // ğŸ”¥ ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„åœ–ç‰‡æ’åˆ—ï¼ˆèˆ‡åŸç‰ˆå®Œå…¨ä¸€è‡´ï¼Œåªæ˜¯ä¸æ·»åŠ é»‘æ¡†ï¼‰
        function borderlessArrangeImages(images) {
            // ğŸ”¥ ç²å–ç•¶å‰å“è³ªè¨­å®š
            const quality = scalingQuality.value;
            console.log(`ğŸ“ ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            let totalWidth = 0;
            let maxHeight = 0;

            // ç¬¬ä¸€æ­¥ï¼šè™•ç†åœ–ç‰‡ä½†ä¸æ·»åŠ é»‘æ¡†ï¼ˆèˆ‡åŸç‰ˆé‚è¼¯ä¸€è‡´ï¼‰
            const processedImages = images.map(img => {
                // æ–°å¢ï¼šæª¢æŸ¥ä¸¦èª¿æ•´åœ–ç‰‡é«˜åº¦
                let processedImg = img;

                // å¦‚æœåŸå§‹åœ–ç‰‡é«˜åº¦è¶…é900pxï¼Œå…ˆèª¿æ•´ç‚º690px
                if (img.height > 900) {
                    // ğŸ”¥ ä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = img.width;
                    sourceCanvas.height = img.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(img, 0, 0);

                    // è¨ˆç®—æŒ‰690pxé«˜åº¦ç¸®æ”¾å¾Œçš„æ–°å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                    const heightRatio = 690 / img.height;
                    const newImgWidth = img.width * heightRatio;
                    const newImgHeight = 690;

                    const heightCanvas = safeAdvancedImageScale(sourceCanvas, newImgWidth, newImgHeight, quality);

                    // ğŸ”§ ä¿®å¾©ï¼šèˆ‡é‚Šæ¡†ç‰ˆæœ¬ä¸€è‡´ï¼Œå‰µå»ºå°è±¡è€Œä¸æ˜¯æ–°Image
                    processedImg = {
                        width: newImgWidth,
                        height: newImgHeight,
                        canvas: heightCanvas
                    };
                }

                // ğŸ”§ ä¿®å¾©ï¼šä½¿ç”¨èˆ‡é‚Šæ¡†ç‰ˆæœ¬ç›¸åŒçš„ç¸®æ”¾é‚è¼¯
                const aspectRatio = processedImg.width / processedImg.height;
                let newWidth = Math.min(MAX_WIDTH / images.length - SPACING, processedImg.width);
                let newHeight = newWidth / aspectRatio;

                if (newHeight > MAX_HEIGHT) {
                    newHeight = MAX_HEIGHT;
                    newWidth = newHeight * aspectRatio;
                }

                // ğŸ”¥ å‰µå»ºç¸®æ”¾å¾Œçš„canvasï¼Œä½¿ç”¨å®‰å…¨çš„é«˜ç´šç¸®æ”¾ç®—æ³•
                let scaledCanvas;

                if (processedImg.canvas) {
                    // å¦‚æœå·²ç¶“èª¿æ•´éé«˜åº¦ï¼Œä½¿ç”¨èª¿æ•´å¾Œçš„canvas
                    scaledCanvas = safeAdvancedImageScale(processedImg.canvas, newWidth, newHeight, quality);
                } else {
                    // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                    const sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = processedImg.width;
                    sourceCanvas.height = processedImg.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    setupHighQualityCanvas(sourceCtx);
                    sourceCtx.drawImage(processedImg, 0, 0);

                    scaledCanvas = safeAdvancedImageScale(sourceCanvas, newWidth, newHeight, quality);
                }

                // âœ¨ é—œéµå·®ç•°ï¼šç„¡é‚Šæ¡†ç‰ˆæœ¬ä¸æ·»åŠ é»‘æ¡†
                // åŸç‰ˆæœƒèª¿ç”¨: const borderedCanvas = addBlackBorder(scaledCanvas);
                // ç„¡é‚Šæ¡†ç‰ˆæœ¬ç›´æ¥ä½¿ç”¨ scaledCanvas

                totalWidth += scaledCanvas.width;
                maxHeight = Math.max(maxHeight, scaledCanvas.height);

                return { canvas: scaledCanvas, width: scaledCanvas.width, height: scaledCanvas.height };
            });

            // è¨­ç½®æœ€çµ‚ç•«å¸ƒå°ºå¯¸
            borderlessCanvas.width = Math.min(MAX_WIDTH, totalWidth + SPACING * (images.length - 1));
            borderlessCanvas.height = Math.min(MAX_HEIGHT, maxHeight);

            // å¡«å……ç™½è‰²èƒŒæ™¯
            let x = 0;
            borderlessCtx.fillStyle = 'white';
            borderlessCtx.fillRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);

            // ç¬¬äºŒæ­¥ï¼šå°‡åœ–ç‰‡ä¸¦æ’
            processedImages.forEach(({ canvas: imgCanvas, width, height }) => {
                const y = (borderlessCanvas.height - height) / 2;
                borderlessCtx.drawImage(imgCanvas, x, y);
                x += width + SPACING;
            });

            // è¨­ç½®ç·¨è¼¯canvas
            borderlessEditCanvas.width = borderlessCanvas.width;
            borderlessEditCanvas.height = borderlessCanvas.height;
            borderlessEditCanvas.style.display = 'block';

            document.getElementById('borderlessEditTools').style.display = 'block';
            borderlessInitializeEditTools();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç·¨è¼¯å·¥å…·åˆå§‹åŒ–
        function borderlessInitializeEditTools() {
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);

            borderlessRectangleTool.addEventListener('click', () => borderlessSetTool('rectangle'));
            borderlessArrowTool.addEventListener('click', () => borderlessSetTool('arrow'));
            borderlessWatermarkTool.addEventListener('click', () => {
                // æª¢æŸ¥æ˜¯å¦æœ‰å·²å„²å­˜çš„æµ®æ°´å°
                const savedWatermark = localStorage.getItem('cropWatermarkData');
                if (savedWatermark) {
                    const img = new Image();
                    img.onload = () => {
                        applyWatermarkToBorderlessArrange(img);
                    };
                    img.src = savedWatermark;
                } else {
                    // å¦‚æœæ²’æœ‰ï¼Œè§¸ç™¼æ–‡ä»¶é¸æ“‡
                    // é€™è£¡æˆ‘å€‘éœ€è¦ä¸€å€‹è®Šé‡ä¾†æ¨™è¨˜ç•¶å‰æ˜¯å“ªå€‹æ¨¡å¼è§¸ç™¼çš„æµ®æ°´å°é¸æ“‡
                    // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘å‡è¨­ä½¿ç”¨è€…å·²ç¶“åœ¨è£åˆ‡æ¨¡å¼è¨­å®šå¥½æµ®æ°´å°ï¼Œæˆ–è€…æˆ‘å€‘å¼•å°ä»–å€‘å»è¨­å®š
                    // æˆ–è€…ï¼Œæˆ‘å€‘å¯ä»¥è‡¨æ™‚å€Ÿç”¨ previewWatermarkInput
                    previewWatermarkInput.click();
                }
            });
            borderlessMosaicTool.addEventListener('click', () => borderlessSetTool('mosaic'));
            borderlessUndoButton.addEventListener('click', borderlessUndo);
            borderlessClearButton.addEventListener('click', borderlessClearAllEdits);

            borderlessEditCanvas.addEventListener('mousedown', borderlessStartDrawing);
            borderlessEditCanvas.addEventListener('mousemove', borderlessDraw);
            borderlessEditCanvas.addEventListener('mouseup', borderlessStopDrawing);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å·¥å…·è¨­ç½®
        function borderlessSetTool(tool) {
            borderlessCurrentTool = tool;
            document.querySelectorAll('#borderlessEditTools button').forEach(btn => btn.classList.remove('active'));
            if (tool === 'rectangle') {
                borderlessRectangleTool.classList.add('active');
            } else if (tool === 'arrow') {
                borderlessArrowTool.classList.add('active');
            } else if (tool === 'mosaic') {
                borderlessMosaicTool.classList.add('active');
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç¹ªåœ–äº‹ä»¶è™•ç†
        function borderlessStartDrawing(e) {
            if (!borderlessCurrentTool) return;
            borderlessIsDrawing = true;
            const rect = borderlessEditCanvas.getBoundingClientRect();
            borderlessStartX = e.clientX - rect.left;
            borderlessStartY = e.clientY - rect.top;
        }

        function borderlessDraw(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            // é è¦½åŠŸèƒ½å¯ä»¥åœ¨é€™è£¡æ·»åŠ 
        }

        function borderlessStopDrawing(e) {
            if (!borderlessIsDrawing || !borderlessCurrentTool) return;
            borderlessIsDrawing = false;

            const rect = borderlessEditCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„
            if (borderlessEditHistory.length > 10) {
                borderlessEditHistory.shift();
            }

            borderlessEditCtx.beginPath();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.lineWidth = 3;

            if (borderlessCurrentTool === 'rectangle') {
                // çŸ©å½¢å·¥å…· - æ·»åŠ é™°å½±æ•ˆæœ
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                borderlessEditCtx.lineWidth = 3;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX + 3, borderlessStartY + 3, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();

                // ç¹ªè£½ä¸»çŸ©å½¢
                borderlessEditCtx.save();
                borderlessEditCtx.strokeStyle = 'red';
                borderlessEditCtx.lineWidth = 2;
                borderlessEditCtx.lineCap = 'butt';
                borderlessEditCtx.lineJoin = 'miter';

                borderlessEditCtx.beginPath();
                borderlessEditCtx.rect(borderlessStartX, borderlessStartY, endX - borderlessStartX, endY - borderlessStartY);
                borderlessEditCtx.stroke();

                borderlessEditCtx.restore();
            } else if (borderlessCurrentTool === 'arrow') {
                borderlessDrawArrow(borderlessStartX, borderlessStartY, endX, endY);
            } else if (borderlessCurrentTool === 'mosaic') {
                const x = Math.min(borderlessStartX, endX);
                const y = Math.min(borderlessStartY, endY);
                const width = Math.abs(endX - borderlessStartX);
                const height = Math.abs(endY - borderlessStartY);
                borderlessDrawMosaic(x, y, width, height);
            }

            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ç®­é ­ç¹ªè£½å‡½æ•¸
        function borderlessDrawArrow(fromX, fromY, toX, toY) {
            const headLength = 25;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // ç¹ªè£½é™°å½±æ•ˆæœ
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.fillStyle = 'rgba(0,0,0,0.3)';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX + 2, fromY + 2);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle) + 2, toY - headLength * 0.7 * Math.sin(angle) + 2);
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX + 2, toY + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle - Math.PI / 6) + 2);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6) + 2,
                toY - headLength * Math.sin(angle + Math.PI / 6) + 2);
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();

            // ç¹ªè£½ä¸»ç®­é ­
            borderlessEditCtx.save();
            borderlessEditCtx.strokeStyle = 'red';
            borderlessEditCtx.fillStyle = 'red';
            borderlessEditCtx.lineWidth = 3;
            borderlessEditCtx.lineCap = 'round';
            borderlessEditCtx.lineJoin = 'round';

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(fromX, fromY);
            borderlessEditCtx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle));
            borderlessEditCtx.stroke();

            borderlessEditCtx.beginPath();
            borderlessEditCtx.moveTo(toX, toY);
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6));
            borderlessEditCtx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6));
            borderlessEditCtx.closePath();
            borderlessEditCtx.fill();

            borderlessEditCtx.restore();
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„é¦¬è³½å…‹ç¹ªè£½å‡½æ•¸
        function borderlessDrawMosaic(x, y, width, height) {
            const MOSAIC_SIZE = 10;
            const imageData = borderlessCtx.getImageData(x, y, width, height);
            for (let i = 0; i < width; i += MOSAIC_SIZE) {
                for (let j = 0; j < height; j += MOSAIC_SIZE) {
                    const pixelData = borderlessGetAverageColor(imageData, i, j, MOSAIC_SIZE, width, height);
                    for (let mx = 0; mx < MOSAIC_SIZE && i + mx < width; mx++) {
                        for (let my = 0; my < MOSAIC_SIZE && j + my < height; my++) {
                            const index = ((j + my) * width + (i + mx)) * 4;
                            imageData.data[index] = pixelData[0];
                            imageData.data[index + 1] = pixelData[1];
                            imageData.data[index + 2] = pixelData[2];
                        }
                    }
                }
            }
            borderlessEditCtx.putImageData(imageData, x, y);
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„å¹³å‡é¡è‰²è¨ˆç®—å‡½æ•¸
        function borderlessGetAverageColor(imageData, startX, startY, size, totalWidth, totalHeight) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let x = startX; x < startX + size && x < totalWidth; x++) {
                for (let y = startY; y < startY + size && y < totalHeight; y++) {
                    const index = (y * totalWidth + x) * 4;
                    r += imageData.data[index];
                    g += imageData.data[index + 1];
                    b += imageData.data[index + 2];
                    count++;
                }
            }
            return [Math.floor(r / count), Math.floor(g / count), Math.floor(b / count)];
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ’¤éŠ·åŠŸèƒ½
        function borderlessUndo() {
            if (borderlessEditHistory.length > 1) {
                borderlessEditHistory.pop();
                borderlessEditCtx.putImageData(borderlessEditHistory[borderlessEditHistory.length - 1], 0, 0);
            }
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰ç·¨è¼¯
        function borderlessClearAllEdits() {
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessEditHistory = [borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height)];
            borderlessBaseEditState = null;
        }

        function applyWatermarkToBorderlessArrange(img) {
            // æµ®æ°´å°ç¸®æ”¾ (ç¸®å°30%)
            const logoWidth = img.width * 0.7;
            const logoHeight = img.height * 0.7;

            // ä½ç½®ï¼šå³ä¸‹è§’ï¼Œä¿ç•™ 15px é‚Šè·
            const logoX = borderlessEditCanvas.width - logoWidth - 15;
            const logoY = borderlessEditCanvas.height - logoHeight - 15;

            borderlessEditCtx.save();
            borderlessEditCtx.globalAlpha = 0.5; // 50% é€æ˜åº¦
            borderlessEditCtx.drawImage(img, logoX, logoY, logoWidth, logoHeight);
            borderlessEditCtx.restore();

            // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
            borderlessEditHistory.push(borderlessEditCtx.getImageData(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height));
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„æ¸…é™¤æ‰€æœ‰åœ–ç‰‡
        function borderlessClearAllImages() {
            borderlessUploadedImages = [];
            borderlessUpdateFileInputAndCount();
            borderlessUpdateImageList();
            borderlessDownloadButton.style.display = 'none';
            document.getElementById('borderlessEditTools').style.display = 'none';
            borderlessEditCtx.clearRect(0, 0, borderlessEditCanvas.width, borderlessEditCanvas.height);
            borderlessCtx.clearRect(0, 0, borderlessCanvas.width, borderlessCanvas.height);
            borderlessFileInput2.value = ''; // æ¸…é™¤æ–‡ä»¶è¼¸å…¥
        }

        // ç„¡é‚Šæ¡†ç‰ˆæœ¬çš„ä¸‹è¼‰åŠŸèƒ½
        function borderlessDownloadProcessedImage() {
            const quality = scalingQuality.value;
            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: å“è³ªè¨­å®š ${quality}`);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = borderlessCanvas.width;
            finalCanvas.height = borderlessCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // æ ¹æ“šå“è³ªè¨­å®šé¸æ“‡Canvasè¨­ç½®
            switch (quality) {
                case 'ultra':
                    setupUltraQualityCanvas(finalCtx);
                    break;
                case 'high':
                    setupHighQualityCanvas(finalCtx);
                    break;
                case 'balanced':
                    setupBalancedQualityCanvas(finalCtx);
                    break;
                case 'fast':
                    setupFastQualityCanvas(finalCtx);
                    break;
                default:
                    setupBalancedQualityCanvas(finalCtx);
            }

            finalCtx.drawImage(borderlessCanvas, 0, 0);
            finalCtx.drawImage(borderlessEditCanvas, 0, 0);

            // æ ¹æ“šå“è³ªé¸é …æ±ºå®šJPEGå“è³ª
            let jpegQuality = 0.98;
            switch (quality) {
                case 'ultra':
                    jpegQuality = 0.99;
                    break;
                case 'high':
                    jpegQuality = 0.95;
                    break;
                case 'balanced':
                    jpegQuality = 0.90;
                    break;
                case 'fast':
                    jpegQuality = 0.80;
                    break;
            }

            console.log(`ğŸ”½ ä¸‹è¼‰ç„¡é‚Šæ¡†æˆªåœ–ä¸¦æ’: ä½¿ç”¨JPEGå“è³ª ${jpegQuality}`);

            const link = document.createElement('a');
            link.download = 'borderless_processed_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', jpegQuality);
            link.click();
        }
        // ============ ç¹ç°¡è½‰æ›åŠŸèƒ½ ============

        const convInput = document.getElementById('convInput');
        const convOutputTrad = document.getElementById('convOutputTrad');
        const convOutputSimp = document.getElementById('convOutputSimp');
        const dictBtn = document.getElementById('dictBtn');
        const dictDialog = document.getElementById('dictDialog');
        const closeDictBtn = document.getElementById('closeDictBtn');
        const addDictBtn = document.getElementById('addDictBtn');
        const dictList = document.getElementById('dictList');
        const newSimple = document.getElementById('newSimple');
        const newTrad = document.getElementById('newTrad');
        const dictCountBadge = document.getElementById('dictCountBadge');

        // è½‰æ›å™¨ç‹€æ…‹
        let converterS2T = null;
        let converterT2S = null;
        let customDictionary = JSON.parse(localStorage.getItem('custom_dictionary') || '[]');

        // åˆå§‹åŒ– OpenCC
        async function initOpenCC() {
            if (window.OpenCC && !converterS2T) {
                converterS2T = window.OpenCC.Converter({ from: 'cn', to: 'tw' });
                converterT2S = window.OpenCC.Converter({ from: 'tw', to: 'cn' });
                console.log('OpenCC initialized');
            }
        }

        // å­—å…¸åŠŸèƒ½
        function updateDictUI() {
            dictList.innerHTML = '';

            if (customDictionary.length === 0) {
                dictList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">å°šç„¡è‡ªå®šç¾©è¦å‰‡</div>';
                dictCountBadge.style.display = 'none';
                return;
            }

            dictCountBadge.textContent = customDictionary.length;
            dictCountBadge.style.display = 'inline-block';

            customDictionary.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'dict-item';
                item.innerHTML = `
                    <div style="flex:1; display:flex; gap:10px; align-items:center;">
                        <span style="flex:1; text-align:right;">${entry.simplified}</span>
                        <span style="color:#999;">â‡Œ</span>
                        <span style="flex:1; font-weight:bold;">${entry.traditional}</span>
                    </div>
                    <button class="btn-danger" style="margin-left:10px;">ğŸ—‘ï¸</button>
                `;
                item.querySelector('.btn-danger').addEventListener('click', () => {
                    customDictionary = customDictionary.filter(e => e.id !== entry.id);
                    saveDictionary();
                    updateDictUI();
                    performConversion(); // é‡æ–°è½‰æ›
                });
                dictList.appendChild(item);
            });
        }

        function saveDictionary() {
            localStorage.setItem('custom_dictionary', JSON.stringify(customDictionary));
        }

        // è½‰æ›é‚è¼¯
        function preProcess(text, type) {
            let result = text;
            customDictionary.forEach(entry => {
                if (type === 'trad') {
                    result = result.split(entry.simplified).join(entry.traditional);
                } else {
                    result = result.split(entry.traditional).join(entry.simplified);
                }
            });
            return result;
        }

        function applyDictionary(text, type) {
            let result = text;
            customDictionary.forEach(entry => {
                if (type === 'trad') {
                    result = result.split(entry.simplified).join(entry.traditional);
                } else {
                    result = result.split(entry.traditional).join(entry.simplified);
                }
            });
            return result;
        }

        async function performConversion() {
            const text = convInput.value;
            if (!text) {
                convOutputTrad.textContent = '';
                convOutputSimp.textContent = '';
                return;
            }

            if (!converterS2T || !converterT2S) await initOpenCC();

            // ç¹é«”è½‰æ›æµç¨‹
            const preTrad = preProcess(text, 'trad');
            let tradResult = converterS2T ? converterS2T(preTrad) : preTrad;
            tradResult = applyDictionary(tradResult, 'trad');
            convOutputTrad.textContent = tradResult;

            // ç°¡é«”è½‰æ›æµç¨‹
            const preSimp = preProcess(text, 'simp');
            let simpResult = converterT2S ? converterT2S(preSimp) : preSimp;
            simpResult = applyDictionary(simpResult, 'simp');
            convOutputSimp.textContent = simpResult;
        }

        // äº‹ä»¶ç›£è½
        document.addEventListener('DOMContentLoaded', () => {
            initOpenCC();
            updateDictUI();
        });

        convInput.addEventListener('input', performConversion);

        // Dictionary modal
        dictBtn.addEventListener('click', () => {
            dictDialog.style.display = 'flex';
            updateDictUI();
        });

        closeDictBtn.addEventListener('click', () => {
            dictDialog.style.display = 'none';
        });

        dictDialog.addEventListener('click', (e) => {
            if (e.target === dictDialog) dictDialog.style.display = 'none';
        });

        addDictBtn.addEventListener('click', () => {
            const s = newSimple.value.trim();
            const t = newTrad.value.trim();
            if (s && t) {
                customDictionary.push({ id: Date.now().toString(), simplified: s, traditional: t });
                saveDictionary();
                newSimple.value = '';
                newTrad.value = '';
                updateDictUI();
                performConversion();
            } else {
                alert('è«‹è¼¸å…¥ç°¡é«”å’Œç¹é«”è©å½™');
            }
        });

        // Tools
        document.getElementById('convClearBtn').addEventListener('click', () => {
            convInput.value = '';
            performConversion();
        });

        document.getElementById('convCopyInputBtn').addEventListener('click', () => navigator.clipboard.writeText(convInput.value));
        document.getElementById('convCopyTradBtn').addEventListener('click', () => navigator.clipboard.writeText(convOutputTrad.textContent));
        document.getElementById('convCopySimpBtn').addEventListener('click', () => navigator.clipboard.writeText(convOutputSimp.textContent));

        // Download
        const downloadText = (text, filename) => {
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };

        document.getElementById('convDownloadTradBtn').addEventListener('click', () => downloadText(convOutputTrad.textContent, 'converted_trad.txt'));
        document.getElementById('convDownloadSimpBtn').addEventListener('click', () => downloadText(convOutputSimp.textContent, 'converted_simp.txt'));

        // File Upload
        const convFileInput = document.getElementById('convFileInput');
        document.getElementById('convUploadBtn').addEventListener('click', () => convFileInput.click());
        convFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    convInput.value = e.target.result;
                    performConversion();
                };
                reader.readAsText(file);
                e.target.value = '';
            }
        });


        /* =========================================
           Magic Remover (Watermark Remover) Logic
           ========================================= */

        const mrState = {
            image: null, // DataURL
            isProcessing: false,
            resultImage: null,
            tool: 'wand',
            tolerance: 30,
            mode: 'reconstruct', // 'reconstruct' or 'inpainting'
            watermarkColor: 'white',
            intensity: 50,
            threshold: 50,
            brushSize: 30,
            isDrawing: false,
            maskPaths: [],
            currentPath: null,
            originalImageData: null,
            canvasDimensions: { width: 0, height: 0 }
        };

        // UI Elements
        const mrArea = document.getElementById('magicRemoverArea');
        const mrFileInput = document.getElementById('mrFileInput');
        const mrCanvasWrapper = document.getElementById('mrCanvasWrapper');
        const mrUploadPrompt = document.getElementById('mrUploadPrompt');
        const mrImageCanvas = document.getElementById('mrImageCanvas');
        const mrMaskCanvas = document.getElementById('mrMaskCanvas');
        const mrResultPreview = document.getElementById('mrResultPreview');
        const mrResultImage = document.getElementById('mrResultImage');
        const mrLoadingOverlay = document.getElementById('mrLoadingOverlay');
        const mrProgress = document.getElementById('mrProgress');

        // Controls
        const mrModeReconstructBtn = document.getElementById('mrModeReconstruct');
        const mrModeInpaintingBtn = document.getElementById('mrModeInpainting');
        const mrControlsReconstruct = document.getElementById('mrControlsReconstruct');
        const mrControlsInpainting = document.getElementById('mrControlsInpainting');

        // Reconstruct Settings
        const mrColorWhiteBtn = document.getElementById('mrColorWhite');
        const mrColorBlackBtn = document.getElementById('mrColorBlack');
        const mrIntensityInput = document.getElementById('mrIntensity');
        const mrIntensityVal = document.getElementById('mrIntensityVal');
        const mrThresholdInput = document.getElementById('mrThreshold');
        const mrThresholdVal = document.getElementById('mrThresholdVal');

        // Tools
        const mrToolWandBtn = document.getElementById('mrToolWand');
        const mrToolBrushBtn = document.getElementById('mrToolBrush');
        const mrSettingsWand = document.getElementById('mrSettingsWand');
        const mrSettingsBrush = document.getElementById('mrSettingsBrush');
        const mrToleranceInput = document.getElementById('mrTolerance');
        const mrToleranceVal = document.getElementById('mrToleranceVal');
        const mrBrushSizeInput = document.getElementById('mrBrushSize');
        const mrBrushSizeVal = document.getElementById('mrBrushSizeVal');

        // Actions
        const mrClearBtn = document.getElementById('mrClearBtn');
        const mrUndoBtn = document.getElementById('mrUndoBtn');
        const mrStartInpaintingBtn = document.getElementById('mrStartInpaintingBtn');
        const mrDownloadBtn = document.getElementById('mrDownloadBtn');
        const mrCloseBtn = document.getElementById('mrCloseBtn');


        // Event Listeners
        function initMagicRemoverEvents() {
            mrFileInput.addEventListener('change', handleMrImageUpload);

            mrModeReconstructBtn.addEventListener('click', () => setMrMode('reconstruct'));
            mrModeInpaintingBtn.addEventListener('click', () => setMrMode('inpainting'));

            mrColorWhiteBtn.addEventListener('click', () => setMrWatermarkColor('white'));
            mrColorBlackBtn.addEventListener('click', () => setMrWatermarkColor('black'));

            mrIntensityInput.addEventListener('input', (e) => {
                mrState.intensity = parseInt(e.target.value);
                mrIntensityVal.textContent = mrState.intensity + '%';
                mrUpdateEffect();
            });

            mrThresholdInput.addEventListener('input', (e) => {
                mrState.threshold = parseInt(e.target.value);
                mrThresholdVal.textContent = mrState.threshold;
                mrUpdateEffect();
            });

            mrToolWandBtn.addEventListener('click', () => setMrTool('wand'));
            mrToolBrushBtn.addEventListener('click', () => setMrTool('brush'));

            mrToleranceInput.addEventListener('input', (e) => {
                mrState.tolerance = parseInt(e.target.value);
                mrToleranceVal.textContent = mrState.tolerance;
            });

            mrBrushSizeInput.addEventListener('input', (e) => {
                mrState.brushSize = parseInt(e.target.value);
                mrBrushSizeVal.textContent = mrState.brushSize + 'px';
            });

            mrClearBtn.addEventListener('click', mrClearMask);
            mrUndoBtn.addEventListener('click', mrUndoMask);
            mrStartInpaintingBtn.addEventListener('click', mrApplyInpainting);
            mrDownloadBtn.addEventListener('click', mrDownloadResult);
            mrCloseBtn.addEventListener('click', mrRemoveImage);

            // Canvas Drawing Events
            mrMaskCanvas.addEventListener('mousedown', mrStartDrawing);
            mrMaskCanvas.addEventListener('mousemove', mrDraw);
            mrMaskCanvas.addEventListener('mouseup', mrStopDrawing);
            mrMaskCanvas.addEventListener('mouseleave', mrStopDrawing);

            // Touch support
            mrMaskCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); mrStartDrawing(e); });
            mrMaskCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); mrDraw(e); });
            mrMaskCanvas.addEventListener('touchend', (e) => { e.preventDefault(); mrStopDrawing(e); });

            // Ensure icons are rendered
            if (window.lucide) lucide.createIcons();
        }

        function setMrMode(mode) {
            mrState.mode = mode;
            if (mode === 'reconstruct') {
                mrModeReconstructBtn.classList.add('mr-btn-active');
                mrModeInpaintingBtn.classList.remove('mr-btn-active');
                mrControlsReconstruct.style.display = 'block';
                mrControlsInpainting.style.display = 'none';
            } else {
                mrModeReconstructBtn.classList.remove('mr-btn-active');
                mrModeInpaintingBtn.classList.add('mr-btn-active');
                mrControlsReconstruct.style.display = 'none';
                mrControlsInpainting.style.display = 'block';
            }
            mrRedrawMask();
        }

        function setMrWatermarkColor(color) {
            mrState.watermarkColor = color;
            if (color === 'white') {
                mrColorWhiteBtn.classList.add('active');
                mrColorBlackBtn.classList.remove('active');
            } else {
                mrColorWhiteBtn.classList.remove('active');
                mrColorBlackBtn.classList.add('active');
            }
            mrUpdateEffect();
        }

        function setMrTool(tool) {
            mrState.tool = tool;
            if (tool === 'wand') {
                mrToolWandBtn.classList.add('active');
                mrToolBrushBtn.classList.remove('active');
                mrSettingsWand.style.display = 'block';
                mrSettingsBrush.style.display = 'none';
                mrMaskCanvas.style.cursor = 'pointer';
            } else {
                mrToolWandBtn.classList.remove('active');
                mrToolBrushBtn.classList.add('active');
                mrSettingsWand.style.display = 'none';
                mrSettingsBrush.style.display = 'block';
                mrMaskCanvas.style.cursor = 'crosshair';
            }
        }

        function handleMrImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const MAX_SIDE = 2000;
                    let w = img.width;
                    let h = img.height;

                    if (w > MAX_SIDE || h > MAX_SIDE) {
                        const ratio = Math.min(MAX_SIDE / w, MAX_SIDE / h);
                        w = Math.round(w * ratio);
                        h = Math.round(h * ratio);
                    }

                    mrState.canvasDimensions = { width: w, height: h };
                    mrState.image = event.target.result;
                    mrState.maskPaths = [];
                    mrState.currentPath = null;
                    mrState.resultImage = null;

                    // Setup Canvas
                    mrImageCanvas.width = w;
                    mrImageCanvas.height = h;
                    mrMaskCanvas.width = w;
                    mrMaskCanvas.height = h;

                    const ctx = mrImageCanvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(img, 0, 0, w, h);
                    mrState.originalImageData = ctx.getImageData(0, 0, w, h);

                    // Show Canvas
                    mrUploadPrompt.style.display = 'none';
                    mrCanvasWrapper.style.display = 'flex'; // or block/flex
                    mrResultPreview.style.display = 'none';

                    mrRedrawMask();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = ''; // Reset input
        }

        function mrRemoveImage() {
            if (mrState.isProcessing) return;
            mrState.image = null;
            mrState.maskPaths = [];
            mrState.originalImageData = null;
            mrUploadPrompt.style.display = 'block';
            mrCanvasWrapper.style.display = 'none';
            mrResultPreview.style.display = 'none';
        }

        function getMrCoordinates(e) {
            const rect = mrMaskCanvas.getBoundingClientRect();
            const scaleX = mrMaskCanvas.width / rect.width;
            const scaleY = mrMaskCanvas.height / rect.height;

            let clientX, clientY;
            if (e.touches && e.touches[0]) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                offsetX: (clientX - rect.left) * scaleX,
                offsetY: (clientY - rect.top) * scaleY
            };
        }

        function mrStartDrawing(e) {
            if (!mrState.image || mrState.isProcessing) return;
            const { offsetX, offsetY } = getMrCoordinates(e);

            if (mrState.tool === 'wand') {
                const newWandAction = {
                    type: 'wand',
                    x: offsetX,
                    y: offsetY,
                    tolerance: mrState.tolerance
                };
                mrState.maskPaths.push(newWandAction);
                mrRedrawMask();
            } else {
                mrState.isDrawing = true;
                // Calculate scale factor relative to display size vs authentic size if needed, 
                // but here offset is already scaled.
                // We just use raw brush size or scaled? 
                // React code used getScaleFactor() helper.
                // Let's implement simple constant scale or relative to canvas width?
                // React code: const scaleFactor = maskCanvas.width / rect.width;
                const rect = mrMaskCanvas.getBoundingClientRect();
                const scaleFactor = mrMaskCanvas.width / rect.width;

                mrState.currentPath = {
                    type: 'brush',
                    points: [{ x: offsetX, y: offsetY }],
                    size: mrState.brushSize * scaleFactor
                };
                mrRedrawMask();
            }
        }

        function mrDraw(e) {
            if (!mrState.isDrawing || !mrState.image || mrState.isProcessing || mrState.tool !== 'brush') return;
            const { offsetX, offsetY } = getMrCoordinates(e);

            if (mrState.currentPath) {
                mrState.currentPath.points.push({ x: offsetX, y: offsetY });
                mrRedrawMask();
            }
        }

        function mrStopDrawing() {
            if (!mrState.isDrawing) return;
            mrState.isDrawing = false;
            if (mrState.currentPath) {
                mrState.maskPaths.push(mrState.currentPath);
                mrState.currentPath = null;
                mrRedrawMask();
            }
        }

        function mrUndoMask() {
            if (mrState.maskPaths.length > 0) {
                mrState.maskPaths.pop();
                mrRedrawMask();
            }
        }

        function mrClearMask() {
            mrState.maskPaths = [];
            mrState.currentPath = null;
            mrRedrawMask();
            // Reset result to original
            if (mrState.originalImageData) {
                const ctx = mrImageCanvas.getContext('2d');
                ctx.putImageData(mrState.originalImageData, 0, 0);
                mrUpdateResultImage();
            }
        }

        function mrRedrawMask() {
            if (!mrMaskCanvas || !mrState.originalImageData) return;
            const ctx = mrMaskCanvas.getContext('2d');
            const width = mrMaskCanvas.width;
            const height = mrMaskCanvas.height;

            ctx.clearRect(0, 0, width, height);

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 4;
            const strokeStyle = mrState.mode === 'reconstruct' ? 'rgba(100, 255, 100, 1)' : 'rgba(255, 50, 50, 1)';
            ctx.shadowColor = strokeStyle;
            ctx.strokeStyle = strokeStyle;

            const pathsToDraw = [...mrState.maskPaths];
            if (mrState.currentPath) pathsToDraw.push(mrState.currentPath);

            pathsToDraw.forEach(path => {
                if (path.type === 'brush') {
                    if (path.points.length < 1) return;
                    ctx.lineWidth = path.size;
                    ctx.beginPath();
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    for (let i = 1; i < path.points.length; i++) {
                        ctx.lineTo(path.points[i].x, path.points[i].y);
                    }
                    ctx.stroke();
                }
            });
            ctx.shadowBlur = 0;

            const maskImageData = ctx.getImageData(0, 0, width, height);
            const maskData = maskImageData.data;

            // Make non-transparent pixels fully opaque for mask logic
            for (let i = 0; i < width * height; i++) {
                if (maskData[i * 4 + 3] > 0) {
                    maskData[i * 4 + 3] = 255;
                }
            }

            const maskR = mrState.mode === 'reconstruct' ? 100 : 255;
            const maskG = mrState.mode === 'reconstruct' ? 255 : 50;
            const maskB = mrState.mode === 'reconstruct' ? 100 : 50;
            const maskA = 255;

            // Handle Magic Wand
            const wandActions = mrState.maskPaths.filter(p => p.type === 'wand');
            if (wandActions.length > 0) {
                const originalData = mrState.originalImageData.data;
                wandActions.forEach(action => {
                    mrFloodFill(
                        originalData,
                        maskData,
                        Math.round(action.x),
                        Math.round(action.y),
                        width,
                        height,
                        action.tolerance,
                        maskR, maskG, maskB, maskA
                    );
                });
            }

            // Grow Mask - Fix 1: radius 3
            if (mrState.maskPaths.length > 0 || mrState.currentPath) {
                mrGrowMask(maskData, width, height, 3, maskR, maskG, maskB, maskA);
            }

            ctx.putImageData(maskImageData, 0, 0);

            // Auto-update effect for reconstruct mode
            if (mrState.mode === 'reconstruct' && !mrState.isDrawing) {
                mrApplyColorReconstruction();
            }
        }

        function mrUpdateEffect() {
            if (mrState.mode === 'reconstruct') {
                mrApplyColorReconstruction();
            }
        }

        function mrUpdateResultImage() {
            mrState.resultImage = mrImageCanvas.toDataURL('image/jpeg', 0.9);
            mrResultImage.src = mrState.resultImage;
            mrResultPreview.style.display = 'block';
        }

        let mrUpdateTimeout;
        function mrScheduleUpdate() {
            if (mrUpdateTimeout) clearTimeout(mrUpdateTimeout);
            mrUpdateTimeout = setTimeout(mrUpdateResultImage, 500);
        }

        function mrFloodFill(srcData, targetData, startX, startY, width, height, tolerance, r, g, b, a) {
            if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;

            const stack = [[startX, startY]];
            const visited = new Uint8Array(width * height);
            const startIdx = (startY * width + startX) * 4;

            const seedR = srcData[startIdx];
            const seedG = srcData[startIdx + 1];
            const seedB = srcData[startIdx + 2];

            const limit = tolerance * 4.4;

            while (stack.length) {
                const [x, y] = stack.pop();
                const visitIdx = y * width + x;

                if (visited[visitIdx]) continue;
                visited[visitIdx] = 1;

                const idx = visitIdx * 4;
                const currR = srcData[idx];
                const currG = srcData[idx + 1];
                const currB = srcData[idx + 2];

                const dist = Math.sqrt(
                    (currR - seedR) ** 2 +
                    (currG - seedG) ** 2 +
                    (currB - seedB) ** 2
                );

                if (dist <= limit) {
                    if (targetData[idx + 3] < 255) {
                        targetData[idx] = r;
                        targetData[idx + 1] = g;
                        targetData[idx + 2] = b;
                        targetData[idx + 3] = a;
                    }

                    if (x > 0) stack.push([x - 1, y]);
                    if (x < width - 1) stack.push([x + 1, y]);
                    if (y > 0) stack.push([x, y - 1]);
                    if (y < height - 1) stack.push([x, y + 1]);
                }
            }
        }

        function mrGrowMask(data, width, height, radius, r, g, b, a) {
            let alphaBuffer = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                alphaBuffer[i] = data[i * 4 + 3];
            }

            for (let step = 0; step < radius; step++) {
                let newAlphaBuffer = new Uint8Array(alphaBuffer);
                let changed = false;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = y * width + x;

                        if (alphaBuffer[i] === 0) {
                            let hasMaskNeighbor = false;

                            // Check 8 neighbors
                            if (x > 0 && alphaBuffer[i - 1] > 0) hasMaskNeighbor = true;
                            else if (x < width - 1 && alphaBuffer[i + 1] > 0) hasMaskNeighbor = true;
                            else if (y > 0 && alphaBuffer[i - width] > 0) hasMaskNeighbor = true;
                            else if (y < height - 1 && alphaBuffer[i + width] > 0) hasMaskNeighbor = true;
                            else if (x > 0 && y > 0 && alphaBuffer[i - width - 1] > 0) hasMaskNeighbor = true;
                            else if (x < width - 1 && y > 0 && alphaBuffer[i - width + 1] > 0) hasMaskNeighbor = true;
                            else if (x > 0 && y < height - 1 && alphaBuffer[i + width - 1] > 0) hasMaskNeighbor = true;
                            else if (x < width - 1 && y < height - 1 && alphaBuffer[i + width + 1] > 0) hasMaskNeighbor = true;

                            if (hasMaskNeighbor) {
                                newAlphaBuffer[i] = 255;
                                changed = true;
                            }
                        }
                    }
                }
                alphaBuffer = newAlphaBuffer;
                if (!changed) break;
            }

            for (let i = 0; i < width * height; i++) {
                // Apply color to new mask pixels
                if (alphaBuffer[i] > 0 && data[i * 4 + 3] === 0) {
                    data[i * 4] = r;
                    data[i * 4 + 1] = g;
                    data[i * 4 + 2] = b;
                    data[i * 4 + 3] = a;
                }
            }
        }

        function mrApplyColorReconstruction() {
            if (!mrState.originalImageData) return;
            // Debounce if currently drawing?
            if (mrState.isDrawing) return;

            const canvas = mrImageCanvas;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const maskCtx = mrMaskCanvas.getContext('2d');
            const maskData = maskCtx.getImageData(0, 0, width, height);

            const reconstructedImageData = new ImageData(
                new Uint8ClampedArray(mrState.originalImageData.data),
                width,
                height
            );
            const pixels = reconstructedImageData.data;
            const baseAlpha = mrState.intensity / 100;
            const thresholdLevel = (mrState.threshold / 100) * 255;

            for (let i = 0; i < pixels.length; i += 4) {
                const maskValue = maskData.data[i + 3];
                if (maskValue > 0) {
                    const R = pixels[i];
                    const G = pixels[i + 1];
                    const B = pixels[i + 2];
                    const brightness = 0.299 * R + 0.587 * G + 0.114 * B;
                    let shouldProcess = true;

                    if (mrState.watermarkColor === 'white') {
                        if (brightness < thresholdLevel) shouldProcess = false;
                    } else {
                        if (brightness > (255 - thresholdLevel)) shouldProcess = false;
                    }

                    if (shouldProcess) {
                        const maskWeight = maskValue / 255.0;
                        const effectiveAlpha = baseAlpha * maskWeight;
                        const div = Math.max(0.01, 1 - effectiveAlpha);
                        const W = mrState.watermarkColor === 'white' ? 255 : 0;
                        let newR = (R - W * effectiveAlpha) / div;
                        let newG = (G - W * effectiveAlpha) / div;
                        let newB = (B - W * effectiveAlpha) / div;
                        pixels[i] = Math.max(0, Math.min(255, newR));
                        pixels[i + 1] = Math.max(0, Math.min(255, newG));
                        pixels[i + 2] = Math.max(0, Math.min(255, newB));
                    }
                }
            }

            const finalPixels = new Uint8ClampedArray(pixels);
            // Fix 2: dilationRange = 6
            const dilationRange = 6;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    if (maskData.data[idx + 3] > 0) {
                        let bgR = 0, bgG = 0, bgB = 0;
                        let bgCount = 0;
                        for (let dy = -dilationRange; dy <= dilationRange; dy++) {
                            for (let dx = -dilationRange; dx <= dilationRange; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIdx = (ny * width + nx) * 4;
                                    if (maskData.data[nIdx + 3] === 0) {
                                        bgR += pixels[nIdx];
                                        bgG += pixels[nIdx + 1];
                                        bgB += pixels[nIdx + 2];
                                        bgCount++;
                                    }
                                }
                            }
                        }
                        if (bgCount > 0) {
                            finalPixels[idx] = bgR / bgCount;
                            finalPixels[idx + 1] = bgG / bgCount;
                            finalPixels[idx + 2] = bgB / bgCount;
                        }
                    }
                }
            }
            ctx.putImageData(new ImageData(finalPixels, width, height), 0, 0);
            mrUpdateResultImage();
        }

        async function mrApplyInpainting() {
            if (!mrState.image || mrState.isProcessing) return;
            mrState.isProcessing = true;
            mrLoadingOverlay.style.display = 'flex';
            mrProgress.textContent = '0';

            // Allow UI to update
            await new Promise(r => setTimeout(r, 50));

            const imgCanvas = mrImageCanvas;
            const ctx = imgCanvas.getContext('2d', { willReadFrequently: true });
            const maskCtx = mrMaskCanvas.getContext('2d', { willReadFrequently: true });
            const width = imgCanvas.width;
            const height = imgCanvas.height;

            const imgData = ctx.getImageData(0, 0, width, height);
            const maskData = maskCtx.getImageData(0, 0, width, height);
            const pixels = imgData.data;

            const isMasked = new Uint8Array(width * height);
            let maskedPixelCount = 0;

            for (let i = 0; i < width * height; i++) {
                if (maskData.data[i * 4 + 3] > 50) {
                    isMasked[i] = 1;
                    maskedPixelCount++;
                } else {
                    isMasked[i] = 0;
                }
            }

            if (maskedPixelCount === 0) {
                mrState.isProcessing = false;
                mrLoadingOverlay.style.display = 'none';
                return;
            }

            const patchRadius = 3;
            const searchRadius = Math.min(width, height) / 3;
            const initialMaskedCount = maskedPixelCount;

            const processBatch = async () => {
                let currentMaskedCount = maskedPixelCount;
                while (currentMaskedCount > 0) {
                    const contourPixels = [];
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (isMasked[idx] === 1) {
                                let hasCleanNeighbor = false;
                                if (x > 0 && isMasked[idx - 1] === 0) hasCleanNeighbor = true;
                                else if (x < width - 1 && isMasked[idx + 1] === 0) hasCleanNeighbor = true;
                                else if (y > 0 && isMasked[idx - width] === 0) hasCleanNeighbor = true;
                                else if (y < height - 1 && isMasked[idx + width] === 0) hasCleanNeighbor = true;
                                if (hasCleanNeighbor) contourPixels.push({ x, y });
                            }
                        }
                    }
                    if (contourPixels.length === 0) break;

                    const BATCH_SIZE = 500;
                    for (let i = 0; i < contourPixels.length; i += BATCH_SIZE) {
                        const batch = contourPixels.slice(i, i + BATCH_SIZE);
                        for (const point of batch) {
                            const { x, y } = point;
                            const targetIdx = (y * width + x) * 4;
                            let bestScore = Infinity;
                            let bestR = 0, bestG = 0, bestB = 0;
                            const SAMPLES = 10;

                            for (let s = 0; s < SAMPLES; s++) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = Math.random() * searchRadius;
                                const sx = Math.floor(x + Math.cos(angle) * dist);
                                const sy = Math.floor(y + Math.sin(angle) * dist);
                                if (sx < patchRadius || sx >= width - patchRadius || sy < patchRadius || sy >= height - patchRadius) continue;
                                const sourceCenterIdx = sy * width + sx;
                                if (isMasked[sourceCenterIdx] === 1) continue;

                                let score = 0;
                                let pixelCount = 0;
                                for (let py = -patchRadius; py <= patchRadius; py += 2) {
                                    for (let px = -patchRadius; px <= patchRadius; px += 2) {
                                        const ty = y + py;
                                        const tx = x + px;
                                        if (ty < 0 || ty >= height || tx < 0 || tx >= width) continue;
                                        const tPos = ty * width + tx;
                                        if (isMasked[tPos] === 0) {
                                            const soy = sy + py;
                                            const sox = sx + px;
                                            const sIdx = (soy * width + sox) * 4;
                                            const tIdx = tPos * 4;
                                            const dr = pixels[tIdx] - pixels[sIdx];
                                            const dg = pixels[tIdx + 1] - pixels[sIdx + 1];
                                            const db = pixels[tIdx + 2] - pixels[sIdx + 2];
                                            score += dr * dr + dg * dg + db * db;
                                            pixelCount++;
                                        }
                                    }
                                }
                                if (pixelCount > 0) {
                                    score /= pixelCount;
                                    if (score < bestScore) {
                                        bestScore = score;
                                        const bestSrcIdx = (sy * width + sx) * 4;
                                        bestR = pixels[bestSrcIdx];
                                        bestG = pixels[bestSrcIdx + 1];
                                        bestB = pixels[bestSrcIdx + 2];
                                    }
                                }
                            }
                            if (bestScore !== Infinity) {
                                pixels[targetIdx] = bestR;
                                pixels[targetIdx + 1] = bestG;
                                pixels[targetIdx + 2] = bestB;
                                isMasked[y * width + x] = 0;
                                currentMaskedCount--;
                            }
                        }
                        ctx.putImageData(imgData, 0, 0);
                        const progressPercent = Math.round(((initialMaskedCount - currentMaskedCount) / initialMaskedCount) * 100);
                        mrProgress.textContent = progressPercent;
                        await new Promise(r => setTimeout(r, 0));
                    }
                }
            };

            await processBatch();

            mrState.isProcessing = false;
            mrLoadingOverlay.style.display = 'none';
            maskCtx.clearRect(0, 0, width, height);
            mrState.maskPaths = [];
            mrUpdateResultImage();
        }

        function mrDownloadResult() {
            if (!mrState.resultImage) return;
            const link = document.createElement('a');
            link.download = 'watermark-removed.jpg';
            link.href = mrState.resultImage;
            link.click();
        }

        // Initialize
        initMagicRemoverEvents();



        /* =========================================
           End Magic Remover Logic
           ========================================= */

        /* =========================================
           HTML Cleaner Logic
           ========================================= */
        const cleanerInput = document.getElementById('cleanerInput');
        const cleanerOutput = document.getElementById('cleanerOutput');
        const cleanerRemovePath = document.getElementById('cleanerRemovePath');
        const cleanerRemoveIndex = document.getElementById('cleanerRemoveIndex');
        const cleanerNewAttr = document.getElementById('cleanerNewAttr');
        const cleanerAddAttrBtn = document.getElementById('cleanerAddAttrBtn');
        const cleanerAttrList = document.getElementById('cleanerAttrList');
        const cleanerNewTag = document.getElementById('cleanerNewTag');
        const cleanerAddTagBtn = document.getElementById('cleanerAddTagBtn');
        const cleanerTagList = document.getElementById('cleanerTagList');
        const cleanerClearBtn = document.getElementById('cleanerClearBtn');
        const cleanerUploadBtn = document.getElementById('cleanerUploadBtn');
        const cleanerFileInput = document.getElementById('cleanerFileInput');
        const cleanerDownloadBtn = document.getElementById('cleanerDownloadBtn');
        const cleanerCopyBtn = document.getElementById('cleanerCopyBtn');
        const cleanerAutocorrectPunct = document.getElementById('cleanerAutocorrectPunct');
        const cleanerAutocorrectSpace = document.getElementById('cleanerAutocorrectSpace');

        let cleanerOptions = {
            removeDataPathToNode: true,
            removeDataIndexInNode: true,
            autocorrectPunct: true,
            autocorrectSpace: true,
            customAttributes: [],
            customTags: []
        };

        function updateCleaner() {
            const html = cleanerInput.value;
            cleanerOptions.removeDataPathToNode = cleanerRemovePath.checked;
            cleanerOptions.removeDataIndexInNode = cleanerRemoveIndex.checked;
            cleanerOptions.autocorrectPunct = cleanerAutocorrectPunct.checked;
            cleanerOptions.autocorrectSpace = cleanerAutocorrectSpace.checked;
            const cleaned = cleanHtmlLogic(html, cleanerOptions);
            cleanerOutput.value = cleaned;
        }

        function cleanHtmlLogic(html, options) {
            if (!html) return "";
            const parser = new DOMParser();

            // å˜—è©¦è§£æ HTML
            let doc;
            try {
                doc = parser.parseFromString(html, "text/html");
            } catch (e) {
                console.error("HTML è§£æå¤±æ•—:", e);
                return html;
            }

            const walk = (node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node;

                    // ç§»é™¤å±¬æ€§
                    if (options.removeDataPathToNode) {
                        if (el.hasAttribute("data-path-to-node")) el.removeAttribute("data-path-to-node");
                    }
                    if (options.removeDataIndexInNode) {
                        if (el.hasAttribute("data-index-in-node")) el.removeAttribute("data-index-in-node");
                    }

                    options.customAttributes.forEach(rawAttr => {
                        if (!rawAttr) return;
                        const attrName = rawAttr.split('=')[0].trim();
                        if (attrName && el.hasAttribute(attrName)) el.removeAttribute(attrName);
                    });
                } else if (node.nodeType === Node.TEXT_NODE) {
                    let text = node.textContent;
                    if (options.autocorrectPunct) {
                        text = text.replace(/,/g, 'ï¼Œ')
                            .replace(/;/g, 'ï¼›')
                            .replace(/:/g, 'ï¼š')
                            .replace(/\./g, 'ã€‚')
                            .replace(/\(/g, 'ï¼ˆ')
                            .replace(/\)/g, 'ï¼‰');
                    }
                    if (options.autocorrectSpace) {
                        // ä¸­è‹±æ–‡é–“è·å„ªåŒ–ï¼šä¸­æ–‡èˆ‡è‹±æ–‡/æ•¸å­—ä¹‹é–“åŠ ç©ºæ ¼
                        text = text.replace(/([\u4e00-\u9fa5])([a-zA-Z0-9])/g, '$1 $2')
                            .replace(/([a-zA-Z0-9])([\u4e00-\u9fa5])/g, '$1 $2');
                    }
                    node.textContent = text;
                }

                // éè¿´è™•ç†å­ç¯€é»
                let child = node.firstChild;
                while (child) {
                    const next = child.nextSibling;
                    walk(child);
                    child = next;
                }

                // è™•ç†æ¨™ç±¤å±•é–‹ (Unwrap)
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node;
                    const tagName = el.tagName.toLowerCase();
                    if (options.customTags.includes(tagName)) {
                        const parent = el.parentNode;
                        if (parent) {
                            while (el.firstChild) {
                                parent.insertBefore(el.firstChild, el);
                            }
                            parent.removeChild(el);
                        }
                    }
                }
            };

            const isFullDocument = html.trim().toLowerCase().startsWith("<!doctype") || html.trim().toLowerCase().startsWith("<html");

            if (isFullDocument) {
                walk(doc.documentElement);
                return doc.documentElement.outerHTML;
            } else {
                walk(doc.body);
                return doc.body.innerHTML;
            }
        }

        function renderCleanerTags() {
            cleanerAttrList.innerHTML = '';
            cleanerOptions.customAttributes.forEach(attr => {
                const tag = document.createElement('div');
                tag.className = 'cleaner-tag';
                tag.innerHTML = `<span>${attr}</span><span class="cleaner-tag-remove" onclick="removeCleanerAttr('${attr}')">Ã—</span>`;
                cleanerAttrList.appendChild(tag);
            });

            cleanerTagList.innerHTML = '';
            cleanerOptions.customTags.forEach(tagName => {
                const tag = document.createElement('div');
                tag.className = 'cleaner-tag';
                tag.innerHTML = `<span>${tagName}</span><span class="cleaner-tag-remove" onclick="removeCleanerTag('${tagName}')">Ã—</span>`;
                cleanerTagList.appendChild(tag);
            });
        }

        window.removeCleanerAttr = (attr) => {
            cleanerOptions.customAttributes = cleanerOptions.customAttributes.filter(a => a !== attr);
            renderCleanerTags();
            updateCleaner();
        };

        window.removeCleanerTag = (tagName) => {
            cleanerOptions.customTags = cleanerOptions.customTags.filter(t => t !== tagName);
            renderCleanerTags();
            updateCleaner();
        };

        cleanerAddAttrBtn.addEventListener('click', () => {
            const val = cleanerNewAttr.value.trim();
            if (val && !cleanerOptions.customAttributes.includes(val)) {
                cleanerOptions.customAttributes.push(val);
                cleanerNewAttr.value = '';
                renderCleanerTags();
                updateCleaner();
            }
        });

        cleanerAddTagBtn.addEventListener('click', () => {
            const val = cleanerNewTag.value.trim().toLowerCase();
            if (val && !cleanerOptions.customTags.includes(val)) {
                cleanerOptions.customTags.push(val);
                cleanerNewTag.value = '';
                renderCleanerTags();
                updateCleaner();
            }
        });

        cleanerInput.addEventListener('input', updateCleaner);
        cleanerRemovePath.addEventListener('change', updateCleaner);
        cleanerRemoveIndex.addEventListener('change', updateCleaner);
        cleanerAutocorrectPunct.addEventListener('change', updateCleaner);
        cleanerAutocorrectSpace.addEventListener('change', updateCleaner);

        cleanerClearBtn.addEventListener('click', () => {
            cleanerInput.value = '';
            updateCleaner();
        });

        cleanerUploadBtn.addEventListener('click', () => cleanerFileInput.click());
        cleanerFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                cleanerInput.value = event.target.result;
                updateCleaner();
            };
            reader.readAsText(file);
        });

        cleanerCopyBtn.addEventListener('click', () => {
            cleanerOutput.select();
            document.execCommand('copy');
            alert('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿');
        });

        cleanerDownloadBtn.addEventListener('click', () => {
            const blob = new Blob([cleanerOutput.value], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cleaned.html';
            a.click();
            URL.revokeObjectURL(url);
        });

        /* =========================================
           End HTML Cleaner Logic
           ========================================= */
    </script>



</body>

</html>